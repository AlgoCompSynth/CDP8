/*
 * Copyright (c) 1983-2020 Trevor Wishart and Composers Desktop Project Ltd
 * http://www.trevorwishart.co.uk
 * http://www.composersdesktop.com
 *
 This file is part of the CDP System.
 
 The CDP System is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 The CDP System is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with the CDP System; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 02111-1307 USA
 *
 */
#include <stdio.h>
#include <standalone.h>
#include <string.h>
#include <speccon.h>
#include <science.h>

#define RRRR_EXTEND (345)
#define SEMITONES_PER_OCTAVE (12)

static void RoomReverbFormat(void);
const char* cdp_version = "6.1.0";

/******************************** TKUSAGE_OTHER ********************************/

int main(int argc, char *argv[])
{
    int process, mode;
    if(argc==2 && (strcmp(argv[1],"--version") == 0)) {
        fprintf(stdout,"%s\n",cdp_version);
        fflush(stdout);
        return 0;
    }
    if(argc!=3) {
        fprintf(stdout,"ERROR: Error in usage program tkusage_other\n");
        return -1;
    }
    if(sscanf(argv[1],"%d",&process)!=1) {
        fprintf(stdout,"ERROR: Failed to read process number in tkusage_other\n");
        return -1;
    }
    if(sscanf(argv[2],"%d",&mode)!=1) {
        fprintf(stdout,"ERROR: Failed to read process number in tkusage_other\n");
        return -1;
    }
    switch(process) {
    case(TAPDELAY):
        fprintf(stdout,"INFO: STEREO MULTI-TAPPED DELAY WITH SPATIAL POSITIONING OF DELAYS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DELAY TIMES AMPS (& POSITIONS). A Text Datafile.\n");
        fprintf(stdout,"INFO:       Each line has either 2 values (TIME , AMPLITUDE of one delay).\n");
        fprintf(stdout,"INFO:                    or 3 values (third value specifies spatial POSITION of this delay in the stereo space).\n");
        fprintf(stdout,"INFO:       TIMES (seconds) must be increasing. Duplicate times are ignored.\n");
        fprintf(stdout,"INFO:       A zero time (no delay) overrides the mix parameter,\n");
        fprintf(stdout,"INFO:       and determines the level and pan of the (effectively mono) input.\n");
        fprintf(stdout,"INFO:       AMP values must be in the range 0.0 to 1.0\n");
        fprintf(stdout,"INFO:       Empty lines and lines starting with a semi-colon (e.g. comments) are permitted.\n");
        fprintf(stdout,"INFO:       If a Position value is used in any line, outfile will be stereo.\n");
        fprintf(stdout,"INFO:       POSITION values are nominally in the range -1 to +1:     0 = centre.\n");
        fprintf(stdout,"INFO:       If all position values are 0, the output will be mono.\n");
        fprintf(stdout,"INFO:       Values beyond these limits result in attenuation according to the\n");
        fprintf(stdout,"INFO:       inverse-square law, to suggest distance beyond the speakers.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT GAIN ...........Gain applied to output signal.\n");
        fprintf(stdout,"INFO: FEEDBACK ..............Proportion of output signal fed back into input.\n");
        fprintf(stdout,"INFO:                                       (Negative values invert phase of feedback).\n");
        fprintf(stdout,"INFO: SOURCE SIGNAL IN MIX...Proportion of original src sound mixed with the delay-output.\n");
        fprintf(stdout,"INFO: DECAY TAIL DURATION....Time allowed for delays to decay to zero.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(RMRESP):
        fprintf(stdout,"INFO: GENERATE ROOM RESPONSE DATA SUITABLE FOR USE WITH REVERB PROGRAMS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LIVENESS...................... degree of reflection from each surface.\n");
        fprintf(stdout,"INFO: NUMBER OF REFLECTIONS......... number of reflections from each surface.\n");
        fprintf(stdout,"INFO:            (WARNING: high values will create extremely long data files!).\n");
        fprintf(stdout,"INFO: ROOM LENGTH, WIDTH, HEIGHT.... The size of the room, in metres.\n");
        fprintf(stdout,"INFO: SRC POSITION, LENGTHWAYS, WIDTHWAYS & HEIGHT within the room, in metres.\n");;
        fprintf(stdout,"INFO: LISTENER POSITION LENGTHWAYS, WIDTHWAYS, & HEIGHT within the room, in metres.\n");;
        fprintf(stdout,"INFO: PEAK AMPLITUDE OF DATA\n");
        fprintf(stdout,"INFO: REFLECTION TIME RESOLUTION (MS).\n");;
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT is a text datafile suitable for use with MULTIPLE-DELAYS, REVERB or ROOM REVERB processes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB: The first output time is non-zero.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(RMVERB):
        fprintf(stdout,"INFO: MULTI-CHANNEL REVERB WITH ROOM SIMULATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: An OPTIONAL Text Datafile. (Enter '0' to use preset values instead)......\n");
        RoomReverbFormat();
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ROOM SIZE......................1 small, 2 medium, 3 large.\n");
        fprintf(stdout,"INFO: DENSE REVERB GAIN..............level of the dense reverberation.\n");
        fprintf(stdout,"INFO: SOURCE SIGNAL IN MIX...........Proportion of original src sound mixed with the delay-output.\n");
        fprintf(stdout,"INFO: FEEDBACK ......................Proportion of output signal fed back into input.\n");
        fprintf(stdout,"INFO: AIR-ABSORPTION FILTER CUTOFF...Cutoff frq (Hz) of low pass filter modelling air absorption.\n");
        fprintf(stdout,"INFO:                                       (typically 2500Hz for Large room, 4200Hz for small: set to ZERO for NO absorption).\n");
        fprintf(stdout,"INFO: LOWPASS REVERB-INPUT CUTOFF....Cutoff frq (Hz) of low pass filter on input to reverb.\n");
        fprintf(stdout,"INFO:                                       (set to ZERO for NO filtering of input).\n");
        fprintf(stdout,"INFO: DECAY TAIL DURATION............Time allowed for delays to decay to zero.\n");
        fprintf(stdout,"INFO: LOWPASS INPUT CUTOFF...........Cutoff frq (Hz) of low pass filter on source.\n");
        fprintf(stdout,"INFO: HIGHPASS INPUT CUTOFF..........Cutoff frq (Hz) of high pass filter on source.\n");
        fprintf(stdout,"INFO: REVERB PREDELAY (MS)...........Force delay to start at specified time.\n");
        fprintf(stdout,"INFO: NUMBER OF OUTPUT CHANNELS......Defaults to stereo.\n");
        fprintf(stdout,"INFO: DOUBLE AIR-ABSORPTION.........(Reduces reverb time: Increase Feedback to compensate).\n");
        fprintf(stdout,"INFO: FLOATING POINT OUTPUT FILE.....or not.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MIXMULTI):
        fprintf(stdout,"INFO: MULTI-CHANNEL MIXING FOR UP TO 64-CHANNELS, WITH CHANNEL CROSS-THREADING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIXING STARTTIME...starttime in mix (to start mixing later than zero).\n");
        fprintf(stdout,"INFO: MIXING ENDTIME.....endtime in mix (to stop mix before its true end).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Note that the START and END params intended for mix TESTING purposes only.\n");
        fprintf(stdout,"INFO: If you want to keep output from such a testmix, you should TOPNTAIL it.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ATTENUATION.......reduce the mix level, if necessary.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIXFILE FORMAT FOR MULTICHANNEL MIXING:\n");
        fprintf(stdout,"INFO: The first line indicates the number of output channels.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The ensuing lines have the following format   e.g.\n");
        fprintf(stdout,"INFO: snd1.wav 0.0 4  1:1 .5 2:2 .5 3:3 .5 4:4 .5\n");
        fprintf(stdout,"INFO: snd2.wav 2.0 4  1:1 .25 2:1 .25 3:1 .25 4:1 .25\n");
        fprintf(stdout,"INFO: snd3.wav 2.0 16 2:3 .25 4:1 .25\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Each line consists of:\n");
        fprintf(stdout,"INFO: 1)  Name of a soundfile\n");
        fprintf(stdout,"INFO: 2)  Entry time of that sound in the mix\n");
        fprintf(stdout,"INFO: 3)  Channel count of the input sound\n");
        fprintf(stdout,"INFO: 4)  A ROUTING CODE for the input channels, followed by a level for that routing.\n");
        fprintf(stdout,"INFO: The code consists of a number indicating the input channel, a colon, and\n");
        fprintf(stdout,"INFO: a number indicating the output channel in the final mix.\n");
        fprintf(stdout,"INFO: In line 1 (1:1 2:2 3:3 4:4) each input channel goes to the corresponding output channel\n");
        fprintf(stdout,"INFO: In line 2 (1:1 2:1 3:1 4:1) all input channels are mixed into channel 1 of the output\n");
        fprintf(stdout,"INFO: In line 3 (2:3 4:1) channels 2 & 4 ONLY of input, are routed to chans 3 & 1 of the output\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: So the input channels can be threaded to any output channel desired.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ANALJOIN):
        fprintf(stdout,"INFO: SPLICE TOGETHER A SEQUENCE OF ANALYSIS FILES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NO PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PTOBRK):
        fprintf(stdout,"INFO: CONVERT BINARY PITCH DATA TO BRKPNT FILE, RETAINING NO-PITCH MARKERS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: TIME, IN MS, THAT ANY STRETCH OF PITCH-DATA MUST PERSIST, TO BE VALID.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_STRETCH):
        fprintf(stdout,"INFO: TIME-STRETCH A SOUND USING PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO: 2) STRETCH FACTOR\n");
        fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Timestretching alters pitch: twice as long, down an octave.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_DUPL):
        fprintf(stdout,"INFO: DUPLICATE PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) NUMBER OF DUPLICATIONS.\n");
        fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_DEL):
        fprintf(stdout,"INFO: DELETE PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) ONE IN HOW MANY BLOCKS TO KEEP.\n");
        fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_STRFILL):
        fprintf(stdout,"INFO: TIME-STRETCH A SOUND USING PITCH-SYNCHRONOUS ENVELOPED GRAINS, AND GRAIN DUPLICATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) STRETCH FACTOR\n");
        fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
        fprintf(stdout,"INFO: 4) TRANSPOSITION IN SEMITONES:\n");
        fprintf(stdout,"INFO: Only certain harmonics-related transpositions work.\n");
        fprintf(stdout,"INFO: and these interact in strange ways with the time-stretch parameter,");
        fprintf(stdout,"INFO: sometimes producing octaves.\n");
        fprintf(stdout,"INFO:         e.g. with a time-stretch of 2, these transpositions work...\n");
        fprintf(stdout,"INFO:         -12 (octave down), 12 (octave up)  24 (2 octaves up).\n");
        fprintf(stdout,"INFO:         7 (major 5th), 16 (octave + major 3rd) 19 (octave + 5th)  22 (octave + minor 7th).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_FREEZE):
        fprintf(stdout,"INFO: GRAB ONE OR MORE PITCH-SYNCHRONISED GRAINS AND USE TO CONSTRUCT A NEW SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) TIME IN SOURCE WHERE GRAIN(S) GRABBED.\n");
        fprintf(stdout,"INFO: 3) DURATION OF FILE TO BE CREATED.\n");
        fprintf(stdout,"INFO:       Duration oz ZERO will cause a single (block of) grain(s) to be grabbed,\n");
        fprintf(stdout,"INFO: 4) NUMBER OF GRAINS TO GRAB: IF more than 1, this set is used as a block.\n");
        fprintf(stdout,"INFO: 5) DENSITY (PITCH TRANSPOSITION)\n");
        fprintf(stdout,"INFO:       Density 2      Grains overlap so there are always 2 grains playing at once.\n");
        fprintf(stdout,"INFO:       Density 3      Grains overlap so there are always 3 grains playing at once.\n");
        fprintf(stdout,"INFO:       Density 0.5    One grain followed by one gap, of same duration.\n");
        fprintf(stdout,"INFO:       Density 0.25   One grain followed by a gap of three times the duration.\n");
        fprintf(stdout,"INFO:       With a single (or very few) grain(s), Density can be equivalent to transposition ratio.\n");
        fprintf(stdout,"INFO:       For pitched grains, the fundamental is transposed, but not the spectrum.\n");
        fprintf(stdout,"INFO:       Very high fixed densities produce a file with just 2 thumps (only).\n");
        fprintf(stdout,"INFO:       Glissandos through densities above c 2 produce pitch steps rather than a smooth glide.\n");
        fprintf(stdout,"INFO: 6) SPECTRAL TRANSPOSITION: transposes the spectrum but not the fundamental.\n");
        fprintf(stdout,"INFO:       The particular way in which Density and Spectral Transpositions operate\n");
        fprintf(stdout,"INFO:       depends on the size of segments (no of grains) you choose,\n");
        fprintf(stdout,"INFO:       and the particular nature of the grains (pitched, noisy etc.).\n");
        fprintf(stdout,"INFO: 7) RANDOMISATION of the position of the output grain(blocks).\n");
        fprintf(stdout,"INFO:       Randomisation adds noise to any clearly-pitched grain-source.\n");
        fprintf(stdout,"INFO: 8) OVERALL GAIN (If density is > 1.0, gain may need to be reduced).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_CHOP):
        fprintf(stdout,"INFO: REMOVE PITCH-SYNCHRONOUD GRAINS FROM A FILE, AT SPECIFIED TIMES,\n");
        fprintf(stdout,"INFO: AND KEEP THE REMAINING SEPARATED PARTS OF THE SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) TIME - GRAIN-COUNT FILE.\n");
        fprintf(stdout,"INFO:       Each pair specifies time at which grains are to be found\n");
        fprintf(stdout,"INFO:       and how many grains to omit between the cut sections.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Outputs are the sections of sound left behind once these grains are taken out.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_INTERP):
        fprintf(stdout,"INFO: INTERPOLATE BETWEEN PITCH-SYNCHRONOUS GRAINS,\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) Sustain Duration of first grain.\n");
        fprintf(stdout,"INFO: 2) Duration of Interpolation.\n");
        fprintf(stdout,"INFO: 3) Sustain Duration of final grain.\n");
        fprintf(stdout,"INFO: 4) VIBRATO FREQUENCY.\n");
        fprintf(stdout,"INFO: 5) VIBRATO DEPTH.\n");
        fprintf(stdout,"INFO: 6) TREMOLO FREQUENCY.\n");
        fprintf(stdout,"INFO: 7) TREMOLO DEPTH.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB This process assumes that the input files are single pitch-synchronous grains.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_FEATURES):
        fprintf(stdout,"INFO: ADD NEW FEATURES TO SOUND ANALYSED INTO PITCH-SYNCHRONOUS GRAINS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) PITCH SHIFTING IS ACCOMPANIED BY TIMEWARPING.\n");
        fprintf(stdout,"INFO:       If the pitch goes up, the sound gets shorter, if down, longer.\n");
        fprintf(stdout,"INFO: 2) PITCH SHIFTING IS ACCOMPANIED BY PITCH_DIVISION.\n");
        fprintf(stdout,"INFO:       Results in 2 pitches, the highest at the specified transposition.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
        fprintf(stdout,"INFO: 3)  TRANSPOSITION (semitones).\n");
        fprintf(stdout,"INFO: 4)  VIBRATO FREQUENCY.\n");
        fprintf(stdout,"INFO: 5)  VIBRATO DEPTH (semitones).\n");
        fprintf(stdout,"INFO: 6)  SPECTRAL TRANSPOSITION (semitones).\n");
        fprintf(stdout,"INFO: 7)  HOARSENESS smaller values (c.0.04) are most effective.\n");
        fprintf(stdout,"INFO: 8)  ATTENUATION.\n");
        fprintf(stdout,"INFO: 9)  FOF-STRETCHING:    N.B. This TURNS OFF spectral transposition.\n");
        fprintf(stdout,"INFO: 10) SUBHARMONIC NUMBER: Divides pitch-frequency to produce subharmonic. Must be at least 2.\n");
        fprintf(stdout,"INFO: 11) SUBHARMONIC LEVEL:  Level of any subharmonic introduced.\n");
        fprintf(stdout,"INFO: 12) ALTERNATIVE ALGORITHM FOR FOF_STRETCH.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_SYNTH):
        fprintf(stdout,"INFO: USE VOCAL FOFS AS CONTOUR ON SYNTHESIZED SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WITH A FIXED BAND OF OSCILLATORS.\n");
        fprintf(stdout,"INFO:       Data file is exactly like that for a User-defined Filterbank.\n");
        fprintf(stdout,"INFO: 1)    BANDS AS FRQ (HZ):..Filter-pitches as frq in Hz.....paired with an amplitude.\n");
        fprintf(stdout,"INFO: 2)    BANDS AS MIDI:......Filter-pitches as MIDI values.....paired with an amplitude.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WITH A TIME-VARYING BANK OF OSCILLATORS.\n");
        fprintf(stdout,"INFO:       Data file is exactly like that for a User-defined Time-varying Filterbank.\n");
        fprintf(stdout,"INFO: 3)    BANDS AS FRQ (HZ):..Filter-pitches as frq in Hz.\n");
        fprintf(stdout,"INFO: 4)    BANDS AS MIDI:......Filter-pitches as MIDI values.\n");
        fprintf(stdout,"INFO:       For full details, see 'User-defined Time-varying Filterbank' information.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 5) WITH NOISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  TABLE OF FREQUENCIES AND AMPLITUDES, DEFINING A BANK OF OSCILLATORS.\n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 3)  DEPTH OF FOF CONTOURING (1 TOTAL .... 0, NONE AT ALL).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_IMPOSE):
        fprintf(stdout,"INFO: IMPOSE VOCAL FOFS IN 1ST SOUND ON A 2ND INPUT SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  DEPTH OF FOF CONTOURING (1 TOTAL .... 0, NONE AT ALL).\n");
        fprintf(stdout,"INFO: 3)  WINDOW SIZE (mS) FOR ENVELOPE TRACKING 2ND INPUT SOUND.\n");
        fprintf(stdout,"INFO: 4)  GATE LEVEL (dB) BELOW WHICH 2ND INPUT SIGNAL IS TO BE IGNORED.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_SPLIT):
        fprintf(stdout,"INFO: SPLIT VOCAL SOUND INTO SUBHARMONICS AND UPWARD-TRANSPOSED FEATURES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  SUBHARMONIC NUMBER (DIVIDES VOICE FREQUENCY).\n");
        fprintf(stdout,"INFO: 3)  UPWARD TRANSPOSITION (SEMITONES).\n");
        fprintf(stdout,"INFO: 4)  SUPPRESSION OF UPWARD-TRANSPOSED COMPONENTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_SPACE):
        fprintf(stdout,"INFO: SEPARATE FOFS OF A MONO VOCAL SOUND IN STEREO SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  SUBHARMONIC NUMBER (DIVIDES VOICE FREQUENCY).\n");
        fprintf(stdout,"INFO: 3)  SPATIAL SEPARATION.\n");
        fprintf(stdout,"INFO:           0  NO SEPARATION.\n");
        fprintf(stdout,"INFO:           1  SPLITS ALTERNATELY TO FULL RIGHT/LEFT.\n");
        fprintf(stdout,"INFO:           -1 SPLITS ALTERNATELY TO FULL LEFT/RIGHT.\n");
        fprintf(stdout,"INFO: 4)  LEFT/RIGHT RELATIVE LEVEL.\n");
        fprintf(stdout,"INFO:           RL = 1.0  LEFT & RIGHT LEVELS EQUAL.\n");
        fprintf(stdout,"INFO:           RL > 1.0  LEFT SIGNAL DIVIDED BY RL. BIAS TO RIGHT\n");
        fprintf(stdout,"INFO:           RL < 1.0  RIGHT SIGNAL MULTIPLIED BY RL. BIAS TO LEFT\n");
        fprintf(stdout,"INFO: 5)  SUPPRESS HIGH COMPONENTS.\n");
        fprintf(stdout,"INFO:           0 = NONE.\n");
        fprintf(stdout,"INFO:           1 = COMPLETE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_INTERLEAVE):
        fprintf(stdout,"INFO: INTERLEAVE FOFS OF 2 SOUNDS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE FOR 1ST SND, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE FOR 2ND SND, SIMILARLY.\n");
        fprintf(stdout,"INFO: 3)  NO OF FOFS TREATED AS A UNIT FOR THE PROCESS.\n");
        fprintf(stdout,"INFO: 4)  PITCH BIAS.\n");
        fprintf(stdout,"INFO:           0  NO BIAS.\n");
        fprintf(stdout,"INFO:           1  PITCH FORCED TOWARDS THAT OF 1ST SND.\n");
        fprintf(stdout,"INFO:           -1 PITCH FORCED TOWARDS THAT OF 2ND SND.\n");
        fprintf(stdout,"INFO: 5)  RELATIVE LEVEL.\n");
        fprintf(stdout,"INFO:           RL = 1.0  1ST & 2ND SOUNDS OF EQUAL LEVEL.\n");
        fprintf(stdout,"INFO:           RL > 1.0  2ND SOUND LEVEL DIVIDED BY RL. BIAS TO 1ST\n");
        fprintf(stdout,"INFO:           RL < 1.0  1ST SOUND LEVEL MULTIPLIED BY RL. BIAS TO 2ND\n");
        fprintf(stdout,"INFO: 6)  RELATIVE WEIGHT.\n");
        fprintf(stdout,"INFO:           RW = 1.0  1ST & 2ND SOUNDS ALTERNATE.\n");
        fprintf(stdout,"INFO:           RL > 1.0  1ST SOUND OCCURS RL TIMES MORE THAN 2ND\n");
        fprintf(stdout,"INFO:           RL < 1.0  2ND SOUND OCCURS 1/RL TIMES MORE THAN 1ST\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_REPLACE):
        fprintf(stdout,"INFO: COMBINE FOFS OF 1ST SOUND WITH PITCH OF 2ND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE FOR 1ST SND, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE FOR 2ND SND, SIMILARLY.\n");
        fprintf(stdout,"INFO: 3)  NO OF FOFS TREATED AS A UNIT FOR THE PROCESS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_EXTEND):
        fprintf(stdout,"INFO: EXTEND A SOUND BY FREEZING IT AT A SPECIFIED TIME, USING A PITCH-SYNCD GRAIN.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:        Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2)  TIME IN SOURCE WHERE GRAIN(S) GRABBED.\n");
        fprintf(stdout,"INFO: 3)  DURATION OF TOTAL FILE ONCE IT IS STRETCHED.\n");
        fprintf(stdout,"INFO: 4)  NUMBER OF GRAINS TO GRAB: IF more than 1, this set is used as a block.\n");
        fprintf(stdout,"INFO: 5)  VIBRATO FREQUENCY.\n");
        fprintf(stdout,"INFO: 6)  VIBRATO DEPTH (semitones).\n");
        fprintf(stdout,"INFO: 7)  GRAIN PITCH TRANSPOSITION (semitones).\n");
        fprintf(stdout,"INFO:        In any brkpntfiles used here, zero time refers to start of \n");
        fprintf(stdout,"INFO:        bring expanded, and NOT (necessarily) to start of sound.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 8)  SMOOTH FOFS.\n");
        fprintf(stdout,"INFO:        Imposes a smoothing window on the extracted FOF(s)\n");
        fprintf(stdout,"INFO:        attempting to remove any high frequency buzz effects.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_EXTEND2):
        fprintf(stdout,"INFO: EXTEND A SOUND BY FREEZING IT AT A SPECIFIED TIME, USING A PITCH-SYNCD GRAIN.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) TIME AT WHICH GRAIN STARTS.\n");
        fprintf(stdout,"INFO: 2) TIME AT WHICH GRAIN ENDS.\n");
        fprintf(stdout,"INFO: 3) DURATION OF TOTAL FILE ONCE IT IS STRETCHED.\n");
        fprintf(stdout,"INFO: 4)  VIBRATO FREQUENCY.\n");
        fprintf(stdout,"INFO: 5)  VIBRATO DEPTH (semitones).\n");
        fprintf(stdout,"INFO: 6)  NUDGE: GRAIN-TIMES MOVED FORWARD OR BACK BY 'NUDGE' ZERO-CROSSINGS.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_LOCATE):
        fprintf(stdout,"INFO: LOCATE EXACT TIME OF START OF GRAIN, NEAREST TO A GIVEN TIME.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) TIME.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_CUT):
        fprintf(stdout,"INFO: CUT SOUND AT GRAIN START NEAREST TO SPECIFIED TIME.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) KEEP SOUND BEFORE SPECIFIED GRAIN-TIME.\n");
        fprintf(stdout,"INFO: 2) KEEP SOUND AT AND AFTER SPECIFIED GRAIN-TIME.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 2) TIME.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ONEFORM_GET):
        fprintf(stdout,"INFO: EXTRACT FORMANT AT A SPECIFIED TIME, FROM A FORMANT FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) TIME AT WHICH TO EXTRACT FORMANT.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ONEFORM_PUT):
        fprintf(stdout,"INFO: IMPOSE ON SPECTRUM IN AN ANALYSIS FILE\n");
        fprintf(stdout,"INFO: THE SPECTRAL ENVELOPE IN A SINGLE-FORMANT FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: REPLACE FORMANTS......New formants REPLACE existing formant envelope.\n");
        fprintf(stdout,"INFO: SUPERIMPOSE FORMANTS..New formants IMPOSED ON TOP OF existing formants.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LOW FRQ LIMIT...frq, below which spectrum is set to zero.\n");
        fprintf(stdout,"INFO: HIGH FRQ LIMIT..frq, above which spectrum is set to zero.\n");
        fprintf(stdout,"INFO: GAIN............adjustment to spectrum loudness (normally < 1.0).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ONEFORM_COMBINE):
        fprintf(stdout,"INFO: GENERATE SPECTRUM FROM BINARY-PITCHFILE & SINGLE-FORMANT-DATA.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: outfile is analysis file which must be resynthesized to hear.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(NEWGATE):
        fprintf(stdout,"INFO: GATE A SIGNAL TO ZERO WHERE IT FALLS BELOW A CERTAIN LEVEL.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: GATE LEVEL...in decibels.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPEC_REMOVE):
        fprintf(stdout,"INFO: REMOVE SPECIFIC PITCH (AREA) FROM A SPECTRUM, OR REMOVE COMPONENTS NOT OF PITCH (AREA).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: 1) REMOVE PITCH.\n");
        fprintf(stdout,"INFO: 2) REMOVE NON_PITCH.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MINIMUM PITCH (MIDI).\n");
        fprintf(stdout,"INFO: MAXIMUM PITCH (MIDI).\n");
        fprintf(stdout,"INFO: MODE 1) FREQUENCY ABOVE WHICH HARMONICS ARE NOT REMOVED (HZ).\n");
        fprintf(stdout,"INFO: MODE 2) FREQUENCY ABOVE WHICH HARMONICS ARE NOT RETAINED (HZ).\n");
        fprintf(stdout,"INFO: ATENUATION OF SPECIFIED COMPONENTS.\n");
        fprintf(stdout,"INFO:          (1 = full attenuation, 0 = no attenuation).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Process removes all components, and their harmonics, in the given pitch range,\n");
        fprintf(stdout,"INFO: as far as the given frequency limit.\n");
        fprintf(stdout,"INFO: (Or, mode 2, removes all components which are NOT in the pitch range or that of its harmonics)\n");
        fprintf(stdout,"INFO: as far as the given frequency limit.\n");
        fprintf(stdout,"INFO: Pitch range of an octave or more will remove (retain) all spectral components\n");
        fprintf(stdout,"INFO: between the lower pitch and the upper frequency limit\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PREFIXSIL):
        fprintf(stdout,"INFO: ADD SILENCE AT START OF SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION of silence to add.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(STRANS):
        fprintf(stdout,"INFO: CHANGE SPEED & PITCH OF MULTICHANNEL SOURCE SOUND, OR CREATE VIBRATO.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) SPEED CHANGE...............also changing sound pitch.\n");
        fprintf(stdout,"INFO: 2) SPEED CHANGE IN SEMITONES..speed shift given in semitones.\n");
        fprintf(stdout,"INFO:    For BOTH these modes, brkpnt times are infiletimes, unless flagged as outfiletimes.\n");
        fprintf(stdout,"INFO: 3) ACCELERATE SOURCE TO GIVEN SPEED..speed shift given as multiplier.\n");
        fprintf(stdout,"INFO: 4) VIBRATO THE SOURCE....with given speed and depth (possibly time-varying).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1. Speed change as a speed multiplier.\n");
        fprintf(stdout,"INFO: MODE 2. Speed change in semitones.\n");
        fprintf(stdout,"INFO: MODE 3\n");
        fprintf(stdout,"INFO:      ACCELERATION as speed multiplier at the goal time.\n");
        fprintf(stdout,"INFO:      GOAL TIME is speed at which 'acceleration' speed is achieved.\n");
        fprintf(stdout,"INFO:      START TIME is time in source where acceleration begins.\n");
        fprintf(stdout,"INFO: MODE 4\n");
        fprintf(stdout,"INFO:      VIBRATO FREQUENCY is rate of vibrato, in Hz (can vary over time).\n");
        fprintf(stdout,"INFO:      VIBRATO DEPTH is depth of vibrato, in semitones (can vary over time).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PSOW_REINF):
        fprintf(stdout,"INFO: REINFORCE HARMONICS OR ADD INHARMONIC CONSTITUENTS IN SOUND WITH (VOCAL) FOFS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) REINFORCE HARMONICS.\n");
        fprintf(stdout,"INFO: 2) ADD INHARMONIC ELEMENTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  TABLE OF HARMONIC NUMBERS AND AMPLITUDES.\n");
        fprintf(stdout,"INFO:         These define which harmonics are added to the original source, (range 2 to 256)\n");
        fprintf(stdout,"INFO:         and what their relative-levels are (src assumed to be at level 1.0) (range >0  to 16).\n");
        fprintf(stdout,"INFO:         The output is scaled down in level, if clipping might occur.\n");
        fprintf(stdout,"INFO:         In MODE 2, these 'harmonics' can be FRACTIONAL.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In MODE 1\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DON'T DUPLICATE HARMONICS : FOFs corresponding to higher harmonics which\n");
        fprintf(stdout,"INFO: coincide with FOFs corresponding to lower harmonics, are omitted.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In MODE 1\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DELAY OF HARMONICS: mS delay applied (progressively) to harmonics.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In MODE 2\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WEIGTH : Determines how long inharmonic constituents are sustained.\n");
        fprintf(stdout,"INFO: In some circumstances very high weights may cause the memory to overflow.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PARTIALS_HARM):
        fprintf(stdout,"INFO: EXTRACT RELATIVE AMPLITUDES OF PARTIALS IN A PITCHED SOURCE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) SINGLE-WINDOW ANALYSIS FILE -> FRQ DATA.\n");
        fprintf(stdout,"INFO: 2) SINGLE-WINDOW ANALYSIS FILE -> MIDI DATA.\n");
        fprintf(stdout,"INFO: 3) MULTI-WINDOW ANALYSIS FILE -> FRQ DATA.\n");
        fprintf(stdout,"INFO: 4) MULTI-WINDOW ANALYSIS FILE -> MIDI DATA.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  FUNDAMENTAL FREQUENCY:  Fundamental frequency of the window.\n");
        fprintf(stdout,"INFO: 2)  THRESHOLD AMPLITUDE:  Relative level below which partials are ignored.\n");
        fprintf(stdout,"INFO: 3)  TIME OF WINDOW:  (Modes 3 & 4 only) Time, in analysis file, where partials to be found.\n");
        fprintf(stdout,"INFO: 4)  OUTPUT IN VARIPARTIALS FILTER FORMAT:  Outputs data in file-format for varipartials filter.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in the relevant place).\n");
        break;
    case(SPECROSS):
        fprintf(stdout,"INFO: INTERPOLATE PARTIALS OF PITCHED SRC2 TOWARDS THOSE OF PITCHED SRC 1,\n");
        fprintf(stdout,"INFO: RETAINING THE DURATION OF SRC2, AND THE ATTACK LOCATION OF SRC1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: IN-TUNE RANGE:  Semitone range within which harmonics 'in tune'.\n");
        fprintf(stdout,"INFO: MIN WINDOWS TO CONFIRM PITCH:   Minimum number of adjacent windows that must be pitched,\n");
        fprintf(stdout,"INFO:                  for a pitch-value to be registered.\n");
        fprintf(stdout,"INFO: SIGNAL TO NOISE RATIO:  Signal to noise ratio, in decibels.\n");
        fprintf(stdout,"INFO:                  Windows which fall at or below this level, relative to the maximum level in the sound,\n");
        fprintf(stdout,"INFO:                  are assumed to be noise, & any detected pitch is ignored.\n");
        fprintf(stdout,"INFO: VALID HARMONICS COUNT:  Number of the 8 loudest peaks in spectrum which must be harmonics\n");
        fprintf(stdout,"INFO:                  to confirm that the sound is pitched: Default 5.\n");
        fprintf(stdout,"INFO: LOW PITCH LIMIT:  Lowest acceptable frequency (Hz) at which a pitch value is acceptable.\n");
        fprintf(stdout,"INFO: HIGH PITCH LIMIT:  Highest acceptable frequency (Hz) at which a pitch value is acceptable.\n");
        fprintf(stdout,"INFO: PARTIAL THRESHOLD AMPLITUDE:  The threshold amplitude is measured relative to the loudest partial in the window.\n");
        fprintf(stdout,"INFO:                  Any (possible) partial data which falls below this level is ignored.\n");
        fprintf(stdout,"INFO: OUTPUT LEVEL:  Level of the output spectrum. Vary only if reapplying src1 to several src2s,\n");
        fprintf(stdout,"INFO:                  when the relative levels of the src2s are important.\n");
        fprintf(stdout,"INFO: SPECTRAL_INTERPOLATION:  Degree of interpolation between Src2 and Src1.\n");
        fprintf(stdout,"INFO:                  Zero gives the original (cleaned) src 2, 1 gives src1 only.\n");
        fprintf(stdout,"INFO:                  The degree of interpolation may vary (with time) through the sound.\n");
        fprintf(stdout,"INFO:                  Times in any breakpoint file will be scaled to the duration of Src1.\n");
        fprintf(stdout,"INFO: RETAIN FILE2 CONTOUR UNDER FILE1 CONTOUR so amplitude fluctuations of File1 still apparent at max interpolation.\n");
        fprintf(stdout,"INFO: EXTEND 1ST STABLE PITCH OF FILE1 TO START so very start of File 1 is assumed to be pitched.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Assumes the input files are clearly pitched (at least in the relevant place).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: A typical application would use a (relatively) stable-pitched source for Src1,\n");
        fprintf(stdout,"INFO: while Src2 might vary in pitch (e.g. a speaking voice), but this is not essential.\n");
        break;
    case(LUCIER_GETF):
        fprintf(stdout,"INFO: EXTRACT ROOM-RESONANCE FROM A RECORDING AND CREATE A FILTER-DATA FILE FOR 'FILTER VARIBANK'.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIN ROOM DIMENSION (METRES):  Enter ZERO to ignore roomsize.\n");
        fprintf(stdout,"INFO: ROLLOFF INTERVAL: Interval (in semitones) over which resonance fades to zero, above the max resonance frq dictated by room dimensions.\n");
        fprintf(stdout,"INFO: LOW_FRQ_CUTOFF:      Ignore resonances below this frequency.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Longer recordings give better results.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(LUCIER_GET):
        fprintf(stdout,"INFO: EXTRACT ROOM-RESONANCE FROM A RECORDING AND CREATE A CORRESPONDING ANALYSIS DATA FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIN ROOM DIMENSION (METRES):  Enter ZERO to ignore roomsize.\n");
        fprintf(stdout,"INFO: ROLLOFF INTERVAL: Interval (in semitones) over which resonance fades to zero, above the max resonance frq dictated by room dimensions.\n");
        fprintf(stdout,"INFO: RESOLVE LOW FRQS: Attempt to resolve low frequency resonances more accurately.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(LUCIER_PUT):
        fprintf(stdout,"INFO: IMPOSE ROOM-RESONANCE FROM A RECORDING (EXTRACTED USING 'LUCIER GET') ONTO AN ANALYSIS FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RESONANCE COUNT:      Number of times the room resonance is (cumulatively) added to the sound.\n");
        fprintf(stdout,"INFO: OCTAVE DUPLICATION ROLLOFF:  If NOT set to zero (default), room resonance is duplicated at higher octaves,\n");
        fprintf(stdout,"INFO:          with resonance level multiplied (cumulatively) by this attenuation from 8va to 8va.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(LUCIER_DEL):
        fprintf(stdout,"INFO: ATTEMPT TO REMOVE ROOM-RESONANCE (EXTRACTED USING 'LUCIER GET') FROM A RECORDING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SUPPRESSION:   Degree of suppression of room acoustic.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECLEAN):
        fprintf(stdout,"INFO: REMOVE PERSISTENT NOISE FROM SPECTRUM, BY COMPARISON WITH AN EXTRACT OF THE NOISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PERSISTANCE (mS):   Time for which signal in a channel must exceed threshold defined by noise input before it is allowed to pass.\n");
        fprintf(stdout,"INFO: NOISE PREGAIN:          Threshold level for passing clean signal is level of noise signal times this pregain.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECTRACT):
        fprintf(stdout,"INFO: REMOVE PERSISTENT NOISE FROM SPECTRUM, BY SUBTRACTING AN EXTRACT OF THE NOISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PERSISTANCE (mS):   Time for which signal in a channel must exceed threshold defined by noise input before it is allowed to pass.\n");
        fprintf(stdout,"INFO: NOISE PREGAIN:          Threshold level for passing clean signal is level of noise signal times this pregain.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The noise-signal level is also subtracted from any signal exceeding the threshold.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PHASE):
        fprintf(stdout,"INFO: INVERT PHASE, OR ENHANCE STEREO IMAGE BY PHASE CANCELLATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) INVERT  PHASE OF MONO OR STEREO SIGNAL.\n");
        fprintf(stdout,"INFO: 2) ENHANCE STEREO IMAGE, BY PHASE CANCELLATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PHASE TRANSFER: (Mode 2 only) Amount of phase-inverted other-channel used to enhance stereo.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(BRKTOPI):
        fprintf(stdout,"INFO: CONVERT TEXT PITCH-DATA TO BINARY PITCH DATA.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Pitch data is written to a default format binary file.\n");
        break;
    case(SPECSLICE):
        fprintf(stdout,"INFO: SALAMI-SLICE SPECTRUM INTO (INTERLEAVED) FREQUENCY BANDS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) SLICE SPECTRUM BY ANALYSIS CHANNELS.\n");
        fprintf(stdout,"INFO: 2) SLICE SPECTRUM BY FREQUENCY BANDS.\n");
        fprintf(stdout,"INFO: 3) SLICE SPECTRUM BY PITCH BANDS.\n");
        fprintf(stdout,"INFO: 4) SLICE SPECTRUM BY HARMONICS OF EXTRACTED PITCH.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER_OF_SLICES : with 3 slices (and 1 channel per slice) Slice-1 = chans 1,4,7...etc   Slice-2 = chans 2,4,8.etc Slice-3 = chans 3,6,9.etc\n");
        fprintf(stdout,"INFO: ANALYSIS_CHANNEL_GROUPING : with 3 slices and grouping 2   Slice-1 = chans 1-2,7-8,13-14...etc   Slice-2 = chans 3-4,9-10..etc Slice-3 = chans 5-6,11-12..etc\n");
        fprintf(stdout,"INFO: SLICE_BANDWIDTH: width of slices in Hz: with Hz 100 and 2 slices: Slice-1 = 0-100Hz + 200-300Hz + 400-500Hz..etc Slice-2 = 100-200Hz + 300-400Hz ..etc\n");
        fprintf(stdout,"INFO: SLICE_WIDTH_IN_SEMITONES: width of slices in semitones.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(FOFEX_EX):
        fprintf(stdout,"INFO: EXTRACT AND ORGANISE FOFS IN A SOUND IN ORDER TO RE-USE THEM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)   EXTRACT ALL FOF(GROUP)S SUBJECT TO EXCLUSIONS, TO SPECIAL FOF-STORAGE SOUNDFILE.\n");     
        fprintf(stdout,"INFO: 2)   EXTRACT SINGLE FOF(GROUP) AT SPECIFIED TIME.\n");     
        fprintf(stdout,"INFO: 3)   EXTRACT ALL FOF(GROUP)S SUBJECT TO EXCLUSIONS, TO SEPARATE SOUNDFILES.\n");     
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES 1 & 3\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  LIST OF SECTIONS OF THE SOURCE (AS PAIRS OF SAMPLETIMES) FROM WHICH ~NO~ FOFS ARE TO BE TAKEN.\n");
        fprintf(stdout,"INFO:           IF THERE ARE NO SUCH AREAS, ENTER THE PARAMETER VALUE \"0\"\n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES,\n");
        fprintf(stdout,"INFO:     AND DERIVED FROM THE INPUT SOUNDFILE.\n");
        fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 3)  A dB VALUE: FOFS WHICH ARE LESS THAN THIS LEVEL BELOW THE MAX FOF LEVEL ARE REJECTED.\n");
        fprintf(stdout,"INFO:       N.B. A value of ZERO, RETAINS ALL FOFS.\n");
        fprintf(stdout,"INFO: 4)  GROUPED FOFS: Extracts FOFs in (originally adjacent) pairs, triples, etc.\n");
        fprintf(stdout,"INFO: 5)  NO FOF WINDOWING: Cosine shaping is normally applied to starts and ends of FOFs. Set this flag for NO windowing.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: IN MODE 1: OUTPUT IS A SPECIAL SOUNDFILE CONTAINING A BANK OF FOFS,\n");
        fprintf(stdout,"INFO:            AND A TEXTFILE PROVIDING INFORMATION ABOUT THE 'FOFBANK'\n");
        fprintf(stdout,"INFO:            THESE CAN BE USED WITH 'FOF reconstruct'\n");
        fprintf(stdout,"INFO: IN MODE 3: OUTPUT IS A SET OF SOUNDFILES EACH CONTAINING A SINGLE (GROUP OF) FOF(S).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 2\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, AS ABOVE\n");
        fprintf(stdout,"INFO: 2)  TIME IN FILE AT WHICH TO EXTRACT FOF(GROUP).\n");
        fprintf(stdout,"INFO: 3)  GROUPED FOFS: EXTRACT A GROUP OF N FOFs.\n");
        fprintf(stdout,"INFO: 4)  NO FOF WINDOWING: AS ABOVE.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(FOFEX_CO):
        fprintf(stdout,"INFO: USE A BANK OF FOFS EXTRACTED WITH 'FOF extract' TO SYNTHESIZE A NEW SOUND OVER A PITCHLINE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: INPUT FILE----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MUST BE A BANK OF FOFS DERIVED FROM A SOUND USING 'FOF extract'\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)   Use 1 FOF.\n");     
        fprintf(stdout,"INFO: 2)   All FOFs superimposed to make output FOF.\n");
        fprintf(stdout,"INFO: 3)   Low FOFs superimposed to make output FOF.\n");
        fprintf(stdout,"INFO: 4)   Midrange FOFs superimposed to make output FOF.\n");
        fprintf(stdout,"INFO: 5)   High FOFs superimposed to make output FOF.\n");
        fprintf(stdout,"INFO: 6)   2 FOFs whose balance varies with pitch.\n");
        fprintf(stdout,"INFO: 7)   3 FOFs whose balance varies with pitch and level.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  TEXTFILE DERIVED FROM 'FOF extract' WHEN YOU CREATED THE (INPUT) FOFBANK.\n");
        fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
        fprintf(stdout,"INFO:          (But no NO-PITCH markers). Extract the pitch to a binary file, then do the conversion to text.\n");
        fprintf(stdout,"INFO: 3)  LOUDNESS CONTOUR BREAKPOINT DATA, AS TEXT.\n");
        fprintf(stdout,"INFO: 4)  OVERALL GAIN (FOFS may overlap one another).\n");
        fprintf(stdout,"INFO: 5)  THE FOF(S) TO BE USED (their number in the FOFBANK file, counting from 1) - USE \"SOUND VIEW\"\n");
        fprintf(stdout,"INFO: 6)  EQUALISE FOF LEVELS: Adjusts all FOFs to same level before synthesizing output.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(GREV_EXTEND):
        fprintf(stdout,"INFO: LOCATE AND EXTEND 'GRAINS', USING ENVELOPE TROUGHS AND ZERO-CROSSING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: This process locates elements of a sound by searching for troughs in the envelope.\n");
        fprintf(stdout,"INFO: and extends the segment in a coherent way.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (MS) .... This determines the size of grains that might be found..\n");
        fprintf(stdout,"INFO: DEPTH OF TROUGHS AS PROPORTION OF PEAK HEIGHT .... e.g. with value .5, troughs between peaks\n");
        fprintf(stdout,"INFO:                    which do not fall to half the peak-height, are ignored\n");
        fprintf(stdout,"INFO: EXTEND_BY_HOW_MUCH .... How much time to add to file, by extending specified grain area\n");
        fprintf(stdout,"INFO: TIME_WHERE_GRAINS_START\n");
        fprintf(stdout,"INFO: TIME_WHERE_GRAINS_END\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PEAKFIND):
        fprintf(stdout,"INFO: LIST TIMES OF PEAKS IN A SOUNDFILE (ESPECIALLY FOR SPEECH).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Locates prominent peaks, separated by troughs, and save a list of their timings.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (MS) .... This determines the width of peaks that might be found..\n");
        fprintf(stdout,"INFO: THRESHOLD .... any window falling entirely below this level is assumed to contain no peaks.\n");
        fprintf(stdout,"INFO: Peaks must have a level greater than the  threshold, and be separated by signal lower than the threshold.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If \"threshold\" is set to ZERO, program searches for threshold values appropriate to the local level,\n");
        fprintf(stdout,"INFO: by finding the local maximum in %d windows around the immediate window\n",LOCALMAX_WINDOW);
        fprintf(stdout,"INFO: and then divides this by a factor of %d\n",LOCALPEAK_DECIMATE);
        fprintf(stdout,"INFO: \n");
        break;
    case(CONSTRICT):
        fprintf(stdout,"INFO: SHRINK THE DURATION OF ANY ZERO-LEVEL SEGMENTS IN A SOUND, BY A GIVEN PERCENTAGE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Works only with sounds having segments of (completely) zero level.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PERCENTAGE DECIMATION .... Percentage of zero-level segments to delete\n");
        fprintf(stdout,"INFO: Values greater than 100 cause the separated segments to be overlaid.\n");
        fprintf(stdout,"INFO: e.g. 102 overlays very slightly, 200 overlays completely.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(EXPDECAY):
        fprintf(stdout,"INFO: CURTAIL SOUND USING A TRUE EXPONENTIAL ENVELOPE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECAY START TIME\n");
        fprintf(stdout,"INFO: DECAY END TIME.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PEAKCHOP):
        fprintf(stdout,"INFO: ISOLATE PEAKS IN SOURCE, AND PLAY THEM BACK AT A SPECIFIED TEMPO.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  PLAY BACK PEAKS AT SPECIFIED TEMPO\n");
        fprintf(stdout,"INFO: 2)  OUTPUT PEAK-ISOLATING ENVELOPE\n");
        fprintf(stdout,"INFO: 3)  PLAY BACK PEAKS IN SPECIFIED RHYTHMIC CELLS AT SPECIFIED TEMPO\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RHYTHM CELL .... rhythm-cell speficied in integers = relative durations of rhythmic units.\n");
        fprintf(stdout,"INFO:                                           Rhythmic units DIVIDE beat, so e.g. \"3 1 2\" becomes \"1/2 1/6 1/3\".\n");
        fprintf(stdout,"INFO: WINDOW SIZE (MS) .... windowsize (in mS) for creating envelope.\n");
        fprintf(stdout,"INFO: PEAK WIDTH (MS).... width of retained peaks (in mS).\n");
        fprintf(stdout,"INFO: RISE TIME (MS).... time for signal to rise to (and fall from) the retained peaks.\n");
        fprintf(stdout,"INFO: TEMPO .... tempo of resulting output as MM (events per minute).\n");
        fprintf(stdout,"INFO: GAIN .... where tempo and peakwidth combine to make events overlap, may be necessary to reduce gain.\n");
        fprintf(stdout,"INFO: TEMPO SCATTER ....randomisation of output times (0-1)\n");
        fprintf(stdout,"INFO: GATE ....level (relative to maximum signal level) below which peaks are ignored (0-1)\n");
        fprintf(stdout,"INFO: LEVELLING .... force peakevent levels towards level of maximum event.\n");
        fprintf(stdout,"INFO: CENTRING ....centring of envelope on peak (0-1): 0 = at peak at envelope start; 1 = peak at envelope end.\n");
        fprintf(stdout,"INFO: REPETITION .... repeat peakevents in the source.\n");
        fprintf(stdout,"INFO: SKIP BY .... after using a peakevent, miss out the next 'skip by' peakevents.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHANPAN):
        fprintf(stdout,"INFO: PAN A FILE OVER MORE THAN 2 OUTPUT CHANNELS.\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: MODE 1:  MOVE MONO SOUND AROUND A MULTICHANNEL SPACE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PANNING DATA .... is a file containing value triples : time  pan-position  pantype\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         PAN-POSITION vals lie between (channel) 1 and a max no-of-channels >= 3.\n");
            fprintf(stdout,"INFO:         positions between 0 and 1 are also possible (see below).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         PANTYPE values can be\n");
            fprintf(stdout,"INFO:         0  = direct pan: pan from 1 to 4 goes directly between lspkrs 1->4\n");
            fprintf(stdout,"INFO:         1  = clockwise rotation: pan from 1 to 4 goes through intermediate lspkrs 1->2->3->4\n");
            fprintf(stdout,"INFO:          (assuming lspks are arranged with numbering increasing in a clockwise direction).\n");
            fprintf(stdout,"INFO:         -1 = anticlockwise rotation: pan from 1 to 4 (with 8 lspkrs) goes 1->8->7->6->5->4\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         Direct pans must start at a single loudspeaker, so position vals must be integers (and NOT 0).\n");
            fprintf(stdout,"INFO:         Rotations can start and stop anywhere, so position values can be fractional,\n");
            fprintf(stdout,"INFO:         and values between 0 & 1 are positions between maximum lspkr (e.g. 8) and lspkr 1\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the panning data.\n");
            fprintf(stdout,"INFO:         but it can be greater.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
            fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
            fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
            fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: MODE 2:  SWITCH (SILENCE-SEPARATED) MONO EVENTS IN SOUND BETWEEN SPECIFIED CHANNELS OF OUTPUT.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OUT-CHANNEL SEQUENCE .... is a file containing a list of output channels.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         Each output channel in the list will be visited, in turn.\n");
            fprintf(stdout,"INFO:         If the end of the list is reached, the sequence wraps back to the start of the list.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the switching data.\n");
            fprintf(stdout,"INFO:         but it can be greater.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
            fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
            fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
            fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
            fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(2):
            fprintf(stdout,"INFO: MODE 3:  SPREAD SUCCESSIVE (SILENCE-SEPARATED) MONO EVENTS ON DIFFERENT NUMBERS OF CHANNELS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Events are spread over specified output channels.\n");
            fprintf(stdout,"INFO: If the centre, width or depth of the spread are changing in time,\n");
            fprintf(stdout,"INFO: the placement of events changes only at the onset of a new event in the input.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRE OF SPREAD ....... Channel from which spreading radiates.\n");
            fprintf(stdout,"INFO: CHANNEL SPREAD ......... Total Number of channels over which spreading extends.\n");
            fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT .. Number of channels (on each side) activated behind spreading front.\n");
            fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
            fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
            fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
            fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
            fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
            fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRE, SPREAD and DEPTH can vary over time.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(3):
            fprintf(stdout,"INFO: MODE 4:  SPREAD SOUND GRADUALLY OVER DIFFERENT NUMBERS OF CHANNELS (MONO OR STEREO INPUT).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Events are spread over specified output channels.\n");
            fprintf(stdout,"INFO: If the centre, width or depth of the spread are changing in time,\n");
            fprintf(stdout,"INFO: the placement of events changes continuously.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRE OF SPREAD ....... Channel from which spreading radiates (must be an integer).\n");
            fprintf(stdout,"INFO: CHANNEL SPREAD ......... Total Number of channels over which spreading extends.\n");
            fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT .. Number of channels (on each side) activated behind spreading front.\n");
            fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
            fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
            fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
            fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRE AND SPREAD can vary continuously over time.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(4):
            fprintf(stdout,"INFO: MODE 5:  ANTIPHONALLY SWAP (SILENCE-SEPARATED) EVENTS IN SOUND BETWEEN TWO SETS OF OUTPUT-CHANNELS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Events are switched between one set of output channels and another.\n");
            fprintf(stdout,"INFO: Event switching occurs only at the onset of a new event.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ANTIPHONAL CHANNEL SETS ..... two strings of letters, with separator ('-')\n");
            fprintf(stdout,"INFO:          representing the 2 sets of output channels to alternate between.\n");
            fprintf(stdout,"INFO:          e.g. abcd-efgh = antiphony between output channels 1,2,3,4 and output channels 5,6,7,8.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the antiphony data,\n");
            fprintf(stdout,"INFO:         but it can be greater.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
            fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(5):
            fprintf(stdout,"INFO: MODE 6:  ANTIPHONALLY SWITCH BETWEEN TWO SETS OF OUTPUT-CHANNELS, USING 1 OR MORE SOUNDS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Sound output is switched between one set of output channels and another.\n");
            fprintf(stdout,"INFO: Event switching occurs at specified times and, if several files are input, the next sound in the input list is used.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ANTIPHONAL CHANNEL SETS ..... two strings of letters, with separator ('-')\n");
            fprintf(stdout,"INFO:          representing the 2 sets of output channels to alternate between.\n");
            fprintf(stdout,"INFO:          e.g. abcd-efgh = antiphony between output channels 1,2,3,4 and output channels 5,6,7,8.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the antiphony data,\n");
            fprintf(stdout,"INFO:         but it can be greater.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ANTIPHONY_TIMESTEP ..... Timestep before the output switches to the next set of output channels.\n");
            fprintf(stdout,"INFO:                       Can vary through time.\n");
            fprintf(stdout,"INFO: SILENT GAP BETWEEN ANTIPHONAL EVENTS ... Silence separating antiphonal events (if any).\n");
            fprintf(stdout,"INFO:                       Can vary through time.\n");
            fprintf(stdout,"INFO:                       Cannot be equal to or less than the minimum antiphony_timestep.\n");
            fprintf(stdout,"INFO: SPLICELENGTH (mS) ...... Length of splices fading in and out the antiphonal events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
            fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(6):
            fprintf(stdout,"INFO: MODE 7:  PAN FROM ONE CHANNEL CONFIGURATION TO ANOTHER, PASSING \"THROUGH the CENTRE\".\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PANNING DATA .... is a file containing a list of lines, each having : time  pan-positions\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         TIME value must increase, from one entry to the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         PAN-POSITIONS is a list of ALL the output channels in any order.\n");
            fprintf(stdout,"INFO:         Input channels 1 to N are mapped, in order, to the channels in your list.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         On moving from one list to the next, every input channel spreads outwards until\n");
            fprintf(stdout,"INFO:         it feeds every output channel, then gradually focuses into its next output-channel position.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:         To force all inputs to feed all outputs at the start of the sound, at the end of the sound,\n");
            fprintf(stdout,"INFO:         or at any point during the sound, enter a map of zeros (one zero for every input channel)\n");
            fprintf(stdout,"INFO:         at the starttime, and at the endtime, of the desired period.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
            fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
            fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
            fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(7):
            fprintf(stdout,"INFO: MODE 8:  PAN A PROCESS ROUND A MULTICHANNEL FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The input multichannel sound remains where it is.\n");
            fprintf(stdout,"INFO: The processing itself progresses around the output space in the manner you define.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRE OF PROCESSING  ....... Channel where processing is located.\n");
            fprintf(stdout,"INFO: CHANNEL SPREAD OF PROCESSING .....Total Number of channels over which processing spreads.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(8):
            fprintf(stdout,"INFO: MODE 9:  ROTATE MONO SOUND AROUND MULTICHANNEL SPACE, SPECIFYING (POSSIBLY VARYING) SPEED.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the panning data.\n");
            fprintf(stdout,"INFO:         but it can be greater.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: START CHANNEL ...... Channel in which sound starts out.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPEED (CYCLES PER SEC) ...... Speed of rotation.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
            fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
            fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
            fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ANTICLOCKWISE ...... Force rotation to be anticlockwise (default: clockwise).\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(9):
            fprintf(stdout,"INFO: MODE 10:  SWITCH (SILENCE-SEPARATED) MONO EVENTS IN SOUND BETWEEN RANDOMLY PERMUTED CHANNELS OF OUTPUT.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
            fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
            fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
            fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
            fprintf(stdout,"INFO:          to constitute a silent 'gap' between events in source-sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EVENT GROUP SIZE ......... number of events at any channel, before switching to next.\n");
            fprintf(stdout,"INFO:          Can vary through time.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NO STEPS TO ADJACENT CHANNELS.......Reject moving to an adjacent output channel.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOMLY VARY GROUP SIZE.......number of events at any channel, before switching to next,\n");
            fprintf(stdout,"INFO:          can vary randomly from specified size down to just 1.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(TEX_MCHAN):
        fprintf(stdout,"INFO: TEXTURE MADE FROM ONE OR SEVERAL INPUT SOUND FILES, TO MANY OUTPUT CHANNELS\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: HARMONIC TYPES OF TEXTURE------------------------------------------------------\n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Textures are specified WITHIN A (possibly varying) RANGE OF PITCHES\n");
        fprintf(stdout,"INFO: and within that range, the chosen pitches may be\n");
        fprintf(stdout,"INFO: entirely RANDOM, on a HARMONIC SET (using pitches given),\n");
        fprintf(stdout,"INFO: on a HARMONIC FIELD (uses 8va transpositions of pitches given),\n");
        fprintf(stdout,"INFO: or on HARMONIC SETS, OR FIELDS, WHICH CHANGE THROUGH TIME.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: First note (only) of motifs are guaranteed to be on a harmonic set(field) note\n");
        fprintf(stdout,"INFO: except in MOTIFS IN HF, where motifs notes are forced onto set (field) notes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: PARAMETERS FOR TEXTURE---------------------------------------------------------\n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (** starred items CANNOT VARY in time)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT DURATION...........**.(min) duration of outfile\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- TIMING PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: EVENT PACKING ...............(average) time between event onsets.\n");
        fprintf(stdout,"INFO: SKIPTIME BETWEEN GROUP,MOTIF ONSETS..(average) time between group,motif onsets.\n");
        fprintf(stdout,"INFO: EVENT SCATTER................randomisation of event, group or motif onsets.\n");
        fprintf(stdout,"INFO: TIME GRID UNIT...............minstep(MS) quantised timegrid (for event starttimes)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- SOUND PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1ST SND-IN-LIST TO USE,LAST..1st,last snd to use,from listed input sounds.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- LOUDNESS PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIN EVENT GAIN, MAX..........min & max level of input events\n");
        fprintf(stdout,"INFO: MIN EVENT SUSTAIN, MAX.......min & max sustain-time of events.\n");
        fprintf(stdout,"INFO: OVERALL ATTENUATION..........overall attenuation of the output\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- PITCH PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MIN PITCH, MAX...............min & max pitch(MIDI): (gives transposition of input)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- SPATIAL PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SPATIAL POSITION.............centre of output sound-image.\n");
        fprintf(stdout,"INFO: SPATIAL SPREAD...............spatial-spread of texture events (0 to all-outchans).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If spatial spread is set to ZERO ....\n");
        fprintf(stdout,"INFO: With MONO sources, output is distributed randomly over all output channels\n");
        fprintf(stdout,"INFO: with no events in positions BETWEEN output channels (all events IN single loudspeakers).\n");
        fprintf(stdout,"INFO: With STEREO sources, each stereo event is assigned to a random pair of output channels,\n");
        fprintf(stdout,"INFO: and these pairs are randomly permuted, so all channels used before any channel visited a 2nd time.\n");
        fprintf(stdout,"INFO: With panning sources, this produces a set of random pan-motions using all channels equally.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------- OTHER PARAMETERS -----------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SEED.........................same seed-number: reproducible output (0: not so)\n");
        fprintf(stdout,"INFO: PLAY ALL OF INSOUND..........always play whole input-sound (ignoring dur vals).\n");
        fprintf(stdout,"INFO: PLAY FILES CYCLICALLY........play sounds in input order (always uses ALL input sounds).\n");
        fprintf(stdout,"INFO: RANDOMLY PERMUTE EACH CYCLE..permute order of sounds, in each complete cycle.\n");
        fprintf(stdout,"INFO: FIXED POSITIONS..............infiles set at fixed positions in output.\n");
        fprintf(stdout,"INFO:          This option only functions if the output channel count > 2\n");
        fprintf(stdout,"INFO:          and output positions are located on stereo-images formed by alternate lspkrs\n");
        fprintf(stdout,"INFO:          (i.e. stereo 1-3, stereo 2-4, stereo 3-5 etc)\n");
        fprintf(stdout,"INFO:          In this case, \"SPATIAL POSITION\" is read as an offset of the placement of output positions\n");
        fprintf(stdout,"INFO:          With no offset, first sounds entered are on the channels 1-3 stereo image.\n");
        fprintf(stdout,"INFO:          With offset of 1 first sounds entered are on the channels 2-4 stereo image, and so on\n");
        fprintf(stdout,"INFO:          \"SPATIAL SPREAD\" is read as a randomisation of these positions\n");
        fprintf(stdout,"INFO:          with a range 0 to 1 (entered values above 1 are truncated to 1).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: NOTEDATA IS A TEXTFILE CONTAINING-----------------------------------------------\n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LINE 1: list of (possibly fictional) MIDI pitch of each input snd.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Then, where  harmonic sets or harmonic fields are required,\n");
        fprintf(stdout,"INFO: each subsequent group of lines specifies a NOTELIST\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: NOTELISTS HAVE THE FOLLOWING FORMAT---------------------------------------------\n");
        fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: first line:  #N\n");
        fprintf(stdout,"INFO: other lines: time(SECS)     infile_no      pitch(MIDI)      amp(MIDI)     dur(SECS)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: where N = number of notes (and therefore lines) in notelist to follow,\n");
        fprintf(stdout,"INFO: and times in notelist must never decrease.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (The amp(MIDI) and dur(SECS) params are now redundant, but need to be included).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MANYSIL):
        fprintf(stdout,"INFO: INSERT SEVERAL SILENCES IN A SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SILENCE LOCATION & DURATION .....time/duration value pairs, being the times in the sound to insert the silences,\n");
        fprintf(stdout,"INFO:                                 and the durations of the inserted silences..\n");
        fprintf(stdout,"INFO: SPLICE LENGTH .... length of splices, in mS.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(RETIME):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: MODE 1:  RETIME USER-IDENTIFIED PEAKS IN SOUND, PLACING THEM AT REGULAR BEATS AT SPECIFIED MM.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: LOCATIONS OF BEATS .....list of times of events corresponding to beats, in original sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
            fprintf(stdout,"INFO:        (Marked events in source will be placed at regular beats at this MM in output)\n");
            fprintf(stdout,"INFO:        Values between 20 and 400 are interpreted as MM\n");
            fprintf(stdout,"INFO:        Values below 1.0 are interpreted as beat duration\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: MODE 2:  RETIME EVENTS IN ANY SOUND, USING RETIMING DATA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RETIMING DATA .....which consists of.\n");
            fprintf(stdout,"INFO:      (a) MM of rhythm of accents in original sound.\n");
            fprintf(stdout,"INFO:      (b) Time, in the outfile, of the first accented event.\n");
            fprintf(stdout,"INFO:      (c) Two columns of (increasing) time-data. \n");
            fprintf(stdout,"INFO:             (1) The true position of the attacks in the original sound.\n");
            fprintf(stdout,"INFO:             (2) The ideal(ised) position of those attacks.\n");
            fprintf(stdout,"INFO:                    NB time of first-accented event must equal a time in this 2nd list.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:      This Data can be generated AUTOMATICALLY from the 'rcode' property in a properties file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required OUTPUT tempo.\n");
            fprintf(stdout,"INFO:       Values between 20 and 400 are interpreted as MM\n");
            fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PEAKWIDTH (mS) .... ..width to which peak events will be cut, in output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPLICE LENGTH (mS) .... risetime to events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(2):
            fprintf(stdout,"INFO: MODE 3:  SHORTEN (SILENCE-SEPARATED) EVENTS IN A SOUND, USING PEAKWIDTH DATA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OUTPUT PEAKWIDTH .............. width (in mS) of peaks required in output sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OUTPUT SPLICE LENGTH .... ...time (in mS) for splice cutoff of events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ORIGINAL SPLICE LENGTH .. time (in mS) of splices at end of events in original data.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(3):
            fprintf(stdout,"INFO: MODE 4:  RETIME (SILENCE-SEPARATED) EVENTS IN SOUND, PLACING THEM AT REGULAR BEATS AT SPECIFIED MM.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
            fprintf(stdout,"INFO:       (Marked events in source will be placed at regular beats at this MM in output)\n");
            fprintf(stdout,"INFO:       Values between 20 and 400 are interpreted as MM\n");
            fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PREGAIN .... Gain applied to input\n");
            fprintf(stdout,"INFO:       possibly set less than 1.0 where existing grains overlap in output.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(4):
            fprintf(stdout,"INFO: MODE 5:  RETIME (SILENCE-SEPARATED) EVENTS IN SOUND, CHANGING THEIR TIMING BY A GIVEN FACTOR.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TEMPO-CHANGE FACTOR .... increases or decreases tempo of events.\n");
            fprintf(stdout,"INFO:       Factor may vary over time.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TEMPO-CHANGE STARTS AFTER .... Events not moved before this time.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TEMPO-CHANGE ENDS BEFORE .... Events not moved after this time.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SYNCHRONISATION TIME .... .. Time of event in input which will sync with its copy in output.\n");
            fprintf(stdout,"INFO:                    Time should be WITHIN the desired event. Zero implies sync at 1st event.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(5):
            fprintf(stdout,"INFO: MODE 6:  REPOSITION (SILENCE-SEPARATED) EVENTS AT SPECIFIED BEATS, AT SPECIFIED TEMPO.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: BEAT LOCATIONS OF EVENTS .... positioning of output events, counted as beats.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
            fprintf(stdout,"INFO:       Values between 20 and 1000 are interpreted as MM\n");
            fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIME OF FIRST SOUNDING EVENT IN OUTPUT .... in seconds.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:       between peak events.\n");
            fprintf(stdout,"INFO: PREGAIN .... Applied to output: may be necessary if retimed events overlap one another.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(6):
            fprintf(stdout,"INFO: MODE 7:  REPOSITION (SILENCE-SEPARATED) EVENTS AT SPECIFIED TIMES.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIME LOCATIONS OF EVENTS .... positioning of output events, indicated in seconds.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIME OF FIRST SOUNDING EVENT IN OUTPUT .... in seconds.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:       between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PREGAIN .... Applied to output: may be necessary if retimed events overlap one another.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(7):
            fprintf(stdout,"INFO: MODE 8:  REPEAT SPECIFIED (SILENCE-SEPARATED) EVENT, WITHIN SOUND, AT SPECIFIED TEMPO.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
            fprintf(stdout,"INFO:       Values between 20 and 1000 are interpreted as MM\n");
            fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EVENT LOCATION .... (rough) start-time in file of event to be repeated (must be INSIDE event).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: BEATS IN EVENT .... Number of beats (at specified tempo) within the event to repeat.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EVENT REPETITIONS .... How many times (1 or more) to repeat the event.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(8):
            fprintf(stdout,"INFO: MODE 9:  MASK (REPLACE BY SILENCE) (SILENCE-SEPARATED) EVENTS, IN A SPECIFIED PATTERN OF 'DELETIONS'.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MASKING PATTERN......sequence of 0s (mask) and 1s (don't mask) describing masking pattern.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:       between peak events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(9):
            fprintf(stdout,"INFO: MODE 10: EQUALISE LEVELS, OR ACCENT, (SILENCE-SEPARATED) EVENTS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: DEGREE OF LEVEL EQUALISATION .... Range from 0 to 1.\n");
            fprintf(stdout,"INFO:       1 Boosts level of all events to that of loudest. 0 has no effect.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ACCENT_GROUPING .... If set to ZERO, existing accentuation pattern retained,\n");
            fprintf(stdout,"INFO:       and quieter events are boosted by \"equalisation\".\n");
            fprintf(stdout,"INFO:       If set to (e.g.) 3, every 3rd events is accented,\n");
            fprintf(stdout,"INFO:       (others are set at \"equalisation\" level.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PREGAIN .... Applied to output, only where accent-grouping > 0.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(10):
            fprintf(stdout,"INFO: MODE 11: REPORT DURATION OF SHORTEST (AND LONGEST) (SILENCE-SEPARATED) EVENT.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
            fprintf(stdout,"INFO:        between peak events.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(11):
            fprintf(stdout,"INFO: MODE 12: LOCATE START OF SOUND (FIRST NON-ZERO SAMPLE) IN FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OUTPUT TEXTFILE .... Data can be written to a new file, or to an existing file.\n");
            fprintf(stdout,"INFO:       The outputfile must have a '.txt' extension, or NO extension.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:       The output data consists of the sound-start-time plus the name of the soundfile.\n");
            fprintf(stdout,"INFO:       The same file can be used for successive calls to this process:\n");
            fprintf(stdout,"INFO:       new data will be appended to the end of the file.\n");
            fprintf(stdout,"INFO:       Hence this process can be applied as a BULK PROCESS on a list of input files.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(12):
            fprintf(stdout,"INFO: MODE 13: MOVE ALL DATA IN FILE SO FILE PEAK FOUND MOVES TO SPECIFIED TIME.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NEW PEAK TIME ......... Time to which to move peak in file.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(13):
            fprintf(stdout,"INFO: MODE 14: MOVE ALL DATA IN FILE SO FILE EVENT SPECIFIED MOVES TO SPECIFIED TIME.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NEW PEAK TIME ......... Time to which to move peak in file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ORIGINAL PEAK TIME .... Time of existing peak in file.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(HOVER):
        fprintf(stdout,"INFO: WANDER THROUGH FILE, ZIGZAG READING SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RATE OF HOVER (Hz) .... slow rate read lots of samples forwards, then backwards\n");
        fprintf(stdout,"INFO:                         fast rate read fewer samples forwards, then backwards\n");
        fprintf(stdout,"INFO: LOCATION OF HOVERING .. Time in input sound where samples are read.\n");
        fprintf(stdout,"INFO: RANDOMISATION OF RATE (0-1)\n");
        fprintf(stdout,"INFO: RANDOMISATION OF LOCATION (0-1)\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (mS) .... Must by less then 2 divided by max \"rate\" used\n");
        fprintf(stdout,"INFO: OUTPUT DURATION ....... Total Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MULTIMIX):
        fprintf(stdout,"INFO: GENERATE MULTI-CHANNEL MIXFILES FROM A LIST OF SOUNDFILES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  ALL FILES START AT TIME ZERO. OUTPUT CHANNEL COUNT IS MAX INPUT CHANNEL COUNT.\n");
        fprintf(stdout,"INFO: (2)  EACH FILE STARTS WHERE PREVIOUS FILE ENDS. OUT CHANNEL CNT IS MAX INPUT CHANNEL CNT.\n");
        fprintf(stdout,"INFO: (3)  EACH FILE STARTS AT A FIXED 'TIMESTEP' AFTER THE PREVIOUS ONE. OUT CHANNEL CNT IS MAX INPUT CHANNEL CNT.\n");
        fprintf(stdout,"INFO: (4)  STEREO (or mono) SOUND DISTRIBUTED TO NARROW AND WIDE STEREO PAIRS (4 of 8).\n");
        fprintf(stdout,"INFO: (5)  STEREO (or mono) SOUND DISTRIBUTED OVER AN 8-CHANNEL (PAIR-AT FRONT) SYSTEM.\n");
        fprintf(stdout,"INFO:          in modes 4 and 5, mono is treated as stereo with same signal in each channel.\n");
        fprintf(stdout,"INFO: (6)  N MONO SOUNDS SENT, IN ORDER, TO N SEPARATE OUTPUT CHANNELS.\n");
        fprintf(stdout,"INFO: (7)  MONO SOUNDS SENT, IN ORDER, TO SEPARATE OUTPUT CHANNELS.\n");
        fprintf(stdout,"INFO:              wrapping back to initial position, if more input files than output channels.\n");
        fprintf(stdout,"INFO: (8)  ALL FILES START AT TIME ZERO. OUTPUT CHANNEL COUNT SPECIFIED BY PARAMETER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIME STEP BETWEEN ENTRIES ..... (Mode 3).\n");
        fprintf(stdout,"INFO: RELATIVE LEVEL OF OUTER PAIR .. (Mode 4) Assuming inner pair is at level 1, this is outer pair level.\n");
        fprintf(stdout,"INFO:                                                           All levels are adjusted to avoid distortion.\n");
        fprintf(stdout,"INFO: FRONT PAIR LEVEL ........ (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
        fprintf(stdout,"INFO: FRONT WIDE PAIR LEVEL ... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
        fprintf(stdout,"INFO: REAR WIDE PAIR LEVEL .... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
        fprintf(stdout,"INFO: REAR PAIR LEVEL ......... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 7:\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT .....No of channels in output file.\n");
        fprintf(stdout,"INFO: START CHANNEL ........... Output channel to which first input file is sent.\n");
        fprintf(stdout,"INFO: CHANNEL SKIP ............ Step between output-channel assignment.\n");
        fprintf(stdout,"INFO:                      SKIP 1    assign to successive channels.\n");
        fprintf(stdout,"INFO:                      SKIP 2    assign to alternate channels.\n");
        fprintf(stdout,"INFO:                      SKIP -1   assign to successive channels, counting downwards.\n");
        fprintf(stdout,"INFO: TIMESTEP ................ Timestep between successive entries in mixfile.\n");
        break;
    case(FRAME):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: MODE 1: ROTATE ENTIRE SPATIAL FRAME OF A MULTICHANNEL SOUNDFILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SNAKING SEQUENCE ...... \n");
            fprintf(stdout,"INFO:       In a clockwise frame rotation, an input channel proceeds on a path around all the lspkrs,\n");
            fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 1 follows the path 1- 2->3->4->5->6->7->8->1 etc\n");
            fprintf(stdout,"INFO:       and the other input channels follow it in a \"snake\".\n");
            fprintf(stdout,"INFO:       This ROTATION-snake is the DEFAULT motion, and you should enter\n");
            fprintf(stdout,"INFO:       a ZERO for the snaking sequence, to generate a rotation.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:       However, the channels might snake around the lspkrs on a different route\n");
            fprintf(stdout,"INFO:       e.g. (for an 8-channel file) \"1 3 5 4 6 8 7 2\"\n");
            fprintf(stdout,"INFO:       and these routes could vary over time.\n");
            fprintf(stdout,"INFO:       You can specify such alternative routes in a text datafile of \"time : route\" values\n");
            fprintf(stdout,"INFO:       A line in the datafile for the above route, starting at time zero, would be\n");
            fprintf(stdout,"INFO:       \"0.0 1 3 5 4 6 8 7 2\"\n");
            fprintf(stdout,"INFO:       A changed route could be specified at a later time, on the next line\n");
            fprintf(stdout,"INFO:       e.g. \"1.3327 1 4 6 3 8 5 7 2\"\n");
            fprintf(stdout,"INFO:       In the datafile, the first time used must be zero, and times must increase.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ROTATION SPEED ........\n");
            fprintf(stdout,"INFO:       The speed of frame-rotation, in complete-rotations per second. This can vary over time.\n");
            fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SMEAR ........\n");
            fprintf(stdout,"INFO:       Extent to which signal in any OUTPUT channel bleeds onto its 2 adjacent channels.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: MODE 2: ROTATE ENTIRE SPATIAL FRAME OF SOUNDFILE, ROTATING ODD AND EVEN CHANNELS INDEPENDENTLY.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SNAKING SEQUENCE ...... \n");
            fprintf(stdout,"INFO:       In a clockwise frame rotation here,\n");
            fprintf(stdout,"INFO:       an ODD input channel proceeds on a path around all ODD outchannels,\n");
            fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 1 follows the path 1->3->5->7->1 etc\n");
            fprintf(stdout,"INFO:       and the other ODD input channels follow it in a \"snake\" around the ODD outchannels,\n");
            fprintf(stdout,"INFO:       while an EVEN input channel proceeds on a path around all EVEN outchannels,\n");
            fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 2 follows the path 2->4->6->8->2 etc\n");
            fprintf(stdout,"INFO:       and the other EVEN input channels follow it in a \"snake\" around the EVEN outchannels.\n");
            fprintf(stdout,"INFO:       This ROTATION-snake is the DEFAULT motion, and you should enter\n");
            fprintf(stdout,"INFO:       a ZERO for the snaking sequence, to generate a double rotation.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:       but you can redefine the snaking sequences with a datafile\n");
            fprintf(stdout,"INFO:       e.g.  the snake \"8 6 5 2 7 3 4 1\" produces one snake around the odd entries\n");
            fprintf(stdout,"INFO:       i.e. 8 -> 5 -> 7 -> 4 -> 8 etc\n");
            fprintf(stdout,"INFO:       and a 2nd snake around the even entries\n");
            fprintf(stdout,"INFO:       i.e. 6 -> 2 -> 3 -> 1 -> 6 etc\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: 1ST ROTATION SPEED ........\n");
            fprintf(stdout,"INFO:       The speed of frame-rotation for the ODD input channels, in complete-rotations per second. This can vary over time.\n");
            fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: 2ND ROTATION SPEED ........\n");
            fprintf(stdout,"INFO:       The speed of frame-rotation for the EVEN input channels, in complete-rotations per second. This can vary over time.\n");
            fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SMEAR ........\n");
            fprintf(stdout,"INFO:       Extent to which signal in any OUTPUT channel bleeds onto its 2 adjacent channels.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(2):
            fprintf(stdout,"INFO: MODE 3:  REORIENTATE THE CHANNELS OF THE INPUT FILE TO (FIXED) NEW POSITIONS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: REORIENTATION ..... a list of ALL the output channels, in some order.\n");
            fprintf(stdout,"INFO:        Each successive input channel will be sent to the next output channel in the list.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:        For example, the list \"2 4 6 8 1 3 5 7\"  will cause the input channels to be routed\n");
            fprintf(stdout,"INFO:        1 to 2 : 2 to 4 : 3 to 6 : 4 to 8 : 5 to 1 : 6 to 3 : 7 to 5 : 8 to 7\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(3):
            fprintf(stdout,"INFO: MODE 4:  MIRROR the FRAME OF THE INPUT FILE ABOUT A SPECIFIED AXIS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIRROR PLANE .... Channel number, or Channel-number + 0.5.\n");
            fprintf(stdout,"INFO:       The output channels are symmetrically mirrored about the channel given \n");
            fprintf(stdout,"INFO:       or around the midpoint between channels (1.5 is midpoint between 1 and 2).\n");
            fprintf(stdout,"INFO:       With an N-channel file, N.5 is midpoint between channels N and 1.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(4):
            fprintf(stdout,"INFO: MODE 5:  RENUMBER the OUTPUT CHANNELS, FROM A RING TO A BILATERAL SCHEMA (OR VICE VERSA).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TO RING FORMAT ....\n");
            fprintf(stdout,"INFO:       WITHOUT this flag, converts from ring schema to bilateral schema.\n");
            fprintf(stdout,"INFO:       WITH this flag, converts from bilateral schema to ring schema.\n");;
            fprintf(stdout,"INFO:               Ring         Bilateral                  Ring               Bilateral\n");
            fprintf(stdout,"INFO:                 1                 1                          1                      1\n");
            fprintf(stdout,"INFO:               8   2            2   3                     5   2                 2   3\n");
            fprintf(stdout,"INFO:              7     3          4     5                     4 3                   4 5\n");
            fprintf(stdout,"INFO:               6   4            6   7\n");
            fprintf(stdout,"INFO:                 5                 8\n");
            fprintf(stdout,"INFO: All multichannel processes assume RING format. If using a bilateral numbering schema\n");
            fprintf(stdout,"INFO: convert from and to Bilateral format, before and after processing data.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(5):
            fprintf(stdout,"INFO: MODE 6:  SWAP ANY 2 CHANNEL OF A MLTICHANNEL FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNEL TO SWAP .... The channel to exchange.\n");
            fprintf(stdout,"INFO: CHANNEL TO SWAP WITH .... The channel to exchange it with.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(6):
            fprintf(stdout,"INFO: MODE 7:  ADJUST LEVEL IN (OR ENVELOPE) ONLY SPECIFIED CHANNELS OF A MULTICHANNEL FILE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CHANNELS TO MODIFY ....... Either a channel number, or a text file list of channel numbers.\n");
            fprintf(stdout,"INFO:            Only these channels are modified by the process.\n");
            fprintf(stdout,"INFO: GAIN OR ENVELOPE ....... The gain, or the time-varying gain in the envelope file\n");
            fprintf(stdout,"INFO:            to apply to the specified channels.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(7):
            fprintf(stdout,"INFO: MODE 8:  RENUMBER the OUTPUT CHANNELS, FROM A RING TO BEAST BILATERAL SCHEMA (OR VICE VERSA).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TO RING FORMAT ....\n");
            fprintf(stdout,"INFO:       WITHOUT this flag, converts from ring schema to BEAST bilateral schema.\n");
            fprintf(stdout,"INFO:       WITH this flag, converts from BEAST bilateral schema to ring schema.\n");;
            fprintf(stdout,"INFO:               Ring         Bilateral                  Ring               Bilateral\n");
            fprintf(stdout,"INFO:                 1                 7                          1                      5\n");
            fprintf(stdout,"INFO:               8   2            1   2                     5   2                 1   2\n");
            fprintf(stdout,"INFO:              7     3          3     4                     4 3                   3 4\n");
            fprintf(stdout,"INFO:               6   4            5   6\n");
            fprintf(stdout,"INFO:                 5                 8\n");
            fprintf(stdout,"INFO: All multichannel processes assume RING format. If using a bilateral numbering schema\n");
            fprintf(stdout,"INFO: convert from and to Bilateral format, before and after processing data.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: \"BEAST\" = Birmingham Electro-Acoustic Sound Theatre sound-diffusion system.\n");
            break;
        }
        break;
    case(SEARCH):
        fprintf(stdout,"INFO: FIND THE FIRST REAL SIGNAL IN FILE(S) WHICH START(S) WITH SILENCE.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHANREV):
        fprintf(stdout,"INFO: CREATE MULTICHANNEL ECHO OR REVERBERATION AROUND A SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: INPUT GAIN................Attenuates signal input to stadium.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LEVEL LOSS WITH DISTANCE..across stadium.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: STADIUM SIZE MULTIPLIER...Multiplies average time between echoes.\n");
        fprintf(stdout,"INFO: ..........................(Default average echo time = 0.1 secs).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF ECHOS...........Number of stadium echoes produced.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF OUTPUT CHANNELS....Number of channels in output sound.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CENTRE OF SOUND IMAGE........Centre of sound image amongst output channels.\n");
        fprintf(stdout,"INFO:                      Values from 0, to the total number of output channels.\n");
        fprintf(stdout,"INFO:                      Values can be fractional. Values below 1, lie between Channel N and channel 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SPREAD_OF_ECHOS/REVERB.......Spread of echoes/reverb across output channels.\n");
        fprintf(stdout,"INFO:                      values from 2, to the total number of output channels.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(WRAPPAGE):
        fprintf(stdout,"INFO: GRANULAR RECONSTITUTION OF ONE OR MORE SOUNDFILES, MOVING AROUND A MULTICHANNEL SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CENTRE OF SPREAD  ............ Channel from which sound radiates.Any number between 0 & last output channel.\n");
        fprintf(stdout,"INFO:             Values less than 1, represent locations between the last outchan and the 1st.\n");
        fprintf(stdout,"INFO:             The centre can be moved by supplying a datafile of triples: \"Time   Centre   Direction\"\n");
        fprintf(stdout,"INFO:             Direction, either 1 (clockwise) or -1 (anticlockwise), is direction of motion from PREVIOUS value.\n");
        fprintf(stdout,"INFO: OUTPUT CHANNELS ............. Number of channels of MULTICHANNEL OUTPUT (>2).\n");
        fprintf(stdout,"INFO: CHANNEL SPREAD ............... Total Number of channels over which sound image extends.\n");
        fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT ..... Number of channels (on each side) activated behind spreading front.\n");
        fprintf(stdout,"INFO: TIMESHRINK...... ................Speed of advance in infiles, relative to outfile. (>=0)\n");
        fprintf(stdout,"INFO:              Inverse of timestretch, (& permits infinite timestretch).\n");
        fprintf(stdout,"INFO: DENSITY...........................Amount of grain overlap (>0 : <1 leaves intergrain silence)\n");
        fprintf(stdout,"INFO:              Extremely small values will cease to perform predictably.\n");
        fprintf(stdout,"INFO: GRAINSIZE........................grainsize in MS (must be > 2 * splicelen)\n");
        fprintf(stdout,"INFO: PITCHSHIFT.......... ............is pitchshift of grains in +|- (fractions of) semitones.\n");
        fprintf(stdout,"INFO: LOUDNESS RANGE................is range of gain on grains.\n");
        fprintf(stdout,"INFO:              Use only if amp is to vary (over range &/or through time)\n");
        fprintf(stdout,"INFO: STARTSPLICE.....................length of startsplices on grains,in MS.\n");
        fprintf(stdout,"INFO: ENDSPLICE........................length of endsplices on grains,in MS.\n");
        fprintf(stdout,"INFO: SEARCHRANGE...................for nextgrain, before current 'now' in infile (Default 0 MS).\n");
        fprintf(stdout,"INFO: SCATTER..........................Randomisation of grain position (Range 0-1).\n");
        fprintf(stdout,"INFO: OUTPUT LENGTH.................max outfile length (if end of data not reached).\n");
        fprintf(stdout,"INFO:              Set to zero (Default) for this parameter to be ignored.\n");
        fprintf(stdout,"INFO:              BUT if TIMESHRINK is ANYWHERE 0: OUTLENGTH must be given.\n");
        fprintf(stdout,"INFO: EXPONENTIAL SPLICES.........Default, Linear.\n");
        fprintf(stdout,"INFO: RELATIVE TO OUTPUT TIME..Timeshrink parameters are ALWAYS read relative to time in INPUT file.\n");
        fprintf(stdout,"INFO:              All other parameters are normally also read relative to time in input file.\n");
        fprintf(stdout,"INFO:              Set this flag to force those parameters to be read relative to time in OUTPUT file.\n");
        fprintf(stdout,"INFO: TIMESHRINK LIMIT,DENSITY LIMIT ETC.......allow range of values to be specified\n");
        fprintf(stdout,"INFO:              for any of these params. e.g. With Density & Density Limit set\n");
        fprintf(stdout,"INFO:              a random density is generated between these values,\n");
        fprintf(stdout,"INFO:              while Density & Density Limit can THEMSELVES vary through time.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHSTEREO):
        fprintf(stdout,"INFO: INSERT STEREO FILES INTO A MULTICHANNEL OUTPUT SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: This process allows, for example, stereo outputs from processing the individual channels\n");
        fprintf(stdout,"INFO: of a multichannel file (e.g. reverberation) to be remixed into the multichannel context,\n");
        fprintf(stdout,"INFO: at the sample location as their original mono sources.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PREGAIN.......gain applied to stereo inputs before they are mixed to the output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUT CHANNEL ON WHICH STEREO INPUT CENTRED.......either a channel number,\n");
        fprintf(stdout,"INFO:              or a textfile of channel numbers, one for each stereo inputfile.\n");
        fprintf(stdout,"INFO:              Each stereo input image will be centred (in turn) at the output positions given,\n");
        fprintf(stdout,"INFO:              BUT ...\n");
        fprintf(stdout,"INFO: CENTRE BETWEEN OUTCHANS .... if this flag is set, the output stereo-images are centred\n");
        fprintf(stdout,"INFO:              to the right of the specified output centre, between the 2 output channels.\n");
        fprintf(stdout,"INFO:              e.g. Stereo signal sent to output 2, will be centred between output channels 2 & 3.\n");
        break;
    case(MTON):
        fprintf(stdout,"INFO: CONVERT MONO SOURCE TO MULTICHANNEL SOUND, WITH IDENTICAL DATA IN EVERY CHANNEL.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT.......Number of (identical) channels in the output file.\n");
        break;
    case(FLUTTER):
        fprintf(stdout,"INFO: IMPOSE MULTICHANNEL-DISPERSED LOUDNESS FLUTTERING ON A MULTICHANNEL FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CHANNEL SET SEQUENCE ..... The change in loudness occurs first in one set of output channels,\n");
        fprintf(stdout,"INFO:               then in another, as the fluttering proceeds.\n");
        fprintf(stdout,"INFO:               Each line contains a list of 1 or more of the output channels\n");
        fprintf(stdout,"INFO:               forming a 'channel set' which will flutter.\n");
        fprintf(stdout,"INFO:               The flutter passes from the channels in one set, to the channels in the next,\n");
        fprintf(stdout,"INFO:               on every pulse of the fluttering. When all the defined channels sets are used up,\n");
        fprintf(stdout,"INFO:               The sequence begins again at the start (BUT see the 'randomisation' flag, below),\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FLUTTER FREQUENCY (Hz) ...Frequency of loudness fluctuations. May vary over time.\n");
        fprintf(stdout,"INFO: FLUTTER DEPTH ................... Depth of loudness fluctuations. May vary over time.\n");
        fprintf(stdout,"INFO:               Depth between 0 and 1 determines the trough level of the flutter cycle.\n");
        fprintf(stdout,"INFO:               Depth above 1, makes flutter peaks narrower (troughing still at zero).\n");
        fprintf(stdout,"INFO: GAIN ...................................... Overall gain on the output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOMISE CHANNEL-SETS ORDER .... With this flag set, once all channel-sets have been used\n");
        fprintf(stdout,"INFO:               they are randomly permuted into a different order before the next flutter,\n");
        fprintf(stdout,"INFO:               and when all sets, in this new order, have been used, they are permuted again\n");
        fprintf(stdout,"INFO:               and so on. (The sets themselves are not changed by this process).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ABFPAN):
        fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 1st ORDER B_FORMAT PAN TO A MONO INPUT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
        fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
        fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF B FORMAT OUTPUT CHANNELS .... Either 3 or (default) 4.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT AS STANDARD WAV: AMBISONIC.\n");
        fprintf(stdout,"INFO: OUTPUT AS STANDARD WAV  ........ (NB You cannot set both of these flags)\n");
        fprintf(stdout,"INFO:               The default output is a WAVEX B-FORMAT Ambisonic File.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ABFPAN2):
        fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 2nd ORDER B_FORMAT PAN TO A MONO INPUT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
        fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
        fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PREGAIN .... ... Change the input file amplitude.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: STANDARD WAV (AMBISONIC) OUTPUT ...... default is WAVEX B-FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ABFPAN2P):
        fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 2nd ORDER B_FORMAT PAN TO A MONO INPUT, IN 3-DIMENSIONS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
        fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
        fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PREGAIN .... ... Change the input file amplitude.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: HEIGHT.......... 90 is directly above, -90 directly below.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: STANDARD WAV (AMBISONIC) OUTPUT ...... default is WAVEX B-FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CHANNELX):
        fprintf(stdout,"INFO: EXTRACT CHANNELS FROM A MULTICHANNEL FILE OF ANY FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: INPUT CHANNELS TO EXTRACT.......... Textfile with a list of input channels to extract.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CHORDER):
        fprintf(stdout,"INFO: REORDER CHANNELS INSIDE A MULTICHANNEL FILE OF ANY FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: REORDERING STRING.......... String consisting of (lower-case) letters, with or without zeros.\n");
        fprintf(stdout,"INFO:               The string cannot contain more than 26 items.\n");
        fprintf(stdout,"INFO:               For example, for a 4-channel input file, the channels are represented by \"a\",\"b\",\"c\" and \"d\".\n");
        fprintf(stdout,"INFO:               \"0\" represents a (possible) silent output channel.\n");
        fprintf(stdout,"INFO:               Ordering strings for this 4-channel file could be.....\n");
        fprintf(stdout,"INFO:               \"abcd\" same order as the input (input file not altered).\n");
        fprintf(stdout,"INFO:               \"dcba\" reversed channel-order of the input.\n");
        fprintf(stdout,"INFO:               \"a00b\" input channel 1 to out-channel 1, input channel 2 to out-channel 4, with 2 silent channels.\n");
        fprintf(stdout,"INFO:               \"aababc00ddd\" etc (note that channels can be duplicated in the output).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:               For an 8-channel input file, channels are represented by \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\" and \"h\".\n");
        fprintf(stdout,"INFO:               and so on.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FORCE A .amb FILENAME EXTENSION (CARE!!)\n");
        fprintf(stdout,"INFO:               specifying a \".amb\" file extension does NOT automatically produce an ambisonic output file.\n");
        fprintf(stdout,"INFO:               This can only be guaranteed by the internal structure of the data.\n");
        fprintf(stdout,"INFO:               Forcing a \".amb\" extension onto non-ambisonic data may cause confusion at a later data!\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: This program permits low level manipulation of the data format of files.\n");
        fprintf(stdout,"INFO: With ambisonic or other non-trivial data structures, it should be used WITH CAUTION!!\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \n");
        break;
    case(FMDCODE):
        fprintf(stdout,"INFO: PLAIN MULTI-LAYOUT DECODER FOR AMBISONIC FILES.\n");
        fprintf(stdout,"INFO: (No shelf filter or NF compensation used).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT LAYOUT.......... This can take one of the following values.\n");
        fprintf(stdout,"INFO:               1  : *   Mono (= W signal only).\n");
        fprintf(stdout,"INFO:               2  : *   Stereo (quasi mid/side, = W +- Y) \n");
        fprintf(stdout,"INFO:               3  :     Square (FL  FR  RR  RL  order)\n");
        fprintf(stdout,"INFO:               4  : *   Quad   (FL  FR  RL  RR  order)\n");
        fprintf(stdout,"INFO:               5  :     Pentagon  \n");
        fprintf(stdout,"INFO:               6  : *   5.0  (WAVEX order)\n");
        fprintf(stdout,"INFO:               7  : *   5.1  (WAVEX order : silent LFE)\n");
        fprintf(stdout,"INFO:               8  :     hexagon  \n");
        fprintf(stdout,"INFO:               9  :     octagon 1 (pair at front)\n");
        fprintf(stdout,"INFO:               10 :    octagon 2  (single lspkr at front centre)\n");
        fprintf(stdout,"INFO:               11 :    cube  (as 3 : low/high interleaved)\n");
        fprintf(stdout,"INFO:               12 : *  cube  (as 4 : low quad followed by high quad)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WRITE WAVEX LSPKR POSITIONS TO HEADER ....... NB only applies to \"*\" layouts above.\n");
        fprintf(stdout,"INFO: PLAIN WAV OUTFILE FORMAT ...... Default is generic wavex format.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CHXFORMAT):
        fprintf(stdout,"INFO: SET OR CHANGE THE LOUDSPEAKER POSITION MASK IN A WAVEX FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \nLSPKR_POSITION_MASK ....... Indicates the loudspeaker positions for sound output.");
        fprintf(stdout,"INFO:               0 : Unsets the loudspeaker mask.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CHXFORMATG):
        fprintf(stdout,"INFO: CHANGE GUID TYPE FROM WAVEX TO AMBISONIC, UNSETTING THE LSPKR POSITION MASK.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CHXFORMATM):
        fprintf(stdout,"INFO: SET THE POSSIBLE LOUDSPEAKER POSITION MASK VALUES FOR A WAVEX FILE.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(INTERLX):
        fprintf(stdout,"INFO: INTERELAVE LIST OF MONO OR STEREO SOUNDS (IN A TEXTFILE) TO A MULTICHANNEL OUTPUT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL FORMAT  ....... Indicates the output soundfile format.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:               0 : Standard (wav, aiff etc.) format.\n");
        fprintf(stdout,"INFO:               1 : generic WAV_EX (no loudspeaker assignments).\n");
        fprintf(stdout,"INFO:               2 : WAV_EX mono/stereo/quad (FL  FR  RL  RR). 1,2 or 4 input channels needed.\n");
        fprintf(stdout,"INFO:               3 : WAV_EX quad surround (L, C, R, S). Four input channels needed.\n");
        fprintf(stdout,"INFO:               4 : WAV_EX 5.1 format surround. Six input channels needed.\n");
        fprintf(stdout,"INFO:               5 : WAV_EX Ambisonic B-Format (W,X,Y,Z....). 3,4,5,6,7,8,9,11 or 16 input chans needed.\n");
        fprintf(stdout,"INFO:               6 : WAV_EX 5.0 surround. Five input channels needed.\n");
        fprintf(stdout,"INFO:               7 : WAV_EX 7.1 surround. Eight input channels needed.\n");
        fprintf(stdout,"INFO:               8 : WAV_EX Cube surround. Eight input channels needed.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Input files must match in sample rate, and number of channels, but can have different sample types.\n");
        fprintf(stdout,"INFO: If Input files are WAVEX, any loudspeaker position information is ignored.\n");
        fprintf(stdout,"INFO: The same input file can be listed several times, if required to send to several output channels.\n");
        break;
    case(COPYSFX):
        fprintf(stdout,"INFO: COPY SOUNDFILE, CHANGING THE FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SAMPLE TYPE  ....... Indicates the output sample type.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:               0 : Retain sample type of input file.\n");
        fprintf(stdout,"INFO:               1 : 16 bit integer (short).\n");
        fprintf(stdout,"INFO:               2 : 32 bit integer (long).\n");
        fprintf(stdout,"INFO:               3 : 32 bit floating-point.\n");
        fprintf(stdout,"INFO:               4 : 24 bit integer (packed).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTFILE FORMAT  ....... Indicates the output soundfile format.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:               -1 : Retain format of input file.\n");
        fprintf(stdout,"INFO:               0 : Standard wav format.\n");
        fprintf(stdout,"INFO:               1 : generic WAV_EX (no loudspeaker assignments).\n");
        fprintf(stdout,"INFO:               2 : WAV_EX mono/stereo/quad (FL  FR  RL  RR). 1,2 or 4 input channels needed.\n");
        fprintf(stdout,"INFO:               3 : WAV_EX quad surround (L, C, R, S). Four input channels needed.\n");
        fprintf(stdout,"INFO:               4 : WAV_EX 5.1 format surround. Six input channels needed.\n");
        fprintf(stdout,"INFO:               5 : WAV_EX Ambisonic B-Format (W,X,Y,Z....). 3,4,5,6,7,8,9,11 or 16 input chans needed.\n");
        fprintf(stdout,"INFO:               6 : WAV_EX 5.0 surround. Five input channels needed.\n");
        fprintf(stdout,"INFO:               7 : WAV_EX 7.1 surround. Eight input channels needed.\n");
        fprintf(stdout,"INFO:               8 : WAV_EX Cube surround. Eight input channels needed.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ADD TDPF DITHER TO 16 BIT OUTFILE .... improving quality of low level signals.\n");
        fprintf(stdout,"INFO: WRITE MINIMAL HEADER (NO PEAKDATA) ... header gets no information about peaks in the output file.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(NJOINCH):
        fprintf(stdout,"INFO: CHECK COMPATIBLITY OF FILES FOR CONCATENATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CD COMPATIBLE FILES ONLY .... All files must have sample-rate 44100\n");
        fprintf(stdout,"INFO:               and must be at least 4 seconds in duration. \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: All files must match in sample-rate and number of channels,\n");
        fprintf(stdout,"INFO: but may have different sample types (e.g. 16-bit, 32-bit etc.)\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(NJOIN):
        fprintf(stdout,"INFO: CONCATENATE FILES e.g. FOR C.D. COMPILATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SILENCE BETWEEN FILES ...... silence separating the files in concatenated output.\n");
        fprintf(stdout,"INFO:               To eliminate silence BEFORE 1st file in output, enter a NEGATIVE value.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CD COMPATIBLE FILES ONLY .... All files must have sample-rate 44100\n");
        fprintf(stdout,"INFO:               and must be at least 4 seconds in duration. \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT A TEXTFILE OF CUES .... Output extra file, with cue points in compilation. \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: All files must match in sample-rate and number of channels,\n");
        fprintf(stdout,"INFO: but may have different sample types (e.g. 16-bit, 32-bit etc.)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The output sample format is taken from the file with the highest precision.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(NMIX):
        fprintf(stdout,"INFO: MIX TWO FILES OF THE SAME FORMAT.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Any format is accepted, so long as both files have the same format.\n");
        fprintf(stdout,"INFO: Formats may be wav, aiff, WAVEX, Ambisonic, etc.\n");
        fprintf(stdout,"INFO: (WAVEX files must have the same loudspeaker layout).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Files may have different sample types (16bit, 32bit etc.)\n");
        fprintf(stdout,"INFO: and (unless \"Float Output\" flag is set) output takes the sample-type of the FIRST file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: START TIME OF 2nd FILE .... First file starts at zero; 2nd file starts at time specified here.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: APPLY DITHER TO 16bit OUTPUT .... Enhance quality of low level signal (only with 16bit output).\n");
        fprintf(stdout,"INFO: FLOAT OUTPUT ......................... Force 32bit floating point output type.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(RMSINFO):
        fprintf(stdout,"INFO: REPORT RMS AND AVERAGE POWER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Scans the file (between the times specified) and reports the loudness in various forms.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Output is a table of values showing, for each channel,\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1) the RMS loudness, as amplitude(0-1) and in dB\n");
        fprintf(stdout,"INFO: 2) the average loudness (power) as amplitude(0-1) and in dB\n");
        fprintf(stdout,"INFO: 3) the NET DC loudness as amplitude(0-1) and in dB\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SFEXPROPS):
        fprintf(stdout,"INFO: DISPLAY PROPERTIES OF WAVEX FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: These include\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The File Format.\n");
        fprintf(stdout,"INFO: The loudspeaker configuration.\n");
        fprintf(stdout,"INFO: The loudspeaker positions (if specified).\n");
        fprintf(stdout,"INFO: Creation date of the file.\n");
        fprintf(stdout,"INFO: Sample Rate.\n");
        fprintf(stdout,"INFO: Channel Count.\n");
        fprintf(stdout,"INFO: Sample Type (16-bit,32-bit etc.)\n");
        fprintf(stdout,"INFO: Duration.\n");
        fprintf(stdout,"INFO: Peak data information for each channel.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SETHARES):
        fprintf(stdout,"INFO: EXTRACT PEAKS FROM ANALYSIS DATA.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  LIST (TIME-VARYING) PEAKS\n");
        fprintf(stdout,"INFO:              List peaks in each window - windows may have different numbers of peaks.\n");
        fprintf(stdout,"INFO: (2)  STREAM MAXIMUM NUMBER OF PEAKS.\n");
        fprintf(stdout,"INFO:              Number of streams = maximum number of peaks in any one window in the file.\n");
        fprintf(stdout,"INFO:              Where a window has insufficient peaks to fill all the streams\n");
        fprintf(stdout,"INFO:              a zero-amplitude peak, at an estimated frequency , is set in the stream for that window.\n");
        fprintf(stdout,"INFO:              In this process, all peaks are retained.\n");
        fprintf(stdout,"INFO: (3)  STREAM MOST PROMINENT PEAKS.\n");
        fprintf(stdout,"INFO:              This process assumes that the spectrum is relatively stable.\n");
        fprintf(stdout,"INFO:              The peaks at every semitone interval in every window are counted.\n");
        fprintf(stdout,"INFO:              This determines the weighting of each pitch among the peaks in the entire file.\n");
        fprintf(stdout,"INFO:              The most prominent pitches are chosen as the stream-centres.\n");
        fprintf(stdout,"INFO:              Time-varying pitch/amp data is then assigned to these streams.\n");
        fprintf(stdout,"INFO:              In this process, some peaks may be discarded.\n");
        fprintf(stdout,"INFO: (4)  OUTPUT AVERAGE PITCHES.\n");
        fprintf(stdout,"INFO:              This process assumes that the spectrum is relatively stable.\n");
        fprintf(stdout,"INFO:              Streams are calculated as in Mode 3, and an average value calculated for each stream.\n");
        fprintf(stdout,"INFO:              The output data does not vary in time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SEARCH WINDOW SIZE (SEMITONES) .... semitone width of subwindow used to search for local peaks in spectrum.\n");
        fprintf(stdout,"INFO: PEAKING RATIO .............................. a peak is defined as a channel whose amplitude\n");
        fprintf(stdout,"INFO:              exceeds the median amplitude of all the channels in the subwindow, by this factor.\n");
        fprintf(stdout,"INFO: AMPLITUDE FLOOR .......................... peak must also exceed a floor value to be retained.\n");
        fprintf(stdout,"INFO:             Entered value is first multiplied by the maximum channel amplitude found in the file.\n");
        fprintf(stdout,"INFO: LOW PITCH LIMIT ............................ Minimum frequency to accept as a peak.\n");
        fprintf(stdout,"INFO: HIGH PITCH LIMIT ............................ Maximum frequency to accept as a peak.\n");
        fprintf(stdout,"INFO: IN-TUNE RANGE (SEMITONES) ............. range within which harmonics accepted as in tune.\n");
        fprintf(stdout,"INFO:             If NON-ZERO, peaks which are harmonics of other peaks are not retained.\n");
        fprintf(stdout,"INFO:             If set to zero, ALL peaks are retained.\n");
        fprintf(stdout,"INFO: NO AMPLITUDES ............................. Discard the amplitude information.\n");
        fprintf(stdout,"INFO:             NB: If the output is in \"FILTER FORMAT\", all amplitudes are set to 1.0.\n");
        fprintf(stdout,"INFO: MIDI OUTPUT ................................. Frequency data output as MIDI values.\n");
        fprintf(stdout,"INFO: QUANTISE TO QUARTERTONES ........... Quantise frqs to tempered-scale quartertone.\n");
        fprintf(stdout,"INFO: MARK ZEROS ................................. Mark windows which have NO peaks.\n");
        fprintf(stdout,"INFO:             If set, peak-free areas are marked by (timed) zeros in the output data.\n");
        fprintf(stdout,"INFO: FILTER FORMAT ............................. Output data in filter varibank format.\n");
        fprintf(stdout,"INFO:             This overrides the \"MARK ZEROS\" flag.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHSHRED):
        fprintf(stdout,"INFO: MULTICHANNEL SOUND SHREDDING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  SHRED MONO FILE TO N OUTPUT CHANNELS\n");
        fprintf(stdout,"INFO: (2)  SHRED MULTICHANNEL FILE\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Cut file into segments, rearrange the segments: Repeat the process on the output.\n");
        fprintf(stdout,"INFO: The output chunks are also sent to a randomly permuted sequence of output channels.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF SHREDS. ...number of repeats of shredding process.\n");
        fprintf(stdout,"INFO: AVERAGE CHUNKLENGTH..average length of chunks to cut & permute.\n");
        fprintf(stdout,"INFO: CUT SCATTER..........randomisation of cuts (0 to K): default 1.\n");
        fprintf(stdout,"INFO: .....................where K = total number of chunks (snd-duration/chunklen).\n");
        fprintf(stdout,"INFO: .....................If scatter = 0: sound is reordered without shredding.\n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL CNT...For Mode 1 only.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHZIG):
        fprintf(stdout,"INFO: READ BACK AND FORTH INSIDE SOUNDFILE, WITH RANDOM PANS\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  RANDOM ZIGZAGS\n");
        fprintf(stdout,"INFO: (2)  ZIGZAG BETWEEN USER SPECIFIED TIMES\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In mode USER SPECIFIED\n");
        fprintf(stdout,"INFO: Required data is textfile containing sequence of times to zigzag (and pan) between.\n");
        fprintf(stdout,"INFO: Each step-between-times must be > (3 * splicelen).\n");
        fprintf(stdout,"INFO: Successive zigsteps moving in same (time-)direction are concatenated.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ZIGZAGGING START TIME..... Start time of the area of the infile where zigzagging will happen.\n");
        fprintf(stdout,"INFO: ZIGZAGGING END TIME ........ End time of the area of the infile where zigzagging will happen.\n");
        fprintf(stdout,"INFO: MIN DURATION OUTFILE ...... output will be at least this long.\n");
        fprintf(stdout,"INFO: MIN ZIG LENGTH ............... in \"Random\" mode, minimum duration of any zig or zag.\n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL CNT\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (MS)\n");
        fprintf(stdout,"INFO: MAX ZIG LENGTH ............... in \"Random\" mode, maximum duration of any zig or zag.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOM SEED..a number to generate a replicable random sequence. (>0)\n");
        fprintf(stdout,"INFO: .............enter same number on next program run, to get same outfile.\n");
        fprintf(stdout,"INFO: .............(Default: (0) random sequence is different every time).\n");
        fprintf(stdout,"INFO: NO PANS BETWEEN ADJACENT CHANNELS.......Reject zigs between adjacent output channels.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MCHITER):
        fprintf(stdout,"INFO: ITERATE INPUT SOUND IN FLUID MANNER, DISTRIBUTING TO MANY CHANNELS\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ****  WARNING: Do NOT use with large files. ****\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DELAY..................(average) delay between iterations. Default:infile dur.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOMISATION OF DELAY.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PITCH SCATTER..........max of random pitchshift of each iteration: semitones\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PROGRESSIVE FADE.......(average) amplitude reduction between iterations.\n");
        fprintf(stdout,"INFO:                        A small value is a small amplitude reduction.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OVERALL GAIN...........(special) value 0, gives best guess for no distortion.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECSPHINX):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: IMPOSE CHANNEL AMPLITUDES OF FILE2 ON CHANNEL FRQS OF FILE 1\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: AMPLITUDE BALANCE..... Proportion of File1 Channel-amplitudes retained.\n");
            fprintf(stdout,"INFO: FREQUENCY BALANCE..... Proportion of File2 Channel-frequencies retained in output spectrum.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: MULTIPLY CHANNEL AMPLITUDES OF TWO SPECTRA\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Note that the spectral FREQUENCIES of the FIRST input are always retained.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: BIAS ....... If NON-zero, a proportion of the (channel-by-channel) amplitude of original signal is added to the output.\n");
            fprintf(stdout,"INFO:                        If less than 1, a proportion of the 1st input signal is added to the multiplied output.\n");
            fprintf(stdout,"INFO:                        If greater than 1, a proportion of the 2nd input signal is added to the multiplied output.\n");
            fprintf(stdout,"INFO:                        Ratio of original to multiplied signal, in the output = abs(bias)/(1.0 - abs(bias))\n");
            fprintf(stdout,"INFO:                        where \"abs(bias)\" is the absolute (unsigned) value of \"bias\"\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GAIN ....... Overall gain on output.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(2):
            fprintf(stdout,"INFO: CARVE SPECTRUM OF FILE 1 WITH FORMANT ENVELOPE OF FILE 2\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: If file 2 is continuous, it's continuity is largely retained.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CARVE DEPTH ............ How deeply does the spectral envelope of File 2 bite into the spectrum of File 1. (Range 0 to 1). Time-variable.\n");
            fprintf(stdout,"INFO: OUTPUT GAIN ............ Overall gain on output.\n");
            fprintf(stdout,"INFO: CUTOFF FREQUENCY ... Where in the spectrum does the carving stop (Range 0 - nyquist). Zero value leaves the 1st sound unchanged.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: USE LOUDNESS ENVELOPE OF 2nd SPECTRUM ... The loudness contour of the 1st sound affects that of the output.\n");
            fprintf(stdout,"INFO:                                                                                 Default, the loudness contour of the 1st sound is largely unaffected.\n");
            break;
        }
        break;
    case(SUPERACCU):
        fprintf(stdout,"INFO: SUSTAIN EACH SPECTRAL BAND, UNTIL LOUDER DATA APPEARS IN THAT BAND\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: This process is similar to \"FOCUS ACCUMULATE\"\n");
        fprintf(stdout,"INFO: but at the file end, any decaying channels are retained until they decay to zero.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  SUSTAIN (AND POSSIBLY GLISS) LOUDEST PARTIALS.\n");
        fprintf(stdout,"INFO: (2)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO TEMPERED SCALE.\n");
        fprintf(stdout,"INFO: (3)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO NEAREST OF SPECIFIED FREQUENCIES.\n");
        fprintf(stdout,"INFO:             (HARMONIC SET GIVEN IN INPUT DATA FILE).\n");
        fprintf(stdout,"INFO: (4)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO NEAREST OF SPECIFIED FREQUENCIES OR THEIR 8vas\n");
        fprintf(stdout,"INFO:             (HARMONIC FIELD GIVEN IN INPUT DATA FILE).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECAY RATE....sutained channel data decays by DECAYRATE per sec.\n");
        fprintf(stdout,"INFO: GLISS RATE....sutained channel data glisses at GLISRATE 8vas per sec.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TUNING....forces the (start) frq of sustained partials to one of the specified frequencies.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: REASSIGN CHANNELS .... glissing data is moved into more appropriate channel\n");
        fprintf(stdout,"INFO:                        if it strays beond the channel frq limits.\n");
        fprintf(stdout,"INFO:                        (can cause sustained glissandi to persist for longer.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PARTITION):
        fprintf(stdout,"INFO: PARTITION MONO SOUND FILE INTO DISJUNCT BLOCKS, ASSIGNING EVERY Nth BLOCK TO ONE OF N OUTPUT FILES\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: For input file \"abcdefghijklmno....\" and 3 output files\n");
        fprintf(stdout,"INFO: (where \"a\",\"b\" etc are successive blocks), we produce\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Outfile1 \"a--d--g--j--m--...\n");
        fprintf(stdout,"INFO: Outfile2 \"-b--e--h--k--n-...\n");
        fprintf(stdout,"INFO: Outfile3 \"--c--f--i--l--o...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: where \"--\" is silence replacing the missing blocks\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  BLOCKS DEFINED BY THE COUNT OF THE WAVESETS THEY CONTAIN.\n");
        fprintf(stdout,"INFO: (2)  BLOCKS DEFINED BY THEIR DURATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: GRID COUNT ..... is the number of output files to generate.\n");
        fprintf(stdout,"INFO: WAVESET COUNT PER GRID BLOCK (Mode 1) ..... is the number of wavesets in each Block in the output files.\n");
        fprintf(stdout,"INFO: DURATION OF GRID BLOCKS (Mode 2) ..... is the duration (in seconds) of each Block.\n");
        fprintf(stdout,"INFO: RANDOMISATION OF DURATION (Mode 2) ..... is the randomisation of that duration (Range 0 -1).\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (Mode 2) ..... is the duration of the splices used to cut the blocks, in milliseconds.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECGRIDS):
        fprintf(stdout,"INFO: PARTITION SPECTRUM INTO PARTS, OVER A GRID\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTFILECNT    Number of output spectral files.\n");
        fprintf(stdout,"INFO: CHANGROUPING  Number of adjacent channels per group in the output spectra.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The product of the 2 parameters must be a divisor of the channel count.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If the input file has 16 channels \"abcdefghijklmnop\"\n");
        fprintf(stdout,"INFO: With 2 outfiles and changrouping 1\n");
        fprintf(stdout,"INFO: The outfiles contain \"a-c-e-g-i-k-m-o\" and \"b-d-f-h-j-l-n-p\" respectively.\n");
        fprintf(stdout,"INFO: With 2 outfiles and changrouping 2\n");
        fprintf(stdout,"INFO: The outfiles contain \"ab-ef-ij-mn\" and \"cd-gh-kl-op\".\n");
        fprintf(stdout,"INFO: With 2 outfiles and changrouping 4\n");
        fprintf(stdout,"INFO: The outfiles contain \"abcd-ijkl\" and \"efgh-mnop\".\n");
        fprintf(stdout,"INFO: With 2 outfiles and changrouping 8\n");
        fprintf(stdout,"INFO: The outfiles contain \"abcdefgh\" and \"mnopijkl\".\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: With 4 outfiles and changrouping 1\n");
        fprintf(stdout,"INFO: The outfiles contain \"a-e-i-m\" \"b-f-j-n\" \"c-g-k-o\" and \"d-h-l-p\".\n");
        fprintf(stdout,"INFO: With 4 outfiles and changrouping 2\n");
        fprintf(stdout,"INFO: With changrouping 2 and 4 outfiles\n");
        fprintf(stdout,"INFO: The outfiles contain \"ab-ij\" \"cd-kl\" \"ef-mn\" and \"gh-op\".\n");
        fprintf(stdout,"INFO: With 4 outfiles and changrouping 4\n");
        fprintf(stdout,"INFO: The outfiles contain \"abcd\" \"efgh\" \"ijkl\" and \"mnop\".\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(GLISTEN):
        fprintf(stdout,"INFO: RANDOM PARTITION THE SPECTRUM INTO BINS AND PLAY THESE BACK IN ORDER\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: All the channels of the spectrum are partitioned into N mutually exclusive sets\n");
        fprintf(stdout,"INFO: with channels assigned at random to each set. These sets form 1 complete group.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Then channels in the first set are played, for a given number of windows,\n");
        fprintf(stdout,"INFO: at which point channels in the 2nd set are played, and so on.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (As this happens, we are progressing through the original spectrum at the original rate.\n");
        fprintf(stdout,"INFO: The process determines merely which channels are used - the others being zeroed).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Once all N sets are exhausted, a new group is made by random partition, and so on.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: GROUP DIVISIONS ..... Number of sets to divide analysis-channels into\n");
        fprintf(stdout,"INFO:                     (e.g. with value 4, process partitions channels randomly\n");
        fprintf(stdout,"INFO:                     among 4 sets with [totalchans/4] channels per set).\n");
        fprintf(stdout,"INFO:                     NB Must be an exact divisior of the channel count.\n");
        fprintf(stdout,"INFO: WINDOW LENGTH .......  Number of windows for which each channel-set persists\n");
        fprintf(stdout,"INFO:                     before we switch to next set-of-channels (Range 1-1024)\n");
        fprintf(stdout,"INFO: PITCHSHIFT ............. Maximum +- range of random pitch shifting of each set\n");
        fprintf(stdout,"INFO:                     (Range 0 to 12.0  semitones)\n");
        fprintf(stdout,"INFO: WINDOWLENGTH RANDOMISE ... Randomisation of Window length to use (between 1 and value set)\n");
        fprintf(stdout,"INFO: GROUPDIVIDE RANDOMISE ..... Randomise number of channels in each set in a group\n");
        fprintf(stdout,"INFO:                     Without randomisation, each set-in-a-group has an equal number of channels.\n");
        fprintf(stdout,"INFO:                     With randomisation, a group has sets of different sizes.\n");
        break;
    case(TUNEVARY):
        fprintf(stdout,"INFO: REPLACE SPECTRAL FRQS BY HARMONICS OF SPECIFIED PITCH(ES), POSSIBLY IN MOTION\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Data required a time-changing template of MIDI pitch-values\n");
        fprintf(stdout,"INFO: Each line must start with a time, in seconds,\n");
        fprintf(stdout,"INFO: and be followed by (possibly fractional) MIDI values (range 0 - 127).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Times must start at zero and increase from line to line.\n");
        fprintf(stdout,"INFO: Lines must have equal numbers of entries,\n");
        fprintf(stdout,"INFO: but duplicated MIDI values can be used on any line.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOCUS..........degree of focusing of partial pitches onto template.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CLARITY........degree to which non-template partials are suppressed.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TRACE..........number of (window_by_window) most prominent channels\n");
        fprintf(stdout,"INFO: ...............to be replaced by template frqs. (default, all channels)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LOW FRQ LIMIT..frqs below this are ignored.\n");
        fprintf(stdout,"INFO: \n");
    case(ISOLATE):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: ISOLATE, IN PLACE, SINGLE SPECIFIED SEGMENT(S) OF A SOURCE, TO DISTINCT OUTFILES\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Specified segments are cut from the input file to distinct output files\n");
            fprintf(stdout,"INFO: but the segments retain silent preambles\n");
            fprintf(stdout,"INFO: so they occur at SAME TIME in the outfiles, as in the input file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Process concludes by generating a file of all material left over after segment removal.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CUT SEGMENT TIMES .....The datafile is a list of time-pairs,\n");
            fprintf(stdout,"INFO:           being the start and end times of segments to be cut.\n");
            fprintf(stdout,"INFO:           These should be in time order, and must not overlap one another.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           If 2 cuts abutt each other, or are so close that the end and start splices overlap,\n");
            fprintf(stdout,"INFO:           the end of the first cut will be moved back, and the start of 2nd cut moved forward\n");
            fprintf(stdout,"INFO:           so that they overlap by a single splicelength.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-segments to be marked\n");
            fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
            fprintf(stdout,"INFO:           Input segments are sorted into order and checked for overlap.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
            fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
            fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
            fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
            fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
            fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
            fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: ISOLATE, IN PLACE, SETS OF SPECIFIED SEGMENT(S) OF A SOURCE, TO DISTINCT OUTFILES\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Specified sets of isolated segments are cut from the input file.\n");
            fprintf(stdout,"INFO: Each output file has a different set of isolated segments of the source.\n");
            fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
            fprintf(stdout,"INFO: as in the source file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CUT SEGMENT TIMES ...... Each line of the datafile has a list of time-pairs,\n");
            fprintf(stdout,"INFO:           the start & end times of segments to be cut for that particular output file.\n");
            fprintf(stdout,"INFO:           These should be in time order, in each line.\n");
            fprintf(stdout,"INFO:           None of segments (in any of the lines) must overlap one another.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           If 2 cuts abutt each other, or are so close that the end and start splices overlap,\n");
            fprintf(stdout,"INFO:           the end of the first cut will be moved back, and the start of 2nd cut moved forward\n");
            fprintf(stdout,"INFO:           so that they overlap by a single splicelength.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-segments to be marked\n");
            fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
            fprintf(stdout,"INFO:           Marked segments which succeed each other in time are placed on the same line.\n");
            fprintf(stdout,"INFO:           (assumed to be part of the data for the same output file).\n");
            fprintf(stdout,"INFO:           If a new marked segment preceeds (in time) a previous marked segment,\n");
            fprintf(stdout,"INFO:           a new data line is initiated for a 2nd output file, and so on.\n");
            fprintf(stdout,"INFO:           Input segments are also checked for overlap.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
            fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
            fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
            fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
            fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
            fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
            fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: \n");
            break;
        case(2):
            fprintf(stdout,"INFO: ISOLATE, IN PLACE, SEVERAL SEGMENT(S) OF A SOURCE, TO A SINGLE OUTFILE\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Specified segments are cut from the input file and placed in the same output file.\n");
            fprintf(stdout,"INFO: but the segments retain silent surrounds\n");
            fprintf(stdout,"INFO: so they occur at SAME TIME in the outfiles, as in the input file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Segment starts and ends are located using threshold-on and threshold-off parameters.\n");
            fprintf(stdout,"INFO: If a segment-length is set, only the initial part (length specified) of each segment is retained.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Process concludes by generating a file of all material left over after segment removal.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The original file is reconstructible by mixing both these components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: THRESHOLD ON .......... dB level at which a segment is triggered to  be cut.\n");
            fprintf(stdout,"INFO: THRESHOLD OFF ......... dB level at which a cut segment is triggered to end.\n");
            fprintf(stdout,"INFO: MINIMUM SEGMENT LENGTH.. Minimum Duration in mS which segment must have, to be accepted.\n");
            fprintf(stdout,"INFO: SEGMENT RETAIN LENGTH .. Duration in mS of (start-)portion of segments to retain.\n");
            fprintf(stdout,"INFO:                     If segment length is set to zero, the complete segments are retained.\n");
            fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
            fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
            fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
            fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
            fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
            fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
            fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(3):
            fprintf(stdout,"INFO: ISOLATE, IN PLACE, ALL THE SLICED UP SEGMENT(S) OF A SOUNDFILE\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The source is segmented into successive adjacent segments, written to distinct output files.\n");
            fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
            fprintf(stdout,"INFO: as in the source file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SLICE TIMES ...... Datafile contains a list of (increasing) times where the source is to be cut.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-times to be marked\n");
            fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
            fprintf(stdout,"INFO:           Cut-times are sorted into ascending order.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
            fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
            fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
            fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
            fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
            fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed using \"REJOIN\",\n");
            fprintf(stdout,"INFO:            WITHOUT needing to re-reverse them first.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(4):
            fprintf(stdout,"INFO: ISOLATE, IN PLACE, ALL THE SLICED UP SEGMENT(S) OF A SOUNDFILE, WITH SLIGHT OVERLAPS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The source is segmented into successive adjacent segments, written to distinct output files.\n");
            fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
            fprintf(stdout,"INFO: as in the source file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The cut segments are made to overlap slightly (good for isolating speech syllables).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SLICE TIMES ...... Datafile contains a list of (increasing) times where the source is to be cut.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-times to be marked\n");
            fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
            fprintf(stdout,"INFO:           Cut-times are sorted into ascending order.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
            fprintf(stdout,"INFO: DOVETAIL  ............ Length of segment overlaps in mS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
            fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
            fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
            fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
            fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
            fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed using \"REJOIN\",\n");
            fprintf(stdout,"INFO:            WITHOUT needing to re-reverse them first.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(REJOIN):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: REMIX SEGMENT-FILES ORIGINATING IN THE \"ISOLATE\" PROCESS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Process assumes the source files are semgents cut from a source, using \"ISOLATE\"\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The (possibly processed) files are here remixed together\n");
            fprintf(stdout,"INFO: returning segments to their original timings in the source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: If the segments were originally REVERSED by the isolate process\n");
            fprintf(stdout,"INFO: setting \"REVERSE SEGMENTS\" here will automatically re-reverse the (possibly processed) segments\n");
            fprintf(stdout,"INFO: before mixing them.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GAIN ....... Changes the output level (Range 0 - 1).\n");
            fprintf(stdout,"INFO:             (Note that output level is automatically turned down if output clips).\n");
            fprintf(stdout,"INFO: \n");
            break;      
        case(1):
            fprintf(stdout,"INFO: REMIX SEGMENT-FILES ORIGINATING IN THE \"ISOLATE\" PROCESS, WITH THE REMNANT FILE\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Process assumes the source files are segments cut from a source, using \"ISOLATE\"\n");
            fprintf(stdout,"INFO: PLUS the remnant file, which must be LAST in the list of input files.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The (possibly processed) files are here remixed together\n");
            fprintf(stdout,"INFO: returning segments to their original timings in the source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: If the segments were originally REVERSED by the isolate process\n");
            fprintf(stdout,"INFO: setting \"REVERSE SEGMENTS\" here will automatically re-reverse the (possibly processed) segments\n");
            fprintf(stdout,"INFO: before mixing them with the remnant file.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GAIN ....... Changes the output level (Range 0 - 1).\n");
            fprintf(stdout,"INFO:             (Note that output level is automatically turned down if output clips).\n");
            fprintf(stdout,"INFO: \n");
            break;      
        }
        break;
    case(PANORAMA):
        fprintf(stdout,"INFO: CREATE PANORAMA OF INPUT FILES, SPREADING ACROSS MULTICHANNEL SURROUND SPACE\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Loudspeakers assumed to be effectively surrounding the listening area from the front outwards.\n");
        fprintf(stdout,"INFO: Input sounds distributed in order from leftmost to rightmost position\n");
        fprintf(stdout,"INFO: (with a 360 degree spread specified, 180 is assumed to be the rightmost position).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES ----------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  SPECIFY THE NUMBER OF LOUDSPEAKERS, AND THE TOTAL ANGULAR WIDTH ( >= 190 degrees )\n");
        fprintf(stdout,"INFO: 2)  LIST OF LOUDSPEAKER POSITIONS, IN A FILE (TOTAL ANGULAR WIDTH >= 190 degrees)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS -------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1:\n");
        fprintf(stdout,"INFO:       NO. OF LOUDSPEAKERS ........ Assumed equally spaced.\n");
        fprintf(stdout,"INFO:       TOTAL ANGULAR WIDTH OF LSPKRS ......(190 - 360).\n");
        fprintf(stdout,"INFO:                       The loudspeaker array is assumed to be symmetrical around its centre-line.\n");
        fprintf(stdout,"INFO: MODE 2:\n");
        fprintf(stdout,"INFO:       LOUDSPEAKER POSITIONS ....... A textfile list of the angular positions of the loudspeakers.\n");
        fprintf(stdout,"INFO:           positions to the right of centre lie between 0 (front) and 180 (rear)\n");
        fprintf(stdout,"INFO:           positions to the left of centre lie between >180 (rear) and 360(=0) (front)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ANGULAR WIDTH OF SOUND IMAGE .......... (0 - 360 degrees).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ANGULAR OFFSET OF SOUND IMAGE ...... angle between centre-line of sounds and centre-line of loudspeakers.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SOUND CONFIGURATION ........ Distribution of output sounds within the sound image angle.\n");
        fprintf(stdout,"INFO:          1: sounds are equally spaced\n");
        fprintf(stdout,"INFO:          2: two sounds are equally spaced, followed by a gap, etc.\n");
        fprintf(stdout,"INFO:          3: three sounds are equally spaced, followed by a gap, etc.\n");
        fprintf(stdout,"INFO:          and so on\n");
        fprintf(stdout,"INFO:          Must be a divisor of the number of input sounds used.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOMISATION ............... Randomisation of sound positions (0-1).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FRONT-PAIR LSPKRS ....... If the angular width of the loudspeakers is 360 degrees.\n");
        fprintf(stdout,"INFO:          The speaker orientation is ambiguous.\n");
        fprintf(stdout,"INFO:          Default assumes that there is a single loudspeaker at centre front.\n");
        fprintf(stdout,"INFO:          Setting this flag forces a pair of lspkrs, symmetrically placed to each side of centre-front.\n");
        fprintf(stdout,"INFO:          (The flag is IGNORED if TOTAL ANGULAR WIDTH OF LSPKRS is less than 360 degrees )\n");
        fprintf(stdout,"INFO: FRONT-PAIR SOUND IMAGES ....... The same logic applied to the SOUND positions\n");
        fprintf(stdout,"INFO:          (ignored if the ANGULAR WIDTH OF SOUND IMAGE is less than 360 degrees )\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(TREMOLO):
        fprintf(stdout,"INFO: TREMOLO A SOUND, WITH ADJUSTABLE PEAK-WIDTH\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FRQWISE....Interpolate linearly between frqs in any frq brktable (default).\n");
        fprintf(stdout,"INFO: PITCHWISE..Interpolate logarithmically (like pitch). (Care with zero frqs).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TREMOLO FREQUENCY..is frequency of the tremolo vibration itself.\n");
        fprintf(stdout,"INFO: TREMOLO DEPTH......amplitude depth of tremolo.\n");
        fprintf(stdout,"INFO: OVERALL GAIN.......Overall signal gain, or envelope.\n");
        fprintf(stdout,"INFO: PEAK NARROWING ....Tremolo peaks can be made narrower.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ECHO):
        fprintf(stdout,"INFO: REPEATEDLY ECHO A SOUND\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DELAY...................must be greater than the sound duration.\n");
        fprintf(stdout,"INFO:               (use the \"DELAY\" program otherwise).\n");
        fprintf(stdout,"INFO: ATTENUATION.............change in level from one echo to the next.\n");
        fprintf(stdout,"INFO: MAXIMUM DURATION....... maximum duration of output (output may be shorter).\n");
        fprintf(stdout,"INFO: RANDOMISATION ......... Randomisation of echo times.\n");
        fprintf(stdout,"INFO: CUTOFF LEVEL .......... Level below which output signal is cut off.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PACKET):
        fprintf(stdout,"INFO: CREATE AN ENVELOPED SOUND-PACKET, CUT AND SHAPED FROM A SOURCE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOUND....Use signal minima around the specified location in the source, to determine where to cut a packet.\n");
        fprintf(stdout,"INFO: FORCED...Cut a packet at the specified location in the source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PACKET LOCATION IN SOURCE ........ Time in source around which packet is to be cut.\n");
        fprintf(stdout,"INFO:                    A single time value or a textfile list of times.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ......... Duration (of forced packet) or minimum-duration (of found packet) in mS.\n");
        fprintf(stdout,"INFO:                    (Must be less than half the source duration).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NARROWING ........ Narrowing of the packet envelope, which is normally cosinusoidal.\n");
        fprintf(stdout,"INFO:                    Values below 1.0 broaden the packet.\n");
        fprintf(stdout,"INFO:                    Values very close to zero may produce clicks (square-wave envelope).\n");
        fprintf(stdout,"INFO:                    High vals with short packets may produce click-impulses or silence.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CENTRING ........  Centring of the peak of the packet envelope.\n");
        fprintf(stdout,"INFO:                    0  gives a peak at centre: -ve values move the peak towards the start of packet\n");
        fprintf(stdout,"INFO:                    +ve values move the peak towards the end of the packet.\n");
        fprintf(stdout,"INFO:                    If the packet content has varying level, the true peak position may not correspond\n");
        fprintf(stdout,"INFO:                    to the envelope peak position, unless the \"-f\" flag is used.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NORMALISE ........ Normalise the packet level.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: EXPAND ........... Packet wave maxima(minima) are forced up(down) to the envelope contour of the packet.\n");
        fprintf(stdout,"INFO:                    (default, the packet envelope is simply imposed on the existing signal).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SHAVE SILENCE..... Remove leading or trailing silence in resultant packet.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SYNTHESIZER):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: SYNTHESIZE COMPLEX TONES\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Creates tones with any number of partials which may vary through time in frequency and level.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
            fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
            fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
            fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
            fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
            fprintf(stdout,"INFO: DURATION .......... Total Duration of the synthesized sound.\n");
            fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
            break;
        case(1):
            fprintf(stdout,"INFO: SYNTHESIZE PACKET_STREAMS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Creates a stream of wave-packets, which may vary in content through time.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
            fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
            fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
            fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
            fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
            fprintf(stdout,"INFO: DURATION .......... Total Duration of the synthesized sound.\n");
            fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NARROWING ......... Narrowing of the packet envelope, which is normally cosinusoidal.\n");
            fprintf(stdout,"INFO:                     Values below 1.0 broaden the packet.\n");
            fprintf(stdout,"INFO:                     Values very close to zero may produce clicks (square-wave envelope).\n");
            fprintf(stdout,"INFO:                     High vals with high frequencies may produce click-impulses or silence.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CENTRING .........  Centring of the peak of the packet envelope.\n");
            fprintf(stdout,"INFO:                     0 gives a peak at centre: -ve values move the peak towards the start of packet\n");
            fprintf(stdout,"INFO:                     +ve values move the peak towards the end of the packet.\n");
            fprintf(stdout,"INFO:                     If the packet content has varying level, the true peak position may not correspond\n");
            fprintf(stdout,"INFO:                     to the envelope peak position.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: STATIONARY PACKET PARAMS .......\n");
            fprintf(stdout,"INFO:                     With this flag set, packet parameters are set at the outset of a packet,\n");
            fprintf(stdout,"INFO:                     and remain the same until its end.\n");
            fprintf(stdout,"INFO:                     With no flag set, frq and level parameters of partials continue to vary WITHIN the packets.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: SYNTHESIZE GLISTENING SOUNDS\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Creates a distribution of partials-components of spectrum (which may vary through time), varying in time and space.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
            fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
            fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
            fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
            fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
            fprintf(stdout,"INFO: DURATION ............ Total Duration of the synthesized sound.\n");
            fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
            fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
            fprintf(stdout,"INFO: MAX OCTAVE TRANSPOSITION.. Maximum transposition of spectral components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in partials-content of output.\n");
            fprintf(stdout,"INFO: RISETIME ............ Time taken to attain max octave transposition range, at start of sound.\n");
            fprintf(stdout,"INFO: FALLTIME ............ Time taken to return to minimal range.\n");
            fprintf(stdout,"INFO: STEADY STATE ...... Time spent in minimal range at end of sound.\n");
            fprintf(stdout,"INFO: FROM FUNDAMENTAL  Initial rise in number of partials is from fundamental only.\n");
            fprintf(stdout,"INFO: TO FUNDAMENTAL .... Final \"steady state\" gradually contracts to using fundamental only.\n");
            fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
            fprintf(stdout,"INFO: PARTIALS IN PLAY . Number of partials used in any segment: If set to zero, number of partials used is random.\n");
            fprintf(stdout,"INFO: MAXCHANGE PARTIALS .. As far as possible, always change partials used, from one segment to the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPATIALISE ............ Distribute components in space.\n");
            fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
            fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
            fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
            fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
            fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all partials in a segment.\n");
            fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
            fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
            fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
            fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");               
            fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
            fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
            fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
            fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
            fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
            fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
            fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
            fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
            fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
            fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
            fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
            break;
        case(3):
            fprintf(stdout,"INFO: SYNTHESIZE FRACTALLY-ARRAYED SEQUENCES OF SPIKES\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Creates waveform with fractal distribution of spikes.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
            fprintf(stdout,"INFO: DURATION ............ Total Duration of the synthesized sound.\n");
            fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Shape of waveform is \"ON OFF ON OFF TAIL\" where ...\n");
            fprintf(stdout,"INFO:       \"ON\" segments contain signal, and are of same duration.\n");
            fprintf(stdout,"INFO:       \"OFF\" segments contain NO signal, and are of same duration.\n");
            fprintf(stdout,"INFO:       \"TAIL\" (can be zero length) is additional silence at waveform end.\n");
            fprintf(stdout,"INFO: The \"ON\" segments are then themselves divided in similar proportions, the resulting smaller \"ON\" segments similarly, and so on,\n");
            fprintf(stdout,"INFO: producing a  fractal distribution.\n");
            fprintf(stdout,"INFO: Signal spikes are then placed in the \"ON\" segments.\n");
            fprintf(stdout,"INFO: Spikes alternate from +ve to -ve at the specified level of fractalisation.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SAMPLES IN SPIKE ATTACK ... Number of samples in the spike attack (can be zero).\n");
            fprintf(stdout,"INFO: SLOPE OF SPIKE ATTACK ..... Slope of attack : 1 = linear  : >1 rises slowly-then-faster  : <1 rises fast-then-slower.\n");
            fprintf(stdout,"INFO: SAMPLES IN SPIKE DECAY .... Number of samples in the spike decay (can be zero).\n");
            fprintf(stdout,"INFO: SLOPE OF SPIKE DECAY ...... Slope of decay : 1 = linear  : >1 falls fast-then-slower  : <1 falls slowly-then-faster.\n");
            fprintf(stdout,"INFO: RATIO ONSEG TO ONOFF GROUPLENGTH ............ Determines relative size of \"ON\" and \"OFF\" segments.\n");
            fprintf(stdout,"INFO: RATIO ONOFFONOFF GROUPLENGTH TO WAVECYCLE LENGTH ............ \n");
            fprintf(stdout,"INFO:             Determines relative size of the 4 (\"ON\",\"OFF\",\"ON\",\"OFF\") segments group, and the total wavecycle length.\n");
            fprintf(stdout,"INFO: RANDOMISATION OF SPIKES ............ Degree of time-randomisation of the spikes.\n");
            fprintf(stdout,"INFO: FRACTALISATION LEVEL FOR SPIKES TO FLIP POS TO NEG ...... Level of fractalisation at which spikes flip from +ve to -ve.\n");
            break;
        }
        break;
    case(TAN_ONE):
        fprintf(stdout,"INFO: PLAY REPETITIONS OF MONO SOUND ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
        fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: EVENT COUNT ... Count of the events in the tangent stream (Single and Two src modes only).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
        fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
        fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
        fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
        fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
        fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
        fprintf(stdout,"INFO: the SAME final (approaching)  or initial (receding) event is repeated, at fixed level.\n");
        fprintf(stdout,"INFO: These repeated events are ADDITIONAL to the event-count.\n");
        break;
    case(TAN_TWO):
        fprintf(stdout,"INFO: PLAY REPETITIONS OF TWO MERGED MONO SOUNDS ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The two sources are superimposed along the tangent path, beginning with only the 1st sound\n");
        fprintf(stdout,"INFO: and gradually mixing in more of the 2nd sound from one event to the next.\n");
        fprintf(stdout,"INFO: If one input is a filtered version of the other, this suggest it might be more distant.\n");
        fprintf(stdout,"INFO: Hence for approaching motion the filterd sound should be first,\n");
        fprintf(stdout,"INFO: whereas for receding motion the filtered sound should be second.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
        fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: EVENT COUNT ... Count of the events in the tangent stream (Single and Two src modes only).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
        fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
        fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: BALANCE ACCUMULATOR ... Progressive accumulation of 2nd sound in the mix.\n");
        fprintf(stdout,"INFO:                  For an accumulation value of 0.33, succeesive mix would be [1.0 : 0.0] [0.66 : 0.33] [0.44 : 0.56] etc.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
        fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
        fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
        fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
        fprintf(stdout,"INFO: the SAME final (approaching)  or initial (receding) event is repeated, at fixed level.\n");
        fprintf(stdout,"INFO: These repeated events are ADDITIONAL to the event-count, and there are no balance changes here.\n");
        break;
    case(TAN_SEQ):
        fprintf(stdout,"INFO: PLAY SEQUENCE OF MONO SOUNDS ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
        fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
        fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
        fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
        fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
        fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
        fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
        fprintf(stdout,"INFO: the SAME final (approaching) or initial (receding) event is repeated, at fixed level\n");
        fprintf(stdout,"INFO: and these events are ADDED to the input events.\n");
        break;
    case(TAN_LIST):
        fprintf(stdout,"INFO: PLAY SEQUENCE OF MONO SOUNDS (IN A TEXTFILE LIST OF SOUNDS) ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
        fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
        fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
        fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
        fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DRAG ........... Slows the pan-motion acceleration.\n");
        fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
        fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
        fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
        fprintf(stdout,"INFO: the SAME final (approaching) or initial (receding) event is repeated, at fixed level.\n");
        fprintf(stdout,"INFO: and these repeated events are ADDED to the input events.\n");
        break;
    case(SPECTWIN):
        fprintf(stdout,"INFO: INTERBREED THE SPECTRAL CONTENT OF TWO DIFFERENT SOUNDS\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Spectral envelope may be drawn over the local-maxima of the channel-levels (Formant Envelope)\n");
        fprintf(stdout,"INFO: or simply follow the amplitude changes from one channel to the next (Absolute Envelope)\n");
        fprintf(stdout,"info: Spectral envelops are interbred as follows ....\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FORMANTS SND 1 WITH FORMANTS SND 2.\n");
        fprintf(stdout,"INFO: FORMANTS SND 1 WITH ABSOLUTE SND 2.\n");
        fprintf(stdout,"INFO: ABSOLUTE SND 1 WITH FORMANTS SND 2.\n");
        fprintf(stdout,"INFO: ABSOLUTE SND 1 WITH ABSOLUTE SND 2.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FREQUENCY INTERPOLATION .... Dominance of spectral frequencies of 2nd input file.\n");
        fprintf(stdout,"INFO:            Values > 0 move channel frequencies from those of file 1 towards those of file 2.\n");
        fprintf(stdout,"INFO: ENVELOPE INTERPOLATION ..... Dominance of spectral envelope of 2nd input file.\n");
        fprintf(stdout,"INFO:            Values > 0 move the envelope from that of file 1 towards that of file 2.\n");
        fprintf(stdout,"INFO:            Note that when Formant and Absolute envelopes are combined,\n");
        fprintf(stdout,"INFO:            the formant peaks are moved onto the absolute envelope,\n");
        fprintf(stdout,"INFO:            with all other channels moving proportionately.\n");
        fprintf(stdout,"INFO: SPECTRAL DUPLICATIONS .... Adds transposed copies to spectrum 1, before proceeding.\n");
        fprintf(stdout,"INFO: DUPLICATION INTERVAL .... Transposition from one duplication to next, in semitones.\n");
        fprintf(stdout,"INFO: DUPLICATION ROLLOFF ....  Level change in passing to next higher duplication.\n");
        break;
    case(TRANSIT):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A MONO SOUND\n");
        fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
        fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
        fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
        fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(TRANSITF):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A PAIR OF MONO SOUNDS\n");
        fprintf(stdout,"INFO:               ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  The 2nd sound is gradually mixed in to the first as distance from focus increases.\n");
        fprintf(stdout,"INFO:  If 2nd sound is a filtered version of the first, this may suggest greater distance.\n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO:  BALANCE DECIMATION ..Proportion of 2nd sound mixed into first as sound becomes more distant from focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
        fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
        fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
        fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(TRANSITD):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A MONO SOUND\n");
        fprintf(stdout,"INFO:        ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS,\n");
        fprintf(stdout,"INFO:                      SHIFTING TO 2nd SOUND ON PASSING FOCUS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  The 2nd sound replaces the first once the focus of the motion is passed.\n");
        fprintf(stdout,"INFO:  If the 2nd sound is a pitch-shifted version of the 1st, this may suggest doppler-shift.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Additional sounds may be input, to place at the centre point of the mix (near the focus)\n");
        fprintf(stdout,"INFO:  suggesting gradual changes in pitch at the doppler-shift moment.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
        fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
        fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
        fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(TRANSITFD):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A PAIR OF MONO SOUNDS\n");
        fprintf(stdout,"INFO:        ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS,\n");
        fprintf(stdout,"INFO:                      SHIFTING TO 2nd PAIR ON PASSING FOCUS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  The 2nd sound is gradually mixed in to the first as distance from focus increases.\n");
        fprintf(stdout,"INFO:  If 2nd sound is a filtered version of the first, this may suggest greater distance.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  The 3rd sound replaces the first once the focus of the motion is passed.\n");
        fprintf(stdout,"INFO:  If the 3rd sound is a pitch-shifted version of the 1st, this may suggest doppler-shift.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  The 4th sound is gradually mixed in to the 3rd, as with sounds 1 and 2.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Additional sounds may be input, to place at the centre point of the mix (near the focus)\n");
        fprintf(stdout,"INFO:  suggesting gradual changes in pitch at the doppler-shift moment.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO:  BALANCE DECIMATION ..Proportion of 2nd(4th) sound mixed into 1st(3rd) as sound becomes more distant from focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
        fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
        fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
        fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(TRANSITS):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS A SEQUENCE OF MONO SOUND\n");
        fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration will be double this value, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(TRANSITL):
        fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS A SEQUENCE OF MONO SOUND LISTED IN A TEXTFILE\n");
        fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
        fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
        fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
        fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
        fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
        fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
        fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
        fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
        fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  Total duration will be double this value, as the mix approaches and then recedes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
        fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
        fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
        break;
    case(CANTOR):
        fprintf(stdout,"INFO:  GRADUALLY INSERT HOLES INTO A SOURCE, IN THE MANNER OF A CANTOR SET\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:  A hole is gradually cut in the middle of the source sound, dividing into two parts.\n");
        fprintf(stdout,"INFO:  Then holes are cut in these two parts, and so on.\n");
        fprintf(stdout,"INFO:  The output is a set of versions of the source, with more and more holes.\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  MODE 1 .... Holesize proportional to size of segment they cut.\n");
        fprintf(stdout,"INFO:  MODE 2 .... Holesize is fixed.\n");
        fprintf(stdout,"INFO:  MODE 3 .... Holes generated by  superimposed layers of sinusoindal envelope-shapng..\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  In Modes 1 & 2\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  HOLE SIZE ........ Percentage of the input sound (or sound segment) taken up by the hole.\n");
        fprintf(stdout,"INFO:  DIG DEPTH ........ Depth of each cut (as a fraction of 1) as hole is gradually created.\n");
        fprintf(stdout,"INFO:  TRIGGER DEPTH .... Depth of hole at which next pair of holes start to be dug.\n");
        fprintf(stdout,"INFO:  SPLICE LENGTH .... Splice length in milliseconds.\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION.. Maximum total duration of all the output sounds.\n");
        fprintf(stdout,"INFO:  EXTEND TO LIMIT .. Proceed with hole digging even when there are not enough samples left to create splices.\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  In Modes 3\n");
        fprintf(stdout,"INFO:  \n");
        fprintf(stdout,"INFO:  MNIMUM HOLE LEVEL .. Level of signal at base of holes.\n");
        fprintf(stdout,"INFO:  DIG DEPTH .......... Number of repetitions for hole to reach its maximum depth.\n");
        fprintf(stdout,"INFO:  LAYER COUNT ........ Number of enveloping layers used.\n");
        fprintf(stdout,"INFO:  LAYER DECIMATION ... Relative depth at which each layer is imposed.\n");
        fprintf(stdout,"INFO:  MAXIMUM DURATION.... Maximum total duration of all the output sounds.\n");
        break;
    case(SHRINK):
        switch(mode) {
        case(0):
        case(1):
        case(2):
        case(3):
            switch(mode) {
            case(0):
                fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT, BY REMOVING ITS END, AS THE REPETITIONS PROCEEDS.\n");
                break;
            case(1):
                fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT AROUND ITS MIDPOINT AS THE REPETITIONS PROCEEDS.\n");
                break;
            case(2):
                fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT, BY REMOVING ITS BEGINNING, AS THE REPETITIONS PROCEEDS.\n");
                break;
            case(3):
                fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT AROUND A SPECIFIED TIME, AS THE REPETITIONS PROCEEDS.\n");
                break;
            }
            fprintf(stdout,"INFO:  \n");
            fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
            fprintf(stdout,"INFO:  \n");
            if(mode == 3)
                fprintf(stdout,"INFO:  CENTRE OF SHRINKAGE.. Time around which shrinkage takes place.\n");
            fprintf(stdout,"INFO:  SOUND SHRINKAGE ..... Shortening factor of sound from one repeat to the next.\n");
            fprintf(stdout,"INFO:                                                Shrinkage stops once events become too short for the splices.\n");
            fprintf(stdout,"INFO:  EVENT GAP ........... Initial timestep between output events (>= input sound duration).\n");
            fprintf(stdout,"INFO:  TIME CONTRACTION .....Shortening of time between placement of sounds in output stream.\n");
            fprintf(stdout,"INFO:                                                1.0 = events equally spaced, < 1.0 events become closer\n");
            fprintf(stdout,"INFO:                                                Events cannot overlap, so the minimum value of \"contraction\" = value of \"sound shrinkage\".\n");
            fprintf(stdout,"INFO:  DURATION ............ (Minimum) duration of the output.\n");
            fprintf(stdout,"INFO:  SPLICE LENGTH ....... Length of splices, in millseconds.\n");
            fprintf(stdout,"INFO:  MINIMUM EVENT DURATION ....... When sound duration reaches this minimum, shrinkage stops and events thereafter are of equal length.\n");
            fprintf(stdout,"INFO:  MINIMUM EVENT SEPARATION ..... When event separation reaches this minimum, contraction stops and events thereafter are equally spaced in time.\n");
            fprintf(stdout,"INFO:  EVENT TIME RANDOMISATION ..... Randomisation of entry times of events.\n");
            fprintf(stdout,"INFO:  EQUALISE EVENT LEVELS ........ Force the (maximum) level of all output events to that of the input event (if possible).\n");
            fprintf(stdout,"INFO:  REVERSE SEGMENTS ............. Output events are each reversed, but remain in the same time order.\n");
            break;
        case(4):
        case(5):
            switch(mode) {
            case(4):
                fprintf(stdout,"INFO:  IN A SOUND, SHRINK EVENTS CENTRED ROUND DETECTABLE PEAKS.\n");
                break;
            case(5):
                fprintf(stdout,"INFO:  IN A SOUND, SHRINK EVENTS CENTRED ROUND USER-SPECIFIED PEAKS.\n");
                break;
            }
            fprintf(stdout,"INFO:  \n");
            fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
            fprintf(stdout,"INFO:  \n");
            if(mode == 5)
                fprintf(stdout,"INFO:  PEAK TIMES .......... A textfile listing the times of peaks in the input sound file.\n");
            fprintf(stdout,"INFO:  SOUND SHRINKAGE ..... Shortening factor of sound from one repeat to the next.\n");
            fprintf(stdout,"INFO:                                                Shrinkage stops once events become too short for the splices.\n");
            if(mode == 4)
                fprintf(stdout,"INFO:  WINDOW SIZE ......... Size of window for peak detection (in milliSeconds).\n");
            else
                fprintf(stdout,"INFO:  WINDOW SIZE ......... Size of window for minima detection (in milliSeconds).\n");
            fprintf(stdout,"INFO:  TIME CONTRACTION .....Shortening of time between placement of sounds in output stream.\n");
            fprintf(stdout,"INFO:                                                1.0 = events equally spaced, < 1.0 events become closer\n");
            fprintf(stdout,"INFO:                                                Events cannot overlap, so the minimum value of \"contraction\" = value of \"sound shrinkage\".\n");
            fprintf(stdout,"INFO:  SHRINKAGE START...... Time at which shrinking begins.\n");
            fprintf(stdout,"INFO:  SPLICE LENGTH ....... Length of splices, in millseconds.\n");
            fprintf(stdout,"INFO:  MINIMUM EVENT DURATION ....... When sound duration reaches this minimum, shrinkage stops.\n");
            fprintf(stdout,"INFO:  MINIMUM EVENT SEPARATION ..... When event separation reaches this minimum, contraction stops.\n");
            fprintf(stdout,"INFO:  EVENT TIME RANDOMISATION ..... Randomisation of entry times of events.\n");
            fprintf(stdout,"INFO:  \n");
            fprintf(stdout,"INFO:  MINIMUM LENGTH FOR SQUEEZE START.....\n");
            fprintf(stdout,"INFO:                                 Minimum source-segment length before sound squeezing can begin (for the \"SQUEEZE EVENLY\" option)\n");
            fprintf(stdout,"INFO:  INPUT GATE .......... Input level (relative to the maximum level of the source) below which source-peaks are ignored.\n");
            if(mode == 4)
                fprintf(stdout,"INFO:  SKEW ................ Where, in the found source-segment, the sound is cut. e.g. 0 = at start  :  0.5 = in the middle  :  1 = at end.\n");
            fprintf(stdout,"INFO:  \n");
            fprintf(stdout,"INFO:  EQUALISE EVENT LEVELS ........ Force the (maximum) level of all output events to that of the input event (if possible).\n");
            fprintf(stdout,"INFO:  REVERSE SEGMENTS ............. Output events are each reversed, but remain in the same time order.\n");
            fprintf(stdout,"INFO:                        Mixing the output, then reversing the resultant sound produces an 'Expansion' of events,\n");
            fprintf(stdout,"INFO:                        opposite to the 'Shrinkage/Contraction'.\n");
            fprintf(stdout,"INFO:                        Note that the mixed sequence can be developed (each sound processed) to produce new, related sequences\n");
            fprintf(stdout,"INFO:                        which can be mixed using the same mix times as in the original.\n");
            fprintf(stdout,"INFO:                        If sounds processing involves any time-extension, start-times in the mix for the reversed segments will be altered.\n");
            fprintf(stdout,"INFO:                        Hence, with this flag set, an additional file is output listing the gaps between sound-ENDS in any mix\n");
            fprintf(stdout,"INFO:                        of the processed events.\n");
            fprintf(stdout,"INFO:  SQUEEZE EVENLY ............... If \"shrinkage\" > 0, sounds shorten in a regular manner.\n");
            fprintf(stdout,"INFO:                                                                If \"contraction\" > 0, output accelerates in a regular manner.\n");
            fprintf(stdout,"INFO:  OUTPUT GATE .................. Omit any too-quiet events, once a fixed end tempo has been reached.\n");
            break;
        }
        break;
    case(NEWTEX):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: GRANULATE SOURCE SOUND OVER TIME AND SPACE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Granulate several streams from a SINGLE source, where the source can be transposed.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TRANSPOSITION DATA ..... A textfile Listing of transposition ratios and relative levels, against time.\n");
            fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are transpositions, and these must increase through a line.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are loudness levels for those transposition, between -1 and 1.\n");
            fprintf(stdout,"INFO:                     -ve values invert the phase of the source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
            fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
            fprintf(stdout,"INFO: OCTAVE TRANSPOSITION.. Current range of additional octave transpositions of the original components.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in stream-content of output.\n");
            fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
            fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
            fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
            fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
            fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
            fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
            fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
            fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
            fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
            fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
            fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");
            fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
            fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
            fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
            fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
            fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
            fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
            fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
            fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
            fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
            fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
            fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: GRANULATE SEVERAL SOURCE SOUNDS OVER TIME AND SPACE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Granulate a group of sounds, where the sources are not transposed.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
            fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
            fprintf(stdout,"INFO: MAX SOURCE DUPLICATION...... Maximum number of simultaneous streams of any one source.\n");
            fprintf(stdout,"INFO: DELAY ................. Time delay between duplicated streams.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in stream-content of output.\n");
            fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
            fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
            fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
            fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
            fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
            fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
            fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
            fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
            fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
            fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
            fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");
            fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
            fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
            fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
            fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
            fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
            fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
            fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
            fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
            fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
            fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
            fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: GRANULATE SOURCE SOUND(S) OVER TIME AND SPACE, WITH DRUNKEN WALK THROUGH SOURCE(S).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The sources are not transposed.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
            fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
            fprintf(stdout,"INFO: MAX SOURCE DUPLICATION...... Maximum number of simultaneous streams of any one source.\n");
            fprintf(stdout,"INFO: LOCUS ................................. Time around which (next) source-read begins.\n");
            fprintf(stdout,"INFO: AMBITUS ............................ Area around locus within which next source-segment read may start.\n");
            fprintf(stdout,"INFO: DRUNK STEP ..................... Maximum size of random leap in source between start of this read and start of next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMESTEP ............ Average timestep in output between changes in stream-content.\n");
            fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
            fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
            fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
            fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
            fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
            fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
            fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
            fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
            fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
            fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
            fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");
            fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
            fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
            fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels, channel-pairs and triangles only.\n");
            fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, triangles, square, diamond and all-positions.\n");
            fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
            fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
            fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
            fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise, speed determined by \"Timestep\".\n");
            fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise, speed determined by \"Timestep\".\n");
            fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise, speed determined by \"Timestep\".\n");
            fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise, speed determined by \"Timestep\".\n");
            break;
        }
        break;
    case(CERACU):
        fprintf(stdout,"INFO: SUPERIMPOSE DIFFERENT CYCLIC REPETITIONS OF A SOUND, UNTIL THE CYCLES RESYNCHRONISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The source sound repeats at regular time-intervals.\n");
        fprintf(stdout,"INFO: There are 2 or more streams of such repetition, each with a different repetition time-interval.\n");
        fprintf(stdout,"INFO: A \"complete-cycle\" takes us from one point where all the streams are in sync to the next point where this is the case.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CYCLE COUNT DATA ................... A list of integers.\n");
        fprintf(stdout,"INFO:                                    The number of items in the list determines the number of simultaneous cycle-streams.\n");
        fprintf(stdout,"INFO:                                    The values entered determined how many repeats there are in each stream before all streams resynchronise.\n");
        fprintf(stdout,"INFO: SHORTEST REPEAT TIME .............. Time before the first repeat in the fastest cycle. If set to ZERO, assumed to be duration of input file.\n");
        fprintf(stdout,"INFO:                                    NB With many prime-number cycles, the \"Shortest Repeat Time\" may be adjusted upwards (sometimes considerably!)\n");
        fprintf(stdout,"INFO:                                    to allow all the repeating cycles to fit into a cycle with the correct number of repeats.\n");
        fprintf(stdout,"INFO:                                    (The minimum output duration, in samples, cannot be less than the Lowest Common Multiple of all the cycle-counts,\n");
        fprintf(stdout,"INFO:                                    and the cyclecnts will all be factors of this duration).\n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............ Number of output channels.\n");
        fprintf(stdout,"INFO: MINIMUM OUTPUT DURATION......... Minimum duration of the output. If set to ZERO, assumed to be one complete-cycle.\n");
        fprintf(stdout,"INFO:                                    Process always outputs a WHOLE NUMBER of complete-cycles\n");
        fprintf(stdout,"INFO:                                    and this output will be equal to or longer in duration than the output duration specified.\n");
        fprintf(stdout,"INFO: OVERRIDE LENGTH LIMIT ............. Force output to continue until a complete cycle is generated, no matter how long this may take.\n");
        fprintf(stdout,"INFO:                                    A warning will be given after 1 hour of output(!).\n");
        fprintf(stdout,"INFO:                                    No guarantee can be given that the program will not crash for extremely long durations.\n");
        fprintf(stdout,"INFO: ECHO DELAY ................................. An optional echo of the entire output can be added. To avoid this echo, set parameter to ZERO.\n");
        fprintf(stdout,"INFO:                                    The echo delay should not be greater than the \"Shortest Repeat Time\" BUT\n");
        fprintf(stdout,"INFO:                                    the \"Shortest Repeat Time\" may be recalculated (see program output) to accomodate\n");
        fprintf(stdout,"INFO: ECHO SPATIAL OFFSET ................ Any optional echo can be offset to a different channel.\n");
        fprintf(stdout,"INFO:                                    1 offset it 1 channel to the right, -1 offsets it 1 chyannel to the left, and so on.\n");
        fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY ................ If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
        fprintf(stdout,"INFO:                                    But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
        break;
    case(MADRID):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: REPEAT SOUND(S) WITH SPATIALISED ACCENTUATIONS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The source sounds repeat, with several superimposed copies played at different spatial locations.\n");
            fprintf(stdout,"INFO: By randomly deleting events from these streams spatial relocations and accents are produced.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OUTPUT DURATION ....................... Maximum Duration of output.\n");
            fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............... Number of channels in the output sound.\n");
            fprintf(stdout,"INFO: NUMBER OF STREAMS .................... Number of spatially distinct streams.\n");
            fprintf(stdout,"INFO: DELETION FACTOR ........................ Proportion of events to delete.\n");
            fprintf(stdout,"INFO:                                                        Values between 0 and 1 delete that proportion of events in the various streams.\n");
            fprintf(stdout,"INFO:                                                        For values greater than 1, the proportion of events at a single location increases.\n");
            fprintf(stdout,"INFO: and, if you \"ALLOW GAPS IN OUTPUT\", the proportion of empty events also increases.\n");
            fprintf(stdout,"INFO: EVENT TIME STEP .......................... Time-step between event repetitions.\n");
            fprintf(stdout,"INFO: EVENT TIME RANDOMISATION .......... Randomisation of time-step between event repetitions.\n");
            fprintf(stdout,"INFO: DELETION SEED VALUE .................... If the process is run a 2nd time, with the SAME parameters,\n");
            fprintf(stdout,"INFO:                                                        If the seed value is set to the same POSITIVE value, deletions will be the same.\n");
            fprintf(stdout,"INFO:                                                        If set to zero however, deletions will always be different, even when all other parameters are the same.\n");
            fprintf(stdout,"INFO: ALLOW GAPS IN OUTPUT ................. Some repeptition points may have NO sound at all.\n");
            fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
            fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
            fprintf(stdout,"INFO: RANDOMLY_PERMUTE_INFILE_ORDER . Randomly permuter order of input files, and play 1 of each in this order before creating the next order permutation.\n");
            fprintf(stdout,"INFO: RANDOMLY_SELECT_INFILE .............. Randomly select the next input file to use, independently of any previous selection.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: You cannot use BOTH Random Permutation AND Random Selection.\n");
            fprintf(stdout,"INFO: Neither of these flags is operational where there is only ONE input sound.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: SEQUENCE SOUND(S) WITH SPATIALISED ACCENTUATIONS.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The source sounds follow each other in a defined sequence\n");
            fprintf(stdout,"INFO: with several superimposed copies played at different spatial locations.\n");
            fprintf(stdout,"INFO: By randomly deleting events from these streams spatial relocations and accents are produced.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEQUENCE DATA ........................ Textfile of integers between 1 and the number of input files.\n");
            fprintf(stdout,"INFO:                                                        The sequence of numbers in this file determines the sequence of input files used in the output.\n");
            fprintf(stdout,"INFO: OUTPUT DURATION ....................... Maximum Duration of output.\n");
            fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............... Number of channels in the output sound.\n");
            fprintf(stdout,"INFO: NUMBER OF STREAMS .................... Number of spatially distinct streams.\n");
            fprintf(stdout,"INFO: DELETION FACTOR ........................ Proportion of events to delete.\n");
            fprintf(stdout,"INFO:                                                        Values between 0 and 1 delete that proportion of events in the various streams.\n");
            fprintf(stdout,"INFO:                                                        For values greater than 1, the proportion of events at a single location increases.\n");
            fprintf(stdout,"INFO: and, if you \"ALLOW GAPS IN OUTPUT\", the proportion of empty events also increases.\n");
            fprintf(stdout,"INFO: EVENT TIME STEP .......................... Time-step between event repetitions.\n");
            fprintf(stdout,"INFO: EVENT TIME RANDOMISATION .......... Randomisation of time-step between event repetitions.\n");
            fprintf(stdout,"INFO: DELETION SEED VALUE .................... If the process is run a 2nd time, with the SAME parameters,\n");
            fprintf(stdout,"INFO:                                                        If the seed value is set to the same POSITIVE value, deletions will be the same.\n");
            fprintf(stdout,"INFO:                                                        If set to zero however, deletions will always be different, even when all other parameters are the same.\n");
            fprintf(stdout,"INFO: ALLOW GAPS IN OUTPUT ................. Some repeptition points may have NO sound at all.\n");
            fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
            fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: You cannot use BOTH Random Permutation AND Random Selection.\n");
            fprintf(stdout,"INFO: Neither of these flags is operational where there is only ONE input sound.\n");
            break;
        }
        break;
    case(SHIFTER):
        fprintf(stdout,"INFO: GENERATE A SERIES OF SIMULTANEOUS REPETITION STREAMS WHERE THE RHYTHMIC PULSE SHIFTS FROM ONE TO THE OTHER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The source sound repeats regularly in (specified) cycles.\n");
        fprintf(stdout,"INFO: The tempi of the cycles is arranged so that the streams resynchronise after a set number of repetitions.\n");
        fprintf(stdout,"INFO: e.g. 11,12,13 would set up 3 streams which repeat the sound 11,12 and 13 times, respectively, before the streams resynchronise.\n");
        fprintf(stdout,"INFO: The focus may shift from one stream to another (by loudness emphasis), as the output sound evolves.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CYCLE DATA ................................. Textfile list of at least 2 different integers with values  >= 2.\n");
        fprintf(stdout,"INFO:                                                        In Mode 2, the number of entries should equal the number of input sound-sources.\n");
        fprintf(stdout,"INFO:                                                        These numbers represent the count of repetitions in each output stream before the streams resynchronise.\n");
        fprintf(stdout,"INFO: CYCLE DURATION ........................ Duration from one streams-synchronisation-point to the next.\n");
        fprintf(stdout,"INFO:                                                        Cycle duration and cycle data together determine the tempi of the different streams.\n");
        fprintf(stdout,"INFO: MIN OUTPUT DURATION ................ Minimum Duration of the output.\n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............. Number of channels in the output sound. The cycles play at fixed locations distributed over the output array.\n");
        fprintf(stdout,"INFO: MINIMUM BEAT DIVISION .............. Smallest integer subdivision of the beat: a multiple of 2 or 3, and greater than 4.\n");
        fprintf(stdout,"INFO:                                                        This determines the quantisation of the entry-times in the various streams.\n");
        fprintf(stdout,"INFO: LINGER CYCLES .......................... Number of cycles for which the focus is on any one cycle.\n");
        fprintf(stdout,"INFO: TRANSITION CYCLES .................... Number of cycles during which the focus moves from one cycle to another.\n");
        fprintf(stdout,"INFO:                                                        The sum of Linger cycles and Transition cycles must be >= 1.\n");
        fprintf(stdout,"INFO: FOCUS LEVEL BOOST .................... If the standard stream level is \"L\", the focus stream is increased in level by \"L\" times \"FOCUS LEVEL BOOST\".\n");
        fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
        fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In standard operation, focus shifts to each of the listed cycles in the order they appear in the data file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: READ BACK AND FORTH_THROUGH FOCUS .. Focus shifts gradually to the end of the data list, then back gradually towards the start, and so on.\n");
        fprintf(stdout,"INFO: RANDOMLY PERMUTE FOCUS ........... The cycle to focus on is determined by a random permutation of the order of the cycles.\n");
        fprintf(stdout,"INFO:                                                        Once all the cycles have been used, a new permutation is made.\n");
        fprintf(stdout,"INFO: You cannot use both Back-and-Forth AND Random focus shift.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(FRACTURE):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: MONO SOUND GRADUALLY FRACTURES INTO ELEMENTS DISTRIBUTED IN SPACE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stderr,"INFO: The source is cut into fragments which are enveloped and possibly transpose-stacked\n");
            fprintf(stderr,"INFO: and these fragments are distributed in space.\n");
            fprintf(stderr,"INFO: Stacks are synchronised at the envelope peak of the fragment.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ENVELOPE SERIES ......... A text datafile of lines consisting of a time and 7 pairs of envelope data.\n");
            fprintf(stdout,"INFO:                                                       The times are abslute times and must start at 0 and advance.\"\n");
            fprintf(stdout,"INFO:                                                       Each pair of the 7 consists of an \"etime\" and a level value.\n");
            fprintf(stdout,"INFO:                                                       Etimes are RELATIVE times within the envelope.\n");
            fprintf(stdout,"INFO:                                                       In Each line they must start at 0, end at 1, and advance.\n");
            fprintf(stdout,"INFO:                                                       Levels values should lie between 0 and 1. The first and last values MUST be zero, and the maximum value MUST be 1.0.\n");
            fprintf(stdout,"INFO:                                                       Envelopes to use at a specific time are derived by interpolating between the given envelopes\n");
            fprintf(stdout,"INFO:                                                       and subsequently modifying their depth (how close to zero they cut - see below).\n");
            fprintf(stdout,"INFO: OUTPUT CHANNELS ......... The number of channels in the output file (2-16).\n");
            fprintf(stdout,"INFO: NUMBER OF SPATIAL STREAMS .. The number of spatial positions to which the resulting fragments are allotted ( >=4 ).\n");
            fprintf(stdout,"INFO: PULSE DURATION ............ The average time between each SET of fragments (one in each stream).\n");
            fprintf(stdout,"INFO: DEPTH AND STACK ........... Between 0 and 1 this parameter controls how deeply the envelopes cut into the source.\n");
            fprintf(stdout,"INFO:                                                       With depth 1 the envelope cuts down to zero (as in the input envelope data).\n");
            fprintf(stdout,"INFO:                                                       With depth 0.75 the envelope cuts 3/4 of the way to zero.\n");
            fprintf(stdout,"INFO:                                                       With depth 0 the envelope has NO EFFECT on the source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                                                       Once the depth value exceeds 1, a STACK value is derived, being the depth minus 1.\n");
            fprintf(stdout,"INFO:                                                       Stacking adds transposed copies to the fragment, synchronised around the envelope peak.\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 2, the Stack value is 1: The 1st transposed element is added at full level,\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 1.5, the Stack value is .5: the transposed element is added at 1/2 level,\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 2.5, the Stack value is 1.5: The first element is added at full level, the 2nd at 1/2 level\n");
            fprintf(stdout,"INFO:                                                       and so on.\n");
            fprintf(stdout,"INFO: STACKING INTERVAL ........ Interval of (upward) transposition in the stack, in semitones (0-12).\n");
            fprintf(stdout,"INFO:                                                       The (Default) zero value is read as an octave (12). Zeros MUST NOT BE USED in stack brkpoint files.\n");
            fprintf(stdout,"INFO: READ RANDOMISATION .... Randomisation of the fragment read-time in the source. Range 0-1.\n");
            fprintf(stdout,"INFO: PULSE RANDOMISATION ... Randomisation of the pulse duration. Range 0-1.\n");
            fprintf(stdout,"INFO:                                                       In both cases, maximum random scatter scatters within range +- half the duration of the fragment.\n");
            fprintf(stdout,"INFO: STREAM DISPERSAL ........ Scattering of the output timings amongst different streams.\n");
            fprintf(stdout,"INFO:                                                       If pulse(+randomisation) generates a timing \"P\",\n");
            fprintf(stdout,"INFO:                                                       With Dispersal 0 : all fragments start at \"P\".\n");
            fprintf(stdout,"INFO:                                                       With Dispersal 1 : fragments are scattered within a range of +- half the duration of the fragment.\n");
            fprintf(stdout,"INFO:                                                       Intermediate values scattered fragment start-times to various extents around the time \"W\".\n");
            fprintf(stdout,"INFO: LEVEL RANDOMISATION .... Randomisation of the levels of the fragments. Range  0 - 1.\n");
            fprintf(stdout,"INFO:                                                       With value 0: All fragments are at full level. Value 1 produces random levels between 0 & full level.\n");
            fprintf(stdout,"INFO: ENVELOPE RANDOMISATION .. Randomisation of the choice of source envelope.\n");
            fprintf(stdout,"INFO:                                                       This is a time-range between 0 and \"now\".\n");
            fprintf(stdout,"INFO:                                                       If set (>0) the time in the envelope data file at which the envelope is selected\n");
            fprintf(stdout,"INFO:                                                       is set randomly between \"now\" and \"now minus time-range\".\n");
            fprintf(stdout,"INFO: STACK RANDOMISATION .. Randomisation of the stacking depth.\n");
            fprintf(stdout,"INFO:                                                       If set to zero, stacking depth is determined completely by the depth parameter (S = D - 1).\n");
            fprintf(stdout,"INFO:                                                       If set to one, stacking depth is selected at random between 0 and the given value.\n");
            fprintf(stdout,"INFO:                                                       Intermediate values give intermediate random-selection ranges.\n");
            fprintf(stdout,"INFO: PITCH RANDOMISATION IN CENTS .. Randomisation of the transposition of the fragments.\n");
            fprintf(stdout,"INFO:                                                       If set to \"P\", Fragments are randomly transposed in pitch between +P and -P.\n");
            fprintf(stdout,"INFO: RANDOM SEED .............. If the seed value is set as ZERO, and randomising parameters are used,\n");
            fprintf(stdout,"INFO:                                                       running the process again with IDENTICAL parameters will produce DIFFERENT output (due to the the variable randomisation).\n");
            fprintf(stdout,"INFO:                                                       With a POSITIVE seed value, re-running the process with IDENTICAL randomising parameters produces IDENTICAL (randomised) output.\n");
            fprintf(stdout,"INFO: MINIMUM FRAGMENT DURATION .... Minimum duration of any fragment in any stream.\n");
            fprintf(stdout,"INFO: MAXIMUM FRAGMENT DURATION ... Maximum duration of any fragment in any stream.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PERMIT SHORT STACKS ... Normally, very sort events are not stacked (to prevent clipping). Setting this flag allows short events to be stacked.\n");
            fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY ... If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
            fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NB Stacking, and the read, level & pitch randomisations ARE NOT ACTIVATED if the depth is less than 1.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: MONO SOUND GRADUALLY FRACTURES INTO ELEMENTS DISTRIBUTED IN STEREO, THEN STEREO-IMAGE POSITIONED IN MULTICHANNEL SPACE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stderr,"INFO: The source is cut into fragments which are enveloped and possibly transpose-stacked\n");
            fprintf(stderr,"INFO: and these fragments are distributed in space.\n");
            fprintf(stderr,"INFO: Stacks are synchronised at the envelope peak of the fragment.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The stereo \"front\" is then positioned in multichannel space.\n");
            fprintf(stdout,"INFO: If the front moves it must always move forwards.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ENVELOPE SERIES ......... A text datafile of lines consisting of a time and 7 pairs of envelope data.\n");
            fprintf(stdout,"INFO:                                                       The times are abslute times and must start at 0 and advance.\"\n");
            fprintf(stdout,"INFO:                                                       Each pair of the 7 consists of an \"etime\" and a level value.\n");
            fprintf(stdout,"INFO:                                                       Etimes are RELATIVE times within the envelope.\n");
            fprintf(stdout,"INFO:                                                       In Each line they must start at 0, end at 1, and advance.\n");
            fprintf(stdout,"INFO:                                                       Levels values should lie between 0 and 1. The first and last values MUST be zero, and the maximum value MUST be 1.0.\n");
            fprintf(stdout,"INFO:                                                       Envelopes to use at a specific time are derived by interpolating between the given envelopes\n");
            fprintf(stdout,"INFO:                                                       and subsequently modifying their depth (how close to zero they cut - see below).\n");
            fprintf(stdout,"INFO: OUTPUT CHANNELS ......... The number of channels in the output file (2-16).\n");
            fprintf(stdout,"INFO: NUMBER OF SPATIAL STREAMS .. The number of spatial positions to which the resulting fragments are allotted ( >=4 ).\n");
            fprintf(stdout,"INFO: PULSE DURATION ............ The average time between each SET of fragments (one in each stream).\n");
            fprintf(stdout,"INFO: DEPTH AND STACK ........... Between 0 and 1 this parameter controls how deeply the envelopes cut into the source.\n");
            fprintf(stdout,"INFO:                                                       With depth 1 the envelope cuts down to zero (as in the input envelope data).\n");
            fprintf(stdout,"INFO:                                                       With depth 0.75 the envelope cuts 3/4 of the way to zero.\n");
            fprintf(stdout,"INFO:                                                       With depth 0 the envelope has NO EFFECT on the source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                                                       Once the depth value exceeds 1, a STACK value is derived, being the depth minus 1.\n");
            fprintf(stdout,"INFO:                                                       Stacking adds transposed copies to the fragment, synchronised around the envelope peak.\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 2, the Stack value is 1: The 1st transposed element is added at full level,\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 1.5, the Stack value is .5: the transposed element is added at 1/2 level,\n");
            fprintf(stdout,"INFO:                                                       With a Depth of 2.5, the Stack value is 1.5: The first element is added at full level, the 2nd at 1/2 level\n");
            fprintf(stdout,"INFO:                                                       and so on.\n");
            fprintf(stdout,"INFO: STACKING INTERVAL ........ Interval of (upward) transposition in the stack, in semitones (0-12).\n");
            fprintf(stdout,"INFO:                                                       The (Default) zero value is read as an octave (12). Zeros MUST NOT BE USED in stack brkpoint files.\n");
            fprintf(stdout,"INFO: CENTRE OF IMAGE .......... Channel from which stereo image radiates (must be an integer).\n");
            fprintf(stdout,"INFO: FRONT POSITION ............ Position of stereo image in surround-space.\n");
            fprintf(stdout,"INFO:                                                       1 : front at centre lspkr.     -1: front at lspkr opposite to centre      0 : front at midline of surround-space.\n");
            fprintf(stdout,"INFO:                                                       2 : front infinitely far away in direction of centre lspkr.     -(2+(depth*2)) : front infinitely far away in direction opposite to centre lspkr.\n");
            fprintf(stdout,"INFO: DEPTH BEHIND FRONT ...... Fraction of total channels activated behind spreading front.\n");
            fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
            fprintf(stdout,"INFO:                                                       0, No rolloff, all channels play at full-current-level as they are added.\n");
            fprintf(stdout,"INFO:                                                       1, Full rolloff, levels fall to 1/N of full-current-level when Nth channels is added.\n");
            fprintf(stdout,"INFO:                                                       Intermediate values are possible.\n");
            fprintf(stdout,"INFO: READ RANDOMISATION .... Randomisation of the fragment read-time in the source. Range 0-1.\n");
            fprintf(stdout,"INFO: PULSE RANDOMISATION ... Randomisation of the pulse duration. Range 0-1.\n");
            fprintf(stdout,"INFO:                                                       In both cases, maximum random scatter scatters within range +- half the duration of the fragment.\n");
            fprintf(stdout,"INFO: STREAM DISPERSAL ........ Scattering of the output timings amongst different streams.\n");
            fprintf(stdout,"INFO:                                                       If pulse(+randomisation) generates a timing \"P\",\n");
            fprintf(stdout,"INFO:                                                       With Dispersal 0 : all fragments start at \"P\".\n");
            fprintf(stdout,"INFO:                                                       With Dispersal 1 : fragments are scattered within a range of +- half the duration of the fragment.\n");
            fprintf(stdout,"INFO:                                                       Intermediate values scattered fragment start-times to various extents around the time \"W\".\n");
            fprintf(stdout,"INFO: LEVEL RANDOMISATION .... Randomisation of the levels of the fragments. Range  0 - 1.\n");
            fprintf(stdout,"INFO:                                                       With value 0: All fragments are at full level. Value 1 produces random levels between 0 & full level.\n");
            fprintf(stdout,"INFO: ENVELOPE RANDOMISATION .. Randomisation of the choice of source envelope.\n");
            fprintf(stdout,"INFO:                                                       This is a time-range between 0 and \"now\".\n");
            fprintf(stdout,"INFO:                                                       If set (>0) the time in the envelope data file at which the envelope is selected\n");
            fprintf(stdout,"INFO:                                                       is set randomly between \"now\" and \"now minus time-range\".\n");
            fprintf(stdout,"INFO: STACK RANDOMISATION .. Randomisation of the stacking depth.\n");
            fprintf(stdout,"INFO:                                                       If set to zero, stacking depth is determined completely by the depth parameter (S = D - 1).\n");
            fprintf(stdout,"INFO:                                                       If set to one, stacking depth is selected at random between 0 and the given value.\n");
            fprintf(stdout,"INFO:                                                       Intermediate values give intermediate random-selection ranges.\n");
            fprintf(stdout,"INFO: PITCH RANDOMISATION IN CENTS .. Randomisation of the transposition of the fragments.\n");
            fprintf(stdout,"INFO:                                                       If set to \"P\", Fragments are randomly transposed in pitch between +P and -P.\n");
            fprintf(stdout,"INFO: RANDOM SEED .............. If the seed value is set as ZERO, and randomising parameters are used,\n");
            fprintf(stdout,"INFO:                                                       running the process again with IDENTICAL parameters will produce DIFFERENT output (due to the the variable randomisation).\n");
            fprintf(stdout,"INFO:                                                       With a POSITIVE seed value, re-running the process with IDENTICAL randomising parameters produces IDENTICAL (randomised) output.\n");
            fprintf(stdout,"INFO: MINIMUM FRAGMENT DURATION .... Minimum duration of any fragment in any stream.\n");
            fprintf(stdout,"INFO: MAXIMUM FRAGMENT DURATION ... Maximum duration of any fragment in any stream.\n");
            fprintf(stdout,"INFO: ATTENUATION FACTOR .......... Rapidity of attenuation of level of front, with distance from ring,\n");
            fprintf(stdout,"INFO:                                                       or during intrinsic fade-out of sound which doesn't recede into far distance.\n");
            fprintf(stdout,"INFO:                                                       1 = linear fade.\n");
            fprintf(stdout,"INFO: SUBTEND ZERO POINT ......... Point at which image becomes mono as it retreats from circle, or ceases being mono as it approaches the circle of loudspeakers.\n");
            fprintf(stdout,"INFO:                                                       Ratio of the required-distance(time)-to-the-subtend-zero-point to the total-distance(time)-to-infinity.\n");
            fprintf(stdout,"INFO: CONTRACTION FACTOR ...... Rate of contraction of image :  1 = linear.\n");
            fprintf(stdout,"INFO: MAX FILTER POINT ............ Point at which image becomes entirely lo-pass filtered as it retreats from circle, or begins to de-filter as it approaches the circle of loudspeakers.\n");
            fprintf(stdout,"INFO:                                                       Ratio of the required-distance(time)-to-the-max-filter-point to the total-distance(time)-to-infinity.\n");
            fprintf(stdout,"INFO: FILTER MIX FACTOR ............ Rate of replacement by filtered image :  1 = linear.\n");
            fprintf(stdout,"INFO: FILTER LOPASS FREQUENCY.. Low-pass cut-off frequency of distance-filter.\n");
            fprintf(stdout,"INFO: FADE IN ........................... Proportion of total duration over which event fades in from zero (independently of any fade associated with distance).\n");
            fprintf(stdout,"INFO: FADE OUT ......................... Proportion of total duration over which event decays to zero (independently of any fade associated with distance).\n");
            fprintf(stdout,"INFO: OVERALL GAIN ................. Overall gain: rare possibility that very rapid contraction with very low attenuation rate may cause overload in mixing to mono.\n");
            fprintf(stdout,"INFO:                                                       In case of overload, turn down inputs with \"Overall Gain\".\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PERMIT SHORT STACKS ... Normally, very sort events are not stacked (to prevent clipping). Setting this flag allows short events to be stacked.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NB The stacking, level and repitching parameters DO NOT KICK IN until the depth reaches 1.\n");
            break;
        }
        break;
    case(SUBTRACT):
        fprintf(stdout,"INFO: SUBTRACTS A MONO FILE FROM (1 CHANNEL OF) ANOTHER FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The first file can have any number of channels.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CHANNEL TO SUBTRACT .......... The number ( 1 - N ) of any channel in the 2nd file. (Setting to ZERO subtracts channel 1).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPEKLINE):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: CREATING SPECTRUM FROM SPECTRAL LINES TEXT DATA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ANALYSIS CHANNELS .......................... Number of channels in output spectral file (multiple of 2).\n");
            fprintf(stdout,"INFO: SOUND SAMPLING RATE ...................... Sampling rate of sound which will eventually be generated.\n");
            fprintf(stdout,"INFO: OUTPUT DURATION .............................. Duration of output spectrum.\n");
            fprintf(stdout,"INFO: NO OF ADDED HARMONICS .................. Number of harmonics to add to basic input spctrum.\n");
            fprintf(stdout,"INFO: HARMONICS ROLLOFF(dB).................... Rolloff (in dB) proceeding from one harmonic to the next.\n");
            fprintf(stdout,"INFO: FOOT OF INPUT DATA ........................ Minimum value in input to be represented in output spectrum ( less or equal to min data value).\n");
            fprintf(stdout,"INFO: CEILING OF INPUT DATA ..................   Maximum value in input to be represented in output spectrum ( breater than or equal to max data value).\n");
            fprintf(stdout,"INFO: FOOT OF SPECTRUM IN OUTPUT ........  Frequency of minimum value represented in output spectrum.\n");
            fprintf(stdout,"INFO: CEILING OF SPECTRUM IN OUTPUT .. Frequency of maximum value represented in output spectrum.\n");
            fprintf(stdout,"INFO: OVERALL GAIN .................................... Attenuation of output spectrum.\n");
            fprintf(stdout,"INFO: SPECTRAL WARP .................................. If NOT set to 1.0, warpa the shape of the output spectrum .... \n");
            fprintf(stdout,"INFO:                               Warp greater than 1 causes spectrum to be squeezed into the lower frequencies.\n");
            fprintf(stdout,"INFO:                               Warp less than 1 causes spectrum to be squeezed into the higher frequencies.\n");
            fprintf(stdout,"INFO: AMPLITUDE RANGE FLATTENING ........ If NOT set to 1.0 changes range of amplitudes of spectral lines.... \n");
            fprintf(stdout,"INFO:                               As value increases, amplitude range is increasingly flattened.\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: CREATING FILTER DATA FILE FROM SPECTRAL LINES TEXT DATA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SOUND SAMPLING RATE ...................... Sampling rate of sound which will eventually be generated.\n");
            fprintf(stdout,"INFO: OUTPUT DURATION .............................. Duration of output spectrum.\n");
            fprintf(stdout,"INFO: FOOT OF INPUT DATA ........................ Minimum value in input to be represented in output spectrum ( less or equal to min data value).\n");
            fprintf(stdout,"INFO: CEILING OF INPUT DATA ..................   Maximum value in input to be represented in output spectrum ( breater than or equal to max data value).\n");
            fprintf(stdout,"INFO: FOOT OF SPECTRUM IN OUTPUT ........  Frequency of minimum value represented in output spectrum.\n");
            fprintf(stdout,"INFO: CEILING OF SPECTRUM IN OUTPUT .. Frequency of maximum value represented in output spectrum.\n");
            fprintf(stdout,"INFO: SPECTRAL WARP .................................. If NOT set to 1.0, warpa the shape of the output spectrum .... \n");
            fprintf(stdout,"INFO:                               Warp greater than 1 causes spectrum to be squeezed into the lower frequencies.\n");
            fprintf(stdout,"INFO:                               Warp less than 1 causes spectrum to be squeezed into the higher frequencies.\n");
            fprintf(stdout,"INFO: AMPLITUDE RANGE FLATTENING ........ If NOT set to 1.0 changes range of amplitudes of spectral lines.... \n");
            fprintf(stdout,"INFO:                               As value increases, amplitude range is increasingly flattened.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(SPECMORPH):
        switch(mode) {
        case(6):
            fprintf(stdout,"INFO: MORPH, IN STEPS, BETWEEN TWO DISSIMILAR SPECTRA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Spectral peaks of 2 files are matched and, at each output step, move away from 1st and closer to 2nd.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NUMBER OF PEAKS TO MAP ..................... Number of peaks to look for.\n");
            fprintf(stdout,"INFO: NUMBER OF INTERMEDIATE FILES ... Number of output files with peaks in between the 1st and 2nd input files.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RETAIN LOUDNESS ENVELOPE OF 1st SND The loudness contour of the 1st sound is retained, even as its spectrum is changed.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: INTERP PEAKS ONLY .................... Retain file1 content of all non-peak channels.\n");
            fprintf(stdout,"INFO:                                   (In default case, non-peak channels interpolate towards file2 values).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: INTERP PEAK FREQUENCIES ONLY .. Amplitudes of peak channels are determined by peak amplitudes of sound 1 only.\n");
            fprintf(stdout,"INFO: \n");
            break;
        default:
            fprintf(stdout,"INFO: MORPH BETWEEN TWO DISSIMILAR SPECTRA.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Spectral peaks are matched, and pitch-glide towards one another.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Modes 1 and 2: Calculate the channels of the spectral peaks as an average over the whole sound.\n");
            fprintf(stdout,"INFO: Modes 3 and 4: Calculate the channels of the spectral peaks on a window by window basis.\n");
            fprintf(stdout,"INFO: Modes 5 and 6: Uses harmonic field of the average peaks in the 2nd sound to tune the spectrum of the 1st.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: 2nd FILE ENTRY TIME ........... Entry of 2nd sound may be delayed (but morph can only begin oce it has entered).\n");
            fprintf(stdout,"INFO: INTERPOLATION START ........ Start time of the morph.\n");
            fprintf(stdout,"INFO: INTERPOLATION END ........... End time of the morph.\n");
            fprintf(stdout,"INFO: INTERPOLATION EXPONENT ... Determines the shape of the interpolation.\n");
            fprintf(stdout,"INFO:                      In modes 1 and 3\n");
            fprintf(stdout,"INFO:                                   exponent 1 gives a linear interpolation.\n");
            fprintf(stdout,"INFO:                                   exponent more than 1 interpolates slower at the start and faster at the end.\n");
            fprintf(stdout,"INFO:                                   exponent less than 1 interpolates faster at the start and slower at the end.\n");
            fprintf(stdout,"INFO:                      In modes 2 and 4\n");
            fprintf(stdout,"INFO:                                   exponent 1 gives a cosinusiodal interpolation.\n");
            fprintf(stdout,"INFO:                                   exponent more than 1 forces the cosinusiodal transition towards the midpoint-time.\n");
            fprintf(stdout,"INFO:                                   exponent less than 1 speeds up the initial and final interpolation-rate.\n");
            fprintf(stdout,"INFO:                                   exponent .85 approaches the linear case.\n");
            fprintf(stdout,"INFO:                                   Below .85 the interpolation lingers longer around its half-way point.\n");
            fprintf(stdout,"INFO: NUMBER OF PEAKS TO MAP ..................... Number of peaks to look for.\n");
            fprintf(stdout,"INFO: RANDOMISATION OF GOAL PEAK FRQ ... Randomisation of goal peak-frequencies (can vary over time).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RETAIN LOUDNESS ENVELOPE OF 1st SND The loudness contour of the 1st sound is retained, even as its spectrum morphs.\n");
            fprintf(stdout,"INFO:                                   In this case, output will cease once the 1st sound ends.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: INTERP PEAKS ONLY .................... Retain file1 content of all non-peak channels.\n");
            fprintf(stdout,"INFO:                                   (In default case, non-peak channels interpolate towards file2 values).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: INTERP PEAK FREQUENCIES ONLY .. Peak channel amplitudes are determined by 1st sound peak amplitudes only.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(SPECMORPH2):
        fprintf(stdout,"INFO: EXTRACT OR MORPH SPECTRAL PEAKS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Spectral peaks are made to glide to new values.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mode 1:  Extract average frequencies of the peaks  (in order of decreasing prominence).\n");
        fprintf(stdout,"INFO: Mode 2: Uses peak-frequencies specified in textfile (in order of decreasing prominence) to gradually tune the spectrum.\n");
        fprintf(stdout,"INFO: Mode 3: Ditto, using cosinusoidal morph.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF PEAKS TO LOOK FOR ..... Number of peaks to look for.\n");
        fprintf(stdout,"INFO: INTERPOLATION START ........ Start time of the morph.\n");
        fprintf(stdout,"INFO: INTERPOLATION END ........... End time of the morph.\n");
        fprintf(stdout,"INFO: INTERPOLATION EXPONENT ... Determines the shape of the interpolation.\n");
        fprintf(stdout,"INFO:                      In modes 1 and 3\n");
        fprintf(stdout,"INFO:                                   exponent 1 gives a linear interpolation.\n");
        fprintf(stdout,"INFO:                                   exponent more than 1 interpolates slower at the start and faster at the end.\n");
        fprintf(stdout,"INFO:                                   exponent less than 1 interpolates faster at the start and slower at the end.\n");
        fprintf(stdout,"INFO:                      In modes 2 and 4\n");
        fprintf(stdout,"INFO:                                   exponent 1 gives a cosinusiodal interpolation.\n");
        fprintf(stdout,"INFO:                                   exponent more than 1 forces the cosinusiodal transition towards the midpoint-time.\n");
        fprintf(stdout,"INFO:                                   exponent less than 1 speeds up the initial and final interpolation-rate.\n");
        fprintf(stdout,"INFO:                                   exponent .85 approaches the linear case.\n");
        fprintf(stdout,"INFO:                                   Below .85 the interpolation lingers longer around its half-way point.\n");
        fprintf(stdout,"INFO: RANDOMISATION OF GOAL PEAK FRQ ... Randomisation of goal peak-frequencies (can vary over time).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(NEWDELAY):
        fprintf(stdout,"INFO: DELAY WITH FEEDBACK, GENERATING PITCHED OUTPUT.\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: Pitch a sound using delay with feedback.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI PITCH .................. MIDI pitch generated by delayed feedback\n");
            fprintf(stdout,"INFO: DELAYED SIGNAL IN MIX .. Level of delayed signal in the output\n");
            fprintf(stdout,"INFO: FEEDBACK................... Feedback level (Feedback generates pitch effect)\n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: Pitch the start portion (HEAD) of a sound using delay with feedback.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI PITCH ....................................................... MIDI pitch to be generated.\n");
            fprintf(stdout,"INFO: HEAD DURATION ................................................ Duration of Head portion of sound.\n");
            fprintf(stdout,"INFO: FACTOR BY WHICH HEAD DURATION EXTENDED .......... Repeats of Head cause the resulting pitched-head to be longer than original by this factor.\n");
            fprintf(stdout,"INFO: DELAY RANDOMISATION ....................................... More randomisation of delay causes pitch to be more gritty or unclear.\n");
            fprintf(stdout,"INFO: MAX OF LEVEL DIP IN EXTENDED HEAD (A FACTOR) ....... Extended Head can dip in level in its middle. Factor 1 = no dip, factor 3 = dip to 1/3 level.\n");
            fprintf(stdout,"INFO: POSITION OF MAX DIP AS FRACTION OF HEAD LENGTH .. Any dip in level reaches its lowest point at this fraction of the extended head's duration.\n");
            fprintf(stdout,"INFO: \n");
            break;
        }
        break;
    case(FILTRAGE):
        fprintf(stdout,"INFO: GENERATE RANDOM FILTER-SETTINGS FOR VARIBANK FILTER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mode 1: Make fixed-values filter.\n");
        fprintf(stdout,"INFO: Mode 2: Make time-varying filter.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION ...................... Duration of filter.\n");
        fprintf(stdout,"INFO: NUMBER OF FILTERS .......... Number of separate pitch-streams defined in output filter data.\n");
        fprintf(stdout,"INFO: MIN MIDIPITCH OF FILTERS .. Minimum MIDI pitch in any specified pitchstream.\n");
        fprintf(stdout,"INFO: MAX MIDIPITCH OF FILTERS .. Maximum MIDI pitch in any specified pitchstream\n");
        fprintf(stdout,"INFO: PITCH DISTRIBUTION ........ 1 gives linear pitch-distribution,\n");
        fprintf(stdout,"INFO:                                           greater than 1 squeezes pitches towards lower values.\n");
        fprintf(stdout,"INFO:                                           less than 1 squeezes pitches towards higher values.\n");
        fprintf(stdout,"INFO: PITCH RANDOMISATION ......... Randomisation of pitches. 1 gives maximum randomisation.\n");
        fprintf(stdout,"INFO: MINIMUM FILTER AMPLITUDE ... Filters will vary in amplitude between thhis MINIMUM, and the max value of 1.0\n");
        fprintf(stdout,"INFO: AMPLITUDE RANDOMISATION .. Randomisation of amplitudes.\n");
        fprintf(stdout,"INFO: AMPLITUDE DISTRIBUTION ...... 0 gives random amplitudes.\n");
        fprintf(stdout,"INFO:                                           1 gives increasing amplitude with pitch.\n");
        fprintf(stdout,"INFO:                                           -1 gives decreasing amplitude with pitch.\n");
        fprintf(stdout,"INFO:                                           Intermediate values give increasing degrees of randomisation, as zero is approached.\n");
        if(mode == 1) {
            fprintf(stdout,"INFO: TIMESTEP BETWEEN FILTER SETS .. (Average) timestep between each pitch-set specification, for time-changing filters,\n");
            fprintf(stdout,"INFO: RANDOMISATION OF TIMESTEP ........ Randomisation of timesteps.\n");
        }
        fprintf(stdout,"INFO: RANDOM SEED .................... If seed value is NOT zero, random values used in process will be reproduced on next pass with SAME parameters.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ITERLINE):
    case(ITERLINEF):
        if(process == ITERLINE)
            fprintf(stdout,"INFO: EXTEND SOURCE BY ITERATION, FOLLOWING A DEFINED TRANSPOSITION LINE.\n");
        else {
            fprintf(stdout,"INFO: EXTEND BY ITERATION A SET OF SOUNDS WHICH ARE TRANSPOSITIONS OF A SOURCE, FOLLOWING A DEFINED TRANSPOSITION LINE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The aim here is to effect a line which changes in pitch without altering the formant character of a source.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: There must be 25 input files, being semitone transpositions of an original source.\n");
            fprintf(stdout,"INFO: The first 12 sounds are transpositions downward by 12 semitones, 11 semitones, 10 semitones etc\n");
            fprintf(stdout,"INFO: File 13 is the original, untransposed source.\n");
            fprintf(stdout,"INFO: Files 14-25 are transpositions upwards by 1 semitone, 2 semitones, 3 semitones etc\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: The transpositions should be duration and formant preserving.\n");
            fprintf(stdout,"INFO: \n");
        }
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mode 1: Interpolate timewise between transposition values.\n");
        fprintf(stdout,"INFO: Mode 2: Step between transposition values.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TRANSPOSITION DATA.....Textfile of pairs of time/transposition values. Times must start at 0, and increase.\n");
        fprintf(stdout,"INFO:                                       Transposition valueds are in (possibly fractional) semitones, in range +- 24 (2 octaves up or down)\n");
        fprintf(stdout,"INFO: DELAY..................(average) delay between iterations.\n");
        fprintf(stdout,"INFO: PITCH SCATTER..........max of randomisation of pitchshift of each iteration: (possibly fractional) semitones.\n");
        fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
        fprintf(stdout,"INFO: OVERALL GAIN...........(special) value 0, gives best guess for no distortion.\n");
        fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECRAND):
        fprintf(stdout,"INFO: TIME-RANDOMISE SPECTRAL DATA.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOMISATION TIMESCALE .......... Timescale over which spectral data are randomised.\n");
        fprintf(stdout,"INFO: WINDOW GROUPING .................. Spectral windows are grouped into sets of time-adjacent windows, and these sets are time-randomised,\n");
        fprintf(stdout,"INFO:                                          This parameter determines the number of windows in each set.\n");
        fprintf(stdout,"INFO:                                          The duration of the window-group cannot exceed (half of) the Randomisation Timescale.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECSQZ):
        fprintf(stdout,"INFO: SQUEEZE THE FREQUENCY-SECTRUM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CENTRE FREQUENCY ............. Frequency around which other values are squeezed.\n");
        fprintf(stdout,"INFO: SQUEEZE FACTOR ............... Contraction of the frequency data range (less than 1).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(HOVER2):
        fprintf(stdout,"INFO: ZIGZAG READ A SOURCE AT A GIVEN FREQUENCY.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: At any specified location, process searches for nearby zero-crossing,\n");
        fprintf(stdout,"INFO: then reads forwards from the zero, then back to the zero, producing a wave half-cycle,\n");
        fprintf(stdout,"INFO: then writes the inversion of those samples, producing symmetrical 2nd-half of wave-cycle.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RATE OF HOVER (Hz) .... slow rate: reads lots of samples forwards, backwards, forwards.\n");
        fprintf(stdout,"INFO:                         fast rate: reads fewer samples forwards, backwards, forwards.\n");
        fprintf(stdout,"INFO: LOCATION OF HOVERING .. Time in input sound where samples are read.\n");
        fprintf(stdout,"INFO: RANDOMISATION OF RATE (0-1)\n");
        fprintf(stdout,"INFO: RANDOMISATION OF LOCATION (0-1)\n");
        fprintf(stdout,"INFO: OUTPUT DURATION ....... Total Duration of output file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ADVANCE LOCATIONS STEPWISE ..... If a brkpoint table is used for LOCATION\n");
        fprintf(stdout,"INFO:                         then the location read at any time-value remains the read-location\n");
        fprintf(stdout,"INFO:                         until a new time-value in the file is reached.\n");
        fprintf(stdout,"INFO:                         (The default read mode is to INTERPOLATE between locations specified at the time-values in the file).\n");
        fprintf(stdout,"INFO: NORMALISE OUTPUT ..... Normalise the level of all wavecycles generated.\n");
        break;
    case(SELFSIM):
        fprintf(stdout,"INFO: MAKE SPECTRUM MORE SELF-SIMILAR.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SELF SIMILARITY INDEX ............. Number of similar windows to replace.\n");
        fprintf(stdout,"INFO:                         Value 1 uses loudest window to replace the most similar window.\n");
        fprintf(stdout,"INFO:                         then the next loudest window to replace window most similar to it\n");
        fprintf(stdout,"INFO:                         and so on, with appropriate overall-loudness scaling.\n");
        fprintf(stdout,"INFO:                         With value 2, loudest windows replaces the TWO windows most similar to it.\n");
        fprintf(stdout,"INFO:                         and so on.\n");
        fprintf(stdout,"INFO:                         If two windows are to be replaced by A, and A first replaces B,\n");
        fprintf(stdout,"INFO:                         and D is more similar to B, than C is to A, then A replaces D rather than C.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ITERFOF):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: GENERATE PITCHED LINE FROM SMALL SOUND PACKET OR FOF.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Treat source as a wavelength sized FOF, and use transposition data, to guide pitch of output line.\n");
            fprintf(stdout,"INFO: With any transposition breakpoint file, interpolate between values, so pitch glides from one value to next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEMITONE TRANSPOSITION OF LINE Assumes duration of input = wavelength of the fundamental pitch to be transposed.\n");
            fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
            fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
            fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
            fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
            fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
            fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
            fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
            fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
            fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
            fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
            fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
            fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: GENERATE STEPPED PITCHED LINE FROM SMALL SOUND PACKET OR FOF.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Treat source as a wavelength sized FOF, and use transposition data, to set pitches of output line.\n");
            fprintf(stdout,"INFO: With any transposition breakpoint file, STEP between values, so that pitch steps from one timed-event to next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEMITONE TRANSPOSITION OF LINE Assumes duration of input = wavelength of the fundamental pitch to be transposed.\n");
            fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
            fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
            fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
            fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
            fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
            fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
            fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
            fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
            fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
            fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
            fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
            fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS FOR ANY DISTINCT PITCHES ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIN LEVEL NOTES ..................... Minimum note loudness.\n");
            fprintf(stdout,"INFO: MAX LEVEL NOTES ..................... Maximum note loudness. Notes vary in loudness between min and max\n");
            fprintf(stdout,"INFO: NOTE INFADE DURATION ............ Duration of any fade-in of notes.\n");
            fprintf(stdout,"INFO: NOTE OUTFADE DURATION ......... Duration of any fade-out of notes.\n");
            fprintf(stdout,"INFO: GAP BETWEEN NOTES ................. Relative length of any gap between notes, as proportion of note duration.\n");
            fprintf(stdout,"INFO: PORTAMENTO TYPE ................... 0 = none  :  1 = rising  :  -1 = falling  :  2 = randomly rising or falling.\n");
            fprintf(stdout,"INFO: PORTAMENTO INTERVAL ............. Interval rise(fall) of any portamento, in semitones, attained only by the start-time of next note.\n");
            fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: GENERATE PITCHED LINE FROM INPUT SOUND.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI-pitch data determines pitch of output line.\n");
            fprintf(stdout,"INFO: With any pitch breakpoint file, interpolate between timed values, so that pitch glides from one timed-event to next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI-PITCH OF LINE ...................\n");
            fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
            fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
            fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
            fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
            fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
            fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
            fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
            fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
            fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
            fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
            fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
            fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
            break;
        case(3):
            fprintf(stdout,"INFO: GENERATE STEP-PITCHED LINE FROM INPUT SOUND.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI-pitch data determines pitches of output line.\n");
            fprintf(stdout,"INFO: With any pitch breakpoint file, step between timed values, so pitch steps from one timed-event to next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIDI-PITCHES OF LINE ...............\n");
            fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
            fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
            fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
            fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
            fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
            fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
            fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
            fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
            fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
            fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
            fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
            fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS FOR ANY DISTINCT PITCHES (Modes 2 and 4) ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MIN LEVEL NOTES ..................... Minimum note loudness.\n");
            fprintf(stdout,"INFO: MAX LEVEL NOTES ..................... Maximum note loudness. Notes vary in loudness between min and max\n");
            fprintf(stdout,"INFO: NOTE INFADE DURATION ............ Duration of any fade-in of notes.\n");
            fprintf(stdout,"INFO: NOTE OUTFADE DURATION ......... Duration of any fade-out of notes.\n");
            fprintf(stdout,"INFO: GAP BETWEEN NOTES ................. Relative length of any gap between notes, as proportion of note duration.\n");
            fprintf(stdout,"INFO: PORTAMENTO TYPE ................... 0 = none  :  1 = rising  :  -1 = falling  :  2 = randomly rising or falling.\n");
            fprintf(stdout,"INFO: PORTAMENTO INTERVAL ............. Interval rise(fall) of any portamento, in semitones, attained only by the start-time of next note.\n");
            fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
            break;
        }
        break;
    case(PULSER):
    case(PULSER2):
    case(PULSER3):
        switch(mode) {
        case(0):
            switch(process) {
            case(PULSER):
                fprintf(stdout,"INFO: CREATE A STREAM OF PITCHED PACKETS FROM A MONO SOURCE.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: (NB: Only the spectral brightness of the source is reflected in the output sound.)\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                break;
            case(PULSER2):
                fprintf(stdout,"INFO: CREATE A STREAM OF PITCHED PACKETS FROM MONO SOURCES.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: (NB: Only the spectral brightness of the sources is reflected in the output sound.)\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                break;
            case(PULSER3):
                fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS FROM PARTIAL-NUMBER DATA.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile list of paired items: Each pair is a partial number and a level.\n");
                fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
                break;
            }
            fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
            fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
            break;
        case(1):
            switch(process) {
            case(PULSER):
                fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM A MONO SOURCE, USING THE START OF THE SOURCE ONLY.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                break;
            case(PULSER2):
                fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM MONO SOURCES, USING THE START OF THE SOURCES ONLY.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                break;
            case(PULSER3):
                fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS WHOSE SPECTRA CHANGE WITH TIME.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile is of list of lines of format \"Time  partialno level [partialno2 level2 ......]\"\n");
                fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
                fprintf(stdout,"INFO:                                                                                  Timers must start at zero, and increase.\n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
                break;
            }
            break;
        case(2):
            switch(process) {
            case(PULSER):
                fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM A MONO SOURCE, SELECTING RANDOM CHUNKS FROM INSIDE THE SOURCE.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                fprintf(stdout,"INFO: LSPKR SELECTION ...................... ZERO   ~~OR~~   SPATIALISATION DATA FOR AN 8-CHANNEL OUPUT.\n");
                fprintf(stdout,"INFO:                                                                                  With ZERO, Sound Output is MONO or (if WIDTH > 0) STEREO.\n");
                fprintf(stdout,"INFO:                                                                                  SPATIALISATION DATA is either ......\n");
                fprintf(stdout,"INFO:                                                                                              (1) a string of channel numbers indicating which of 8 ouput channels to use.\n");
                fprintf(stdout,"INFO:                                                                                              (2) A textfile with a time and a spacedata-string on each line, times increasing from one line to next.\n");
                fprintf(stdout,"INFO:                                                                                                      The number of channels used (as well as the channel selection) may change with time.\n");
                break;
            case(PULSER2):
                fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM MONO SOURCES, SELECTING RANDOM CHUNKS FROM INSIDE THE SOURCES.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                fprintf(stdout,"INFO: LSPKR SELECTION ...................... ZERO   ~~OR~~   SPATIALISATION DATA FOR AN 8-CHANNEL OUPUT.\n");
                fprintf(stdout,"INFO:                                                                                  With ZERO, Sound Output is MONO or (if WIDTH > 0) STEREO.\n");
                fprintf(stdout,"INFO:                                                                                  SPATIALISATION DATA is either ......\n");
                fprintf(stdout,"INFO:                                                                                              (1) a string of channel numbers indicating which of 8 ouput channels to use.\n");
                fprintf(stdout,"INFO:                                                                                              (2) A textfile with a time and a spacedata-string on each line, times increasing from one line to next.\n");
                fprintf(stdout,"INFO:                                                                                                      The number of channels used (as well as the channel selection) may change with time.\n");
                break;
            case(PULSER3):
                fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS WHOSE SPECTRA CHANGE AT RANDOM.\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
                fprintf(stdout,"INFO: \n");
                fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile is of list of lines of format \"Time  partialno level [partialno2 level2 ......]\"\n");
                fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
                fprintf(stdout,"INFO:                                                                                  Timers must start at zero, and increase.\n");
                fprintf(stdout,"INFO:                                                                                  Lines are read in RANDOM order (TIMES ARE IGNORED).\n");
                fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
                fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
                break;
            }
            break;
        }
        fprintf(stdout,"INFO: RISE-TIME MINIMUM/MAXIMUM ......... Minimum and maximum duration of risetime of packets.\n");
        fprintf(stdout,"INFO: SUSTAIN-TIME MINIMUM/MAXIMUM .. Minimum and maximum duration of sustain time of packets.\n");
        fprintf(stdout,"INFO: DECAY-TIME MINIMUM/MAXIMUM ...... Minimum and maximum duration of decaytime of packets.\n");
        fprintf(stdout,"INFO:                                                                                  Actual rise, sustain and decay times are set at random, between the limits given.\n");
        fprintf(stdout,"INFO: TIME STEP BETWEEN PACKETS .......... Timestep between packets in output stream.\n");
        fprintf(stdout,"INFO: PACKET TIME RANDOMISATION ........ Randomisation of timestep between packets.\n");
        fprintf(stdout,"INFO: SLOPE OF ATTACK,SLOPE OF DECAY .. 1 is linear : greater than 1 is steep : less than 1 is less steep.\n");
        fprintf(stdout,"INFO: PITCH SCATTER (SEMITONES) .......... Random scattering of packet pitches.\n");
        fprintf(stdout,"INFO: AMPLITUDE SCATTER ..................... Random scattering of packet amplitudes.\n");
        fprintf(stdout,"INFO: OCTAVIATION ............................. Redundant parameter : no longer in use.\n");
        fprintf(stdout,"INFO: PACKET PITCH BEND ...................... Bending of pitches of packets.\n");
        fprintf(stdout,"INFO: RANDOM SEED ............................. Setting a particular seed value will produce similar output when same seed applied again.\n");
        if(process != PULSER3 && mode == 2) {
            fprintf(stdout,"INFO: SPATIAL WIDTH ............................. With LSPKR SELECTION SET TO ZERO, Width is spatial spread of placement of output segments in stereo panorama.\n");
            fprintf(stdout,"INFO:                                                                                  A width of ZERO produces a MONO output.\n");
            fprintf(stdout,"INFO:                                                                                  With LSPKR SELECTION NOT ZERO Width is spatial spread around the selected output loudspeakers.\n");
            fprintf(stdout,"INFO:                                                                                  A width of ZERO produces a loudspeaker-centric output.\n");
        }
        if(process == PULSER2) {
            fprintf(stdout,"INFO: TOTALLY RANDOM SRC SEQUENCE .... Source sound to produce next packet is chosen totally at random.\n");
            fprintf(stdout,"INFO:                                                                                  Default:  all srcs are used once, in a random order, before proceeding to the next random ordering.\n");
        } else if(process == PULSER3) {
            fprintf(stdout,"INFO: SAMPLING RATE ............................ Sampling rate of sythesized output.\n");
            fprintf(stdout,"INFO: PARTIAL COUNT ............................ Number of partials actually activated (time-variable).\n");
            fprintf(stdout,"INFO:                                                                                  Fractional values can be used: e.g. 2.4 means use 1st and 2nd partials, and 3rd partial attenuated by 0.4.\n");
        }
        fprintf(stdout,"INFO: \n");
        if(process == PULSER && mode == 2)
            fprintf(stdout,"INFO: All parameters except DURATION, RISE/DECAY limits, and SEED can vary through time.\n");
        else if(process == PULSER3)
            fprintf(stdout,"INFO: All parameters except DURATION, RISE/SUSTAIN/DECAY limits, SEED and SAMPLE RATE can vary through time.\n");
        else
            fprintf(stdout,"INFO: All parameters except DURATION, RISE/SUSTAIN/DECAY limits, and SEED can vary through time.\n");
        break;
    case(CHIRIKOV):
        fprintf(stdout,"INFO: GENERATE SOUND OR PITCHLINE BASED ON CHIRIKOV STANDARD MAP, OR CIRCULAR MAP.\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):    fprintf(stdout,"INFO: GENERATE SOUND BASED ON ITERATION OF CHIRIKOV STANDARD MAP.\n");      break;
        case(1):    fprintf(stdout,"INFO: GENERATE PITCH LINE BASED ON ITERATION OF CHIRIKOV STANDARD MAP.\n"); break;
        case(2):    fprintf(stdout,"INFO: GENERATE SOUND BASED ON ITERATION OF CIRCULAR MAP.\n");               break;
        case(3):    fprintf(stdout,"INFO: GENERATE PITCH LINE BASED ON ITERATION OF CIRCULAR MAP.\n");          break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):    
        case(1):    fprintf(stdout,"INFO: DURATION .................... Duration of the output sound.\n");  break;
        case(2):
        case(3):    fprintf(stdout,"INFO: DURATION .................... Duration of the output breakpoint file.\n");    break;
        }
        fprintf(stdout,"INFO: FREQUENCY ................... Frequency of the forcing oscillation (can vary through time).\n");
        fprintf(stdout,"INFO: DAMPING ..................... Damping coeeficient (can vary through time).\n");
        switch(mode) {
        case(0):    
        case(1):    
            fprintf(stdout,"INFO: SAMPLE RATE .......... Sampling rate of the synthesized sound.\n");   
            fprintf(stdout,"INFO: SPLICE LENGTH (mS) ... Splice length (in milliseconds) of the onset and end of the output sound.\n"); 
            break;
        case(2):    
        case(3):    
            fprintf(stdout,"INFO: MINIMUM_MIDI PITCH .. Bottom of MIDI pitch range of output data.\n"); 
            fprintf(stdout,"INFO: MAXIMUM_MIDI PITCH .. Top of MIDI pitch range of output data.\n");    
            fprintf(stdout,"INFO: TIME STEP ....................... Time step between entries in output brkpoint file.\n"); 
            fprintf(stdout,"INFO: TIME RANDOMISATION .. Randomisation of times in output brkpoint file.\n");    
            break;
        }
        break;
    case(MULTIOSC):
        fprintf(stdout,"INFO: GENERATE INTERACTING OSCILLATORS.\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):    fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION.\n");                               break;
        case(1):    fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION OF OSCILLATION.\n");                break;
        case(2):    fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION OF OSCILLATION OF OSCILLATION.\n"); break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION .................... Duration of the output sound.\n");
        fprintf(stdout,"INFO: FREQUENCY ................... Oscillator frequency.\n");
        fprintf(stdout,"INFO: FREQUENCY TWO................ Frequency of oscillation of oscillation.\n");
        fprintf(stdout,"INFO: AMPLITUDE TWO................ Amplitude of oscillation of oscillation.\n");
        if(mode >= 1) {
            fprintf(stdout,"INFO: FREQUENCY THREE................ Frequency of oscillation of oscillation of oscillation.\n");
            fprintf(stdout,"INFO: AMPLITUDE THREE................ Amplitude of oscillation of oscillation of oscillation.\n");
        }
        if(mode == 2) {
            fprintf(stdout,"INFO: FREQUENCY FOUR................ Frequency of oscillation of oscillation of oscillation of oscillation.\n");
            fprintf(stdout,"INFO: AMPLITUDE FOUR................ Amplitude of oscillation of oscillation of oscillation of oscillation.\n");
        }
        fprintf(stdout,"INFO: SAMPLE RATE .......... Sampling rate of the synthesized sound.\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (mS) ... Splice length (in milliseconds) of the onset and end of the output sound.\n");
        break;
    case(SYNFILT):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: GENERATE BAND OF FILTERED NOISE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMELIST OF PITCHES OF FILTS .... a textfile of lines with time-pitch pairs on each line. \n");
            fprintf(stdout,"INFO: \n");
            break;
        case(1):
            fprintf(stdout,"INFO: GENERATE BAND OF MULTIPITCHED FILTERED NOISE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TIMELIST OF PICHS&AMPS OF FILTS .... a textfile with lines of data for filter bands at successive times.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Each line contains the following items\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:           Time   Pitch1 Amp1   [Pitch2 Amp2    etc....].\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Where pitch and Amp values must be paired: and any number of pairs can be used in a line,\n");
            fprintf(stdout,"INFO: BUT each line must have SAME number of pairs on it.\n");
            fprintf(stdout,"INFO: Amp values may be numeric, or dB values (e.g. -4.1dB).\n");
            fprintf(stdout,"INFO: (To eliminate a band in any line(s), set its amplitude to 0.0).\n");
            break;
        }
        fprintf(stdout,"INFO: Time values (in secs) must be in ascending order (and >=0.0), with the maximum time being greater than 0.03 seconds.\n");
        fprintf(stdout,"INFO: Pitch vals are MIDI values (but may be fractional).\n");
        fprintf(stdout,"INFO: (Comment-lines may be used: start these with ';').\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OTHER PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SAMPLE RATE ............. Sample rate of output sound.\n");
        fprintf(stdout,"INFO: CHANNEL COUNT ......... Mono or stereo output.\n");
        fprintf(stdout,"INFO: FILTER Q .................. Q (tightness) of filter.\n");
        fprintf(stdout,"INFO: NUMBER OF HARMONICS.. No of harmonics (of each pitch) to use: Default 1.\n");
        fprintf(stdout,"INFO:                                                Very high harmonics of high pitches may be too high to calculate. (check with Max Harmonic button)\n");
        fprintf(stdout,"INFO:                                                No-of-pitches times no-of-harmonics determines program speed.\n");
        fprintf(stdout,"INFO: ROLL OFF................. Level drop (in dB) from one harmonic to next.\n");
        fprintf(stdout,"INFO: RANDOM SEED .......... Any set value gives reproducible output.\n");
        fprintf(stdout,"INFO: DOUBLE FILTERING .... More sharply defined filter frequencies.\n");
        fprintf(stdout,"INFO: DROP OUT ON OVERFLOW   The filter is designed to adjust its internal level to prevent numerical overflow from\n");
        fprintf(stdout,"INFO:                                                setting this flag will cause the filter to stop calculating if any overflow is detected.\n");
        fprintf(stdout,"INFO:                                                The filter gain can then be turned down, and the filter launched again.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB: USING VERY LARGE NUMBERS OF HARMONICS MAY PRODUCE NUMERICAL INSTABILITY (OUTPUT WILL FAIL)\n");
        fprintf(stdout,"INFO: NB: USING RAPID PITCH SHIFTS AT THE SOUND'S END (ESPECIALLY WITH LOW PITCH & FEW HARMONICS) MAY GIVE TAIL ARTEFACTS.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(STRANDS):
        switch(mode) {
        case(0):
        case(2):
            fprintf(stdout,"INFO: GENERATE PITCHBAND DATA EXHIBITING  LAMINAR,  TAYLOR_COUETTE, AND  TURBULENT  FLOW.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: GENERATE PITCHBANDED SOUND EXHIBITING  LAMINAR,  TAYLOR_COUETTE, AND  TURBULENT  FLOW.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Generates pitch threads distributed over a specified range, which can \"flow\" in the following ways ....\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:         (a)  LAMINAR FLOW (threads do not cross).\n");
        fprintf(stdout,"INFO:         (b)  TWISTED FLOW (threads are grouped in pitch-adjacent bands, and the threads in each band cycle around one another).\n");
        fprintf(stdout,"INFO:         (c)  TWISTED FLOW WITH WAVY BOUNDARIES.\n");
        fprintf(stdout,"INFO:         (d)  BANDED FLOW WITH TURBULENCE (threads cross indiscriminately within the bands).\n");
        fprintf(stdout,"INFO:         (e)  TURBULENT FLOW (threads cross indiscriminately across the entire range).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Transitions to (and from) twisting, and to (and from) turbulence are managed by the process, and timed by the input parameters supplied.\n");
        fprintf(stdout,"INFO: \n");
        if(mode==0) {
            fprintf(stdout,"INFO: Data is output as a set of time-pitch breakkpoint files which define the pitch-evolution of each stream.\n");
            fprintf(stdout,"INFO: (Level data may also be output: see the \"3D\" option below).\n");
            fprintf(stdout,"INFO: \n");
        }
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        if(mode==2)
            fprintf(stdout,"INFO: THREADCOUNT IN EACH BAND ........... Number of pitch-threads in each band, listed in a textfile.\n");
        switch(mode) {
        case(0):
        fprintf(stdout,"INFO: DURATION .................................. Duration of the output data.\n");
        break;
        case(1):
        fprintf(stdout,"INFO: DURATION .................................. Duration of the output sound.\n");
        break;
        }
        fprintf(stdout,"INFO: NUMBER OF BANDS ........................ Number of pitch-bands in the output.\n");
        if(mode != 2)
            fprintf(stdout,"INFO: NUMBER OF THREADS PER BAND ........ Number of pitch-threads in each band.\n");
        fprintf(stdout,"INFO: TIMESTEP BETWEEN OUTPUT VALUES .. Timestep (in mS) between the pitch-data values in the output.\n");
        fprintf(stdout,"INFO: BOTTOM OF PITCH RANGE ................ Lowest pitch of all output.\n");
        fprintf(stdout,"INFO: TOP OF PITCH RANGE ..................... Highest pitch of all output.\n");
        fprintf(stdout,"INFO: FREQUENCY OF BAND ROTATION ....... Rate (in Hz) at which the pitches twist aroud one another within the bands.\n");
        fprintf(stdout,"INFO:                                     (1)  If two successive times in the input data have ZERO frequency,\n");
        fprintf(stdout,"INFO:                                               the flow between those times is LAMINAR.\n");
        fprintf(stdout,"INFO:                                     (2)  If two successive times have NON-ZERO freqency,\n");
        fprintf(stdout,"INFO:                                               the flow between those times is TWISTED.\n");
        fprintf(stdout,"INFO:                                     (3)  If two successive times have zero and non-zero freqencies,\n");
        fprintf(stdout,"INFO:                                               the flow gradually changes between laminar and twisted.\n");
        fprintf(stdout,"INFO: RANDOM DIVERSITY OF BAND FREQUENCIES\n");
        fprintf(stdout,"INFO:                                     (1) With LAMINAR FLOW : Amount of random divergence of thread pitches from steady pitch.\n");
        fprintf(stdout,"INFO:                                     (2) With TWISTED FLOW : Amount of random divergence of twist of individual bands\n");
        fprintf(stdout,"INFO:                                               from the specified twist frequency.\n");
        fprintf(stdout,"INFO: RANDOM WARPING OF THREAD OSCILLATIONS\n");     
        fprintf(stdout,"INFO:                                     (1) With LAMINAR FLOW : If the flow is 3D (see below),\n");
        fprintf(stdout,"INFO:                                               amount of scattering of the loudness random of each stream.\n");
        fprintf(stdout,"INFO:                                               (If the flow is NOT 3D, this parameter is ignored during laminar flow).\n");
        fprintf(stdout,"INFO:                                     (2) With TWISTED FLOW : Random timewarp (acceleration or decelleration)\n");
        fprintf(stdout,"INFO:                                               of the twisting of individual threads in the same band.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: BAND BOUNDARY WAVINESS ............ Amount that the band-boundaries wander away from fixed pitches.\n" );
        fprintf(stdout,"INFO: WAVINESS MIN FREQUENCY ............. Minimum rate of oscillation of the band boundaries.\n");
        fprintf(stdout,"INFO: WAVINESS MAX FREQUENCY ............ Maximum rate of oscillation of the band boundaries.\n");
        fprintf(stdout,"INFO:                                     Actual oscillation rates are selected at random (for each band boundary) between these limits.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TURBULENCE ............................... Turbulence destroys the laminar or twisting pattern of the threads.\n");
        fprintf(stdout,"INFO:                                     Value ZERO creates no turbulence.\n"); 
        fprintf(stdout,"INFO:                                     Values UP TO 1.0 create increasingly turbulent paths WITHIN the  band boundaries.\n");
        fprintf(stdout,"INFO:                                     Values BETWEEN 1.0 and 2.0 create increasingly turbulent paths over the entire pitch-range.\n");
        fprintf(stdout,"INFO:                                     Note that turbulence can ONLY be non-zero when the flow is (fully) twisted.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SEED ..................................... Seed for random generators in process. Set same side on 2 runs to get identical randomisation.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MINIMUM PITCH INTERVAL BETWEEN BANDS Minimum pitch-interval separating the pitch-bands.\n");
        fprintf(stdout,"INFO: MINIMUM PITCH WIDTH OF BANDS ...... Minimum width of bands (especially when subjected to wavyiness).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ROTATION IN 3D ........................... 2 more tranches of values are created to control 3d asepcts of the flow.\n");
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO:                                     The 1st tranche can be used to generate relative level values for the streams,\n");
            fprintf(stdout,"INFO:                                     or to control the number of partials in the stream with changes in pitch.\n");
            fprintf(stdout,"INFO:                                     The 2nd tranche can be used to control the level of a modified version of the source\n");
            fprintf(stdout,"INFO:                                     (e.g. reverbd or filtered), in a mix with the unmodified source.\n");
            fprintf(stdout,"INFO:                                     BOTH processes might indicate the instantaneous distance of each stream from the listener.\n");
            fprintf(stdout,"INFO:                                     This data output as 2 FURTHER sets of textfiles, AFTER all pitch data files have been output.\n");
            break;
        case(1):
            fprintf(stdout,"INFO:                                     This data is used to modify the relative level of the streams in the output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT BANDS SEQUENTIALLY ......... Outputs each band separately, in sequence, rather than all superimposed.\n");
        fprintf(stdout,"INFO: \n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        break;
    case(REFOCUS):
        fprintf(stdout,"INFO: GENERATE ENVELOPES TO CHANGE THE FOCUS (LOUDNESS) BETWEEN CO-EXISTING SOUNDS (e.g. IN A SET OF SOUNDS TO BE MIXED).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  Randomly permute which band is currently in focus.\n");
        fprintf(stdout,"INFO: 2)  Bring bands into focus consecutively in 'rising' sequences, starting at the lowest, rising to the highest.\n");
        fprintf(stdout,"INFO: 3)  Bring bands into focus consecutively in 'falling' sequences, starting at the highest, falling to the lowest.\n");
        fprintf(stdout,"INFO: 4)  Bring bands into focus in a rising/falling/rising... cycle, starting at the lowest.\n");
        fprintf(stdout,"INFO: 5)  Bring bands into focus in a falling/rising/falling.. cycle, starting at the highest.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DURATION .................................. Duration of output envelope files.\n");
        fprintf(stdout,"INFO: NUMBER OF BANDS ........................ Number of sounds to envelope.\n");
        fprintf(stdout,"INFO: FOCUSING RATIO .......................... Ratio of loudness of in-focus sound to out of focus sounds.\n");
        fprintf(stdout,"INFO: TIMESTEP TO NEXT REFOCUS............. Time between refocusings.\n");
        fprintf(stdout,"INFO: TIMESTEP RANDOMISATION .............. Randomisation of this these times.\n");
        fprintf(stdout,"INFO: OFFSET BEFORE REFOCUSING BEGINS .. Refocusing does not start until after the \"offset\" time\n");
        fprintf(stdout,"INFO: TIME AT WHICH REFOCUSING ENDS ..... Refocusing ends at this time, unless it is set to zero.\n");
        fprintf(stdout,"INFO: NO FOCUS ON EXTREMAL BAND .......... The upper (1) or lower (-1) band gets no special focus.\n");
        fprintf(stdout,"INFO: RANDOM SEED .............................. Seend for random value generation: identical seed gives identical output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT IS A SET OF ENVELOPE TEXTFILES which can be used to modify the levels of the sounds in the set of sounds.\n");
        break;
    case(CHANPHASE):
        fprintf(stdout,"INFO: INVERT THE PHASE OF A SPECIFIED CHANNEL OF AN INPUT FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CHANNEL TO INVERT  .................................. Channel whose phase is to be inverted.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SILEND):
        fprintf(stdout,"INFO: PAD END OF SOUND WITH EXTRA SILENCE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1: ................. Duration of silence to add.\n");
        fprintf(stdout,"INFO: MODE 2: ................. Total Duration of new output sound (must be greater than duration of input sound).\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECULATE):
        fprintf(stdout,"INFO: SYSTEMATICALLY PERMUTE CHANNELS OF ANALYSIS FILE, PRODUCING MANY OUTPUT FILES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Analysis channels are permuted pairwise, in the manner of a \"Plain Bob\" bell-ringing sequence.\n");
        fprintf(stdout,"INFO: After each permutation, a new file is output.\n");
        fprintf(stdout,"INFO: The process conclude once the permutations have cycled the channels round to their original order\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MINIMUM FREQUENCY: ................. Frq of lowest analysis channel to permute.\n");
        fprintf(stdout,"INFO: MAXIMUM FREQUENCY: ................. Frq of highest analysis channel to permute.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MASK OTHER CHANNELS: .............. Zero any spectral information outside range of frequencies defined by Min and Max above.\n");
        break;
    case(SPECTUNE):
        fprintf(stdout,"INFO: FIND MOST PROMINENT PITCH IN INPUT FILE, THEN RETUNE THE FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: On retuning, the entire file is transposed by the same amount,\n");
        fprintf(stdout,"INFO: and such that the most prominent pitch moves to the tuning pitch.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1)  Tune to the nearest tempered pitch.\n");
        fprintf(stdout,"INFO: 2)  Tune to the nearest of the pitches listed in the \"tuning\" file.\n");
        fprintf(stdout,"INFO: 3)  Tune to the nearest pitch, or it's octave equivalents, listed in the \"tuning\" file.\n");
        fprintf(stdout,"INFO: 4)  Report the pitch found : no sound output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: VALID HARMONICS COUNT ................ how many of the loudest peaks in the spectral window\n");
        fprintf(stdout,"INFO: ...................................... must be harmonics to confirm that the window is pitched. (default %d)\n",ST_ACCEPTABLE_MATCH);
        fprintf(stdout,"INFO: MINIMUM MIDI PITCH ...................... MIDI value of the LOWEST acceptable pitch. (default 4)\n");
        fprintf(stdout,"INFO: MAXIMUM MIDI PITCH ...................... MIDI value of the HIGHEST acceptable pitch. (default 127)\n");
        fprintf(stdout,"INFO: START TIME FOR PITCH SEARCH .... Time in source at which pitch-search begins (default: 0.0).\n");
        fprintf(stdout,"INFO: END TIME FOR PITCH SEARCH ......... Time in source at which pitch-search ends (default: end-of-file)..\n");
        fprintf(stdout,"INFO: IN-TUNE RANGE (SEMIT) ................. semitone-range within which harmonics accepted as in tune (default %d)\n",ST_ACCEPTABLE_MATCH);
        fprintf(stdout,"INFO: MIN WINDOWS TO CONFIRM PITCH .. minimum number of adjacent windows that must be pitched\n");
        fprintf(stdout,"INFO: ............................... for pitch-value to be registered. (default %d)\n",BLIPLEN);
        fprintf(stdout,"INFO: SIGNAL TO NOISE RATIO (dB) ...... in decibels (default %.1lf)\n",SILENCE_RATIO);
        fprintf(stdout,"INFO: ................................. Windows whose level falls this far below the maximum window level in the sound\n");
        fprintf(stdout,"INFO: ................................. are assumed to be noise, & any detected pitch is assumed spurious.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: IGNORE PITCHED-WINDOW RELATIVE-LOUDNESS  ......\n");
        fprintf(stdout,"INFO:                               Assign window-pitches to 1/8thsemitone bins, and count occurences in bins.\n");
        fprintf(stdout,"INFO:                               Default, Weight the count with the window loudnesses.\n");
        fprintf(stdout,"INFO: SMOOTH PITCH-CONTOUR ..........................................\n");
        fprintf(stdout,"INFO:                               Smooth pitch-contour data before assessing most prominent pitch.\n");
        fprintf(stdout,"INFO:                               Default, no smoothing.\n");
        fprintf(stdout,"INFO: FORMANT ENVELOPE NOT PRESERVED (Modes 1 to 3 only)............ \n");
        fprintf(stdout,"INFO:                               If flag set, transposition ignores the original formant envelope.\n");
        fprintf(stdout,"INFO:                               Default, transposition preserves original formant envelope.\n");
        break;
    case(REPAIR):
        fprintf(stdout,"INFO: REASSEMBLE A SET OF MULTICHANNEL FILES FROM INDIVIDUAL MONO-CHANNEL SOURCES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT  ................ how many channels in the output sound (2, 4, 5, 7, 8, 16 only)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  The number of (mono) input files must be a multiple of the \"OUTPUT CHANNEL COUNT\"\n");
        fprintf(stdout,"INFO: (2)  All files destined to be channel-1s in the output should be listed first;\n");
        fprintf(stdout,"INFO:           All files destined to be channel-2s in the output should be listed next;\n");
        fprintf(stdout,"INFO:           and so on.\n");
        fprintf(stdout,"INFO: (3)  For any one output file, its mono file sources must all be the same length,\n");
        fprintf(stdout,"INFO:           (but output files need not be the same length).\n");
        break;
    case(DISTSHIFT):
        fprintf(stdout,"INFO: DISTORT BY TIME-SHIFTING (GROUPS OF) HALF-WAVESETS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: A half-waveset is defined as the samples between one zero-crossing and the next.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Alternate (groups of) half-wavesets are time-shifted with respect to their partners.\n");
        fprintf(stdout,"INFO: (2)  Alternate (groups of) half-wavesets are swapped.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WAVESET GROUP SIZE  ................ Number of wavesets in the waveset-groups which are operated on.\n");
        fprintf(stdout,"INFO:            1 corresponds to a single half-waveset\n");
        fprintf(stdout,"INFO:            2 corresponds to a complete waveset and a single half-waveset\n");
        fprintf(stdout,"INFO:            3 corresponds to 2 complete wavesets and a single half-waveset\n");
        fprintf(stdout,"INFO:            ETC.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WAVESET SHIFT (MODE 1 ONLY).... Number of waveset(group)s by which the signal is shifted.\n");
        break;
    case(QUIRK):
        fprintf(stdout,"INFO: DISTORT BY RAISING SAMPLE-VALUES TO A POWER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1: Rescales values differently within each half-waveset, scaling values within noramlised range of\n");
        fprintf(stdout,"INFO:              zero to max (for +ve half-waveset) or zero to min (for -ve half-waveset)\n");
        fprintf(stdout,"INFO:              and hence retianing the maximum (minimum) excursion of each half-waveset.\n");
        fprintf(stdout,"INFO: MODE 2: Rescales values within noramlised range of (absolute) maximum sample in file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: POWER FACTOR ................ Factor by which each sample is scaled.\n");
        fprintf(stdout,"INFO:            > 1 exaggerates waveform contour.\n");
        fprintf(stdout,"INFO:            < 1 smooths waveform contour.\n");
        break;
    case(ROTOR):
        fprintf(stdout,"INFO: GENERATING CYCLING PITCH-SPEED SETS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Generates sequence of pitch-sets : sets expand-contract in range, and accel-rit in speed.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Sound is generated from an input soundfile and an input envelope (text)file of time-value pairs.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The input soundfile is read as a wavecycle table.\n");
        fprintf(stdout,"INFO: and should start and end at zero level, and the start and end must both rise, or both fall.\n");
        fprintf(stdout,"INFO: Dovetailing (fading the start and end) can be used to trim the edges of the source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The envelope file is used to envelope the output events.\n");
        fprintf(stdout,"INFO: The duration of the envelope determines the duration of all the events.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: There are 3 ways to specifiy the time-gap between the pitch-sets.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1: Timestep from start of one set to start of next is determined by your input parameter.\n");
        fprintf(stdout,"INFO: MODE 2: Timestep from last event of first set, to first event of next\n");
        fprintf(stdout,"INFO:              is determined by the last timestep between the elements in the previous set.\n");
        fprintf(stdout,"INFO: MODE 3: First element of new set overlays the last element of the previous set.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: COUNT OF NOTES PER SET................................... Number of events in each set.\n");
        fprintf(stdout,"INFO: MIN MIDI PITCH/MAX MIDI PITCH...................... Minimum and Maximum (MIDI) pitch when set has maximal pitch-range.\n");
        fprintf(stdout,"INFO: MAX DURATION SLOWEST BEAT............................ Timestep between elements of sets when at slowest speed.\n");
        fprintf(stdout,"INFO: NUMBER OF SETS PER PITCH CYCLE .................. How many sets before the pitch-sequence returns to its original form.\n");
        fprintf(stdout,"INFO: NUMBER OF SETS PER SPEED CYCLE .................. How many sets before the sequence returns to its original speed.\n"); 
        fprintf(stdout,"INFO: INITIAL PHASE DIFFERENCE BETWEEN CYCLES . Range 0 (in phase) to 1, where -5 is antiphase.\n");
        fprintf(stdout,"INFO: (MININIMUM) OUTPUT DURATION ........................ (Minimum) duration of output to be generated.\n");
        fprintf(stdout,"INFO: DOVETAIL DURATION (mS) .................................. (Optional) dovetails for sommthing onset and tail of source sound.\n");
        fprintf(stdout,"INFO: TIME STEP BETWEEN WHOLE SETS (Mode 1 only). Timestep from start of one set to the next.\n");
        break;
    case(DISTCUT):
        fprintf(stdout,"INFO: CHOP SOUND INTO SEGMENTS, BY COUNTING WAVESETS, AND IMPOSE A DECAYING-ENVELOPE ON SEGMENTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: A waveset is defined as the samples between one zero-crossing and the next-but-one.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Envelope stretches from start of waveset-group to start of next waveset-group.\n");
        fprintf(stdout,"INFO:            Groups are therefore abutted and adjacent.\n");
        fprintf(stdout,"INFO: (2)  Envelope length (in wavesets) and step to start of next envelope group are independent.\n");
        fprintf(stdout,"INFO:            Groups may therefore overlap or be separated by intervening wavesets.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CYCLE COUNT ................. Number of wavesets in the waveset-groups which are enveloped.\n");
        fprintf(stdout,"INFO: CYCLE STEP ................... Number of wavesets from start of one group to start of next.\n");
        fprintf(stdout,"INFO:                                      In Mode 1, this is the same as the cycle_count.\n");
        fprintf(stdout,"INFO: DECAY EXPONENT ........... Defines the decay shape of the envelope.\n");
        fprintf(stdout,"INFO:         1 = Linear  :  >1  Decays more quickly initially  :  <1 Decays more sloly initially.\n");
        fprintf(stdout,"INFO: CUTOFF (dB) ................. Segments whose maximum level falls below MINUS this (dB) value, are not retained.\n");
        break;
    case(ENVCUT):
        fprintf(stdout,"INFO: CHOP SOUND INTO SEGMENTS, AND IMPOSE A DECAYING-ENVELOPE ON SEGMENTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Envelope stretches to time where next envelopes begins.\n");
        fprintf(stdout,"INFO:            Cut segments are therefore abutted and adjacent.\n");
        fprintf(stdout,"INFO: (2)  Envelope duration step to start of next enveloped segment are independent.\n");
        fprintf(stdout,"INFO:            Segments may therefore overlap or be separated from one another within the source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE DURATION ..... ....... .. Duration of segments which are enveloped.\n");
        fprintf(stdout,"INFO: TIMESTEP TO NEXT SEGMENT .. TImestep from start of one enveloped segment to start of next.\n");
        fprintf(stdout,"INFO:                                      In Mode 1, this is the same as the Envelope Duration.\n");
        fprintf(stdout,"INFO: ATTACK DURATION (mS) ........... Defines the rise-time of the envelope, in Milliseconds.\n");
        fprintf(stdout,"INFO: DECAY EXPONENT ........... Defines the decay shape of the envelope.\n");
        fprintf(stdout,"INFO:         1 = Linear  :  >1  Decays more quickly initially  :  <1 Decays more sloly initially.\n");
        fprintf(stdout,"INFO: CUTOFF (dB) ................. Segments whose maximum level falls below MINUS this (dB) value, are not retained.\n");
        break;
    case(SPECFOLD):
        fprintf(stdout,"INFO: PERMUTE SPECTRAL CHANNELS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Fold the spectrum.\n");
        fprintf(stdout,"INFO:         A group of consecutive channels to fold is selected.\n");
        fprintf(stdout,"INFO:         Channels in the group are split into 2 equal sets  (e.g. 1-to-8 and 9-to-16.\n");
        fprintf(stdout,"INFO:         Values in the 1st set are moved to alternate channels (e.g. 1-->2  2-->4  3-->6  etc.\n");
        fprintf(stdout,"INFO:         Values in the 2nd set are assigned to the remaining channels, in descending order.(e.g. 5-->7  6-->5  7-->3  etc.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (2)  Invert the spectrum.\n");
        fprintf(stdout,"INFO: (3)  Randomise the spectrum.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CHANNEL WHERE PROCESSING STARTS .. The number of the first channel in the folded groups.\n");
        fprintf(stdout,"INFO: CHANNELS TO PROCESS .......................... Number of channels to process.\n");
        fprintf(stdout,"INFO: (MODE 1) NUMBER OF FOLDINGS .......... Number of times to repreat the folding process.\n");
        fprintf(stdout,"INFO: (MODE 3) RANDOM SEED ........................ Same seed value produces exactly the same random permutation.\n");
        fprintf(stdout,"INFO: AMPLITUDES ONLY .................................. Process only the channel amplitude information.\n");
        break;
    case(BROWNIAN):
        fprintf(stdout,"INFO: CREATE BROWNIAN MOTION IN PITCH AND SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Use the source sound as a wavetable to generate the output pitches.\n");
        fprintf(stdout,"INFO: (2)  Use the whole source sound to generate individual events, by transposition.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The pitch of successive events wander in both pitch and space.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ................. Number of channels in the output file (1-16).\n");
        fprintf(stdout,"INFO: (MAX) OUTPUT DURATION ................. (Maximum) duration of the output file.\n");
        fprintf(stdout,"INFO: EVENT ATTACK DURATION ................ Rise time of events (Mode 1 only).\n");
        fprintf(stdout,"INFO: EVENT DECAY DURATION .................. Decay time of events (Mode 1 only).\n");
        fprintf(stdout,"INFO: BOTTOM OF PITCHRANGE (MIDI) ........ Bottom of pitch range (MIDI).\n");
        fprintf(stdout,"INFO: TOP OF PITCHRANGE (MIDI) ............. Top of pitch range (MIDI).\n");
        fprintf(stdout,"INFO: STARTING PITCH (MIDI) ................... Initial pitch (MIDI).\n");
        fprintf(stdout,"INFO: START POSITION ............................ Initial spatial position amongst output channels (numbering channels 1 - N).\n");
        fprintf(stdout,"INFO: MAX PITCH STEP (SEMITONES) .......... Maximum pitch step between events.\n");
        fprintf(stdout,"INFO: MAX SPACE STEP ............................ Max spatial step between events (fraction of distance between channels).\n");
        fprintf(stdout,"INFO:                                                                      START POSITION and SPACE STEP are ignored if the output is specified MONO.\n");
        fprintf(stdout,"INFO: AVERAGE TIMESTEP BETWEEN EVENTS.. (Average) Time between events.\n");
        fprintf(stdout,"INFO: RANDOM SEED ............................... (Integer) Seed value (Gives a reproducible random sequence).\n");
        fprintf(stdout,"INFO: MAX AMPLITUDE STEP(dB) ................. Max loudness step between events, in dB (default = 0: max = 96dB).\n");
        fprintf(stdout,"INFO: MINIMUM AMPLITUDE(dB) ................... Min loudness (only comes into play if \"AMPLITUDE STEP\" is greater than zero).\n");
        fprintf(stdout,"INFO:                                                                      If min > zero, and varying amplitude reaches -min dB,\n");
        fprintf(stdout,"INFO:                                                                       amplitude values are \"reflected\" back from this minimum boundary.\n");
        fprintf(stdout,"INFO:                                                                      If set to zero, NO amplitude minimum is set and\n");
        fprintf(stdout,"INFO:                                                                      if varying amplitude reaches -96dB, the sounds stream terminates.\n");
        fprintf(stdout,"INFO: ATTACK SLOPE ................................ Slope of the attack (mode 1 only)\n");
        fprintf(stdout,"INFO:                                                                      values < 1 rise fast, then more slowly  : values > 1 rise slowly, then faster.\n");
        fprintf(stdout,"INFO: DECAY SLOPE .................................. Slope of the decay (mode 1 only).\n");
        fprintf(stdout,"INFO:                                                                      values < 1 fall slowly, then faster  : values > 1 fall fast, then more slowly.\n");
        fprintf(stdout,"INFO: LINEAR LSPKR_ARRAY ...................... Output channels fed to \"linear\" array of loudspeakers.\n");
        fprintf(stdout,"INFO:                                                                      Default: loudspeaker array encircles the listener.\n");
        break;
    case(SPIN):
        fprintf(stdout,"INFO: ROTATE A WIDE STEREO-IMAGE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Rotate around the same 2 stereo channels, with possible doppler-shift.\n");
        fprintf(stdout,"INFO: (2)  Rotate around central channel (with possible doppler-shift) with stereo image spread to channels on left and right of this.\n");
        fprintf(stdout,"INFO: (3)  As mode 2, with image squeezing at centre i.e. when the spinning image crosses the centre ....\n");
        fprintf(stdout,"INFO:               MODE 3 uses ONLY the central channel to project the stereo-at-centre image.\n");
        fprintf(stdout,"INFO:               whereas MODE 2 also uses contributions from the outer channels to project the stereo-at-centre image.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ROTATION_RATE(CYCLES PER SEC) ........... Number of complete rotations per second (can vary through time).\n");
        fprintf(stdout,"INFO:                                                                            Positive values rotate clockwise (as viewed from above).\n");
        fprintf(stdout,"INFO:                                                                            Negative values rotate anticlockwise.\n");
        fprintf(stdout,"INFO: DIFFERENTIAL BETWEEN FRONT AND REAR .. As the edges cross the centre, edge \"at front\" is amplified by this factor\n");
        fprintf(stdout,"INFO:                                                                            while edge at rear is attenuated by this factor.\n");
        fprintf(stdout,"INFO: ATTENUATION AT CENTRE ...................... Attenuates BOTH edges as they cross the centre.\n");
        fprintf(stdout,"INFO: MAX DOPPLER PITCHSHIFT(SEMITONES) ...... Maximum pitchshift (up and down) due to motion-dependent doppler-shift.\n");
        fprintf(stdout,"INFO: EXPAND BUFFERS BY .............................. For large doppler-shift, more memory may be needed for calculations.\n");
        fprintf(stdout,"INFO:                                                                            Memory may be expanded here by some integer factor.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In Modes 2 and 3 .....\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTFILE CHANNEL COUNT ...................... Channel count of the output file. \n");
        fprintf(stdout,"INFO: CENTRE CHANNEL OF IMAGE ................... Channel number, in output file, which is at the output image centre.\n");
        fprintf(stdout,"INFO: MIN LEVEL ON CENTRE CHAN  .................. Minimum level of mono-condensed signal on centre channel.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In Mode 2 only .....\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAX BOOST ON CENTRE CHAN  ................ Maximum amplification of (mono-condensed) signal on centre channel.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPINQ):
        fprintf(stdout,"INFO: ROTATE A DOUBLE STEREO-IMAGE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Takes two stereo inputs and rotates them  around central channel with stereo image spread to channels on left and right of this.\n");
        fprintf(stdout,"INFO: The two inputs are initially wrapped around one another.\n");
        fprintf(stdout,"INFO: i.e. if the channels of File 1 are \"1L\" and \"1R\", and of File 2, \"2L\" and \"2R\", with central channel \"C\"\n");
        fprintf(stdout,"INFO: then the initial placement is  2L   1L   C   1R   2R\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Rotate around central channel (with possible doppler-shift) with stereo image spread to channels on left and right of this.\n");
        fprintf(stdout,"INFO: (2)  As mode 1, with image squeezing at centre i.e. when the spinning image crosses the centre ....\n");
        fprintf(stdout,"INFO:               MODE 2 uses ONLY the central channel to project the stereo-at-centre image.\n");
        fprintf(stdout,"INFO:               whereas MODE 1 also uses contributions from the outer channels to project the stereo-at-centre image.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ROTATION_RATE(CYCLES PER SEC) ........... Number of complete rotations per second (can vary through time).\n");
        fprintf(stdout,"INFO:                                                                            Positive values rotate clockwise (as viewed from above).\n");
        fprintf(stdout,"INFO:                                                                            Negative values rotate anticlockwise.\n");
        fprintf(stdout,"INFO: DIFFERENTIAL BETWEEN FRONT AND REAR .. As the edges cross the centre, edge \"at front\" is amplified by this factor\n");
        fprintf(stdout,"INFO:                                                                            while edge at rear is attenuated by this factor.\n");
        fprintf(stdout,"INFO: ATTENUATION AT CENTRE ...................... Attenuates BOTH edges as they cross the centre.\n");
        fprintf(stdout,"INFO: OUTFILE CHANNEL COUNT ...................... Channel count of the output file. \n");
        fprintf(stdout,"INFO: CENTRE CHANNEL OF IMAGE ................... Channel number, in output file, which is at the output image centre.\n");
        fprintf(stdout,"INFO: MAX DOPPLER PITCHSHIFT(SEMITONES) ...... Maximum pitchshift (up and down) due to motion-dependent doppler-shift.\n");
        fprintf(stdout,"INFO: EXPAND BUFFERS BY .............................. For large doppler-shift, more memory may be needed for calculations.\n");
        fprintf(stdout,"INFO:                                                                            Memory may be expanded here by some integer factor.\n");
        fprintf(stdout,"INFO: MIN LEVEL ON CENTRE CHAN  .................. Minimum level of mono-condensed signal on centre channel.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: In Mode 2 only .....\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MAX BOOST ON CENTRE CHAN  ................ Maximum amplification of (mono-condensed) signal on centre channel.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CRUMBLE):
        fprintf(stdout,"INFO: DISINTEGRATE A MONO SOURCE OVER A MULTICHANNEL SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Project a MONO source on all channels of a multichannel output, then segment it,\n");
        fprintf(stdout,"INFO: and distribute the segments over smaller and smaller groups of channels\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Over an 8-channel space.\n");
        fprintf(stdout,"INFO: (2)  Over a 16-channel space.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: START TIME ............................ Time in source at which disintegration starts.\n");
        fprintf(stdout,"INFO: DURATION OF HALF SPLITS .......... Duration of section where signal splits into 2 images.\n");
        fprintf(stdout,"INFO: DURATION OF QUARTER SPLITS .... Duration of section where signal split into 4 images.\n");
        fprintf(stdout,"INFO: DURATION OF EIGHTH SPLITS ....... (Mode 2 only) Duration of section where signal split into 8 images.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The sum of the \"Start Time\" and all these \"Duration\"s cannot exceed the duration of the input sound.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ORIENTATION ......................... When the input image first splits onto 2 images on 2 blocks of adjacent chans.\n");
        fprintf(stdout,"INFO:                                                                                The first block starts at channel \"ORIENTATION\" and uses channels clockwise of this.\n");
        fprintf(stdout,"INFO:                                                                                The 2nd block uses the remaining channels.\n");
        fprintf(stdout,"INFO: SEGMENT SIZE ........................ The (average) duration of the cut segments (can vary ober time).\n");
        fprintf(stdout,"INFO: SIZE RANDOMISATION ..............  Range 0 - 1. Maximum value(1) modifies size randomly between (size/2) and (3*size)./2\n");
        fprintf(stdout,"INFO: INPUT SCATTER ...................... Random scatering of the start-time in the source at which the next segment is cut. (Range 0 - 1)\n");
        fprintf(stdout,"INFO:                                                                                The cut-time in the source always advances.\n");
        fprintf(stdout,"INFO:                                                                                With no scatter, the timestep step to the next cut-time equals the duration of the current segment.\n");
        fprintf(stdout,"INFO:                                                                                With max input-scatter(1) timestep is a random value between 0 and the current segment duration.\n");
        fprintf(stdout,"INFO: OUTPUT SCATTER .................... Random scatering of the time-placement of the segment in the output stream. (Range 0 - 1)\n");
        fprintf(stdout,"INFO:                                                                                Time-placement in the output stream always advances.\n");
        fprintf(stdout,"INFO:                                                                                With no scatter, the step to the next output-time equals the duration of the current segment.\n");
        fprintf(stdout,"INFO:                                                                                With max output-scatter(1) timestep is a random value between 0 and the current segment duration.\n");
        fprintf(stdout,"INFO: OUTPUT TIMESTRETCH .............. Stretching of time-placement of segments in the output stream. (Range 1 - 64)\n");
        fprintf(stdout,"INFO:                                                                                The timestep in the output stream to the next segment-placement, is multiplied by the timestretch.\n");
        fprintf(stdout,"INFO:                                                                                Where output-timestretch is greater than 1, silent gaps should appear in the output.\n");
        fprintf(stdout,"INFO: PITCH SCATTER ...................... Maximum transposition (up or down) of the output segments,\n");
        fprintf(stdout,"INFO:                                                                                For example, a value of 3 produces a random transposition anywhere between 3 semitones up and 3 semitones down.\n");
        fprintf(stdout,"INFO: SEED ................................... The same seed value produces identical output on successive process runs.\n");
        fprintf(stdout,"INFO: SPLICELENGTH(mS) ................. Length, in milliseconds, of splices which cut segments from source.\n");
        fprintf(stdout,"INFO: LENGTH OF EXPONENTIAL TAIL(mS) Length, in milliseconds, of any (exponentially decaying) tail on the cut segments.\n");
        fprintf(stdout,"INFO: MAXIMIM DURATION ................ If output duration exceeds this limit, curtail it (set to zero for no curtailment).\n");
        break;
    case(TESSELATE):
        fprintf(stdout,"INFO: CREATE REPEATING PATTERN WITH SHIFTS IN SPACE AND TIME, USING ONE OR MORE MONO SOURCES.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The mono source is repeated one (set of) channels, but delays between repeats are different on a different (set of) channel(s).\n");
        fprintf(stdout,"INFO: The standard-delay is the \"Repeat Cycle Duration\".\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The change in the delay, as you pass from one (set of) channel(s) to the next, is specified by an integer, the \"Cycle Index\".\n");
        fprintf(stdout,"INFO: With 4 output channels, and a Cycle Index of 60,\n");
        fprintf(stdout,"INFO: If Channel A has standard-delay,\n");
        fprintf(stdout,"INFO: then the associated channels have standard-delay * (1 + 1/60)\n");
        fprintf(stdout,"INFO: so that\n");
        fprintf(stdout,"INFO: after 60 repetitions, channel(s) B resynchronises with channel(s) A\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Several sources can be input, and time-offset (Time Stagger), so the N sources (initially) form a rhythmic phrase.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Different sources can have different cycle-indeces.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TESSELATION DATA .......................... A textfile consisting of 2 lines of data.\n");
        fprintf(stdout,"INFO:                                   Each line must contain one entry for each input file.\n");
        fprintf(stdout,"INFO:                                   Line 1 - indicates the \"Cycle Index\" for the associated source.\n");
        fprintf(stdout,"INFO:                                   Line 2 - indicates the \"Time Stagger\" of the associated source.\n");
        fprintf(stdout,"INFO:                                                 One item should have stagger zero.\n");
        fprintf(stdout,"INFO:                                                 The other items should have different staggers\n");
        fprintf(stdout,"INFO:                                                 indicating their timing in the initial rhythmic phrase.\n");
        fprintf(stdout,"INFO:                                                 No delay should equal or exceed the \"Repeat Cycle Duration\".\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT .................. The number of output channels (2 - 16). This must be an even number of channels.\n");
        fprintf(stdout,"INFO: REPEAT CYCLE DURATION .................. The standard-(shortest)-delay between repetitions (the \"Repeat Cycle Duration\").\n");
        fprintf(stdout,"INFO: OUTPUT DURATION .......................... The required duration of the output sound.\n");
        fprintf(stdout,"INFO: TESSELATION TYPE ........................ Specifies how the channels are paired up.\n");
        fprintf(stdout,"INFO:                                       0 : Double diamond, all odd-channels play at one delay rate, and all even-channels at the other.\n");
        fprintf(stdout,"INFO:                                       1 : Channels are paired with the adjacent channel (sound 1 on ch1-paired-with-ch2, sound 2 on ch2-paired-with-ch3, etc.\n");
        fprintf(stdout,"INFO:                                       2 : Channels are paired with the channel 2 ahead (sound 1 on ch1 paired-with-ch3, sound 2 on ch2-paired-with-ch4, etc.\n");
        fprintf(stdout,"INFO:                                       3 : Channels are paired with the channel 3 ahead (sound 1 on ch1 paired-with-ch4, sound 2 on ch2-paired-with-ch5, etc.\n");
        fprintf(stdout,"INFO:                                       and so on.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(PHASOR):
        fprintf(stdout,"INFO: CREATE GRADUALLY PITCH-SHIFTING COPIES OF SOURCE SOUND, WHICH \"PHASE\" WITH ONE ANOTHER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Each stream pitch-shifts gradually up and down, to a specified max/min pitch-shift, at a rate determined by the frequency of the phasing wave.\n");
        fprintf(stdout,"INFO: The streams can be distributed over a specified number of output channels, and can be synchronous or time-staggered.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF PHASING STREAMS .......... The number of pitch-shifting streams to be output.\n");
        fprintf(stdout,"INFO: FREQUENCY OF PHASING WAVE .......... The frequency at which the up-down pitch-shifts happen.\n");
        fprintf(stdout,"INFO: MAX PHASING SHIFT (SEMITONES) .. The maximum phase shift used (in semitones): other streams have proportionately less phase-shift.\n");
        fprintf(stdout,"INFO: NUMBER OF OUTPUT CHANNELS .......... Output streams are distributed over this given number of output channels.\n");
        fprintf(stdout,"INFO: TIME OFFSET OF STREAMS(mS) ........ The start-time of the streams can be staggered by a few milliseconds (default, no stagger).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SOUND-SURROUND ................................ If more than 2 output channels, there output-placement relates to a sound-surround array.\n");
        fprintf(stdout,"INFO: WARN OF ROUNDING ERRORS .............. Warns of any errors in calculating the phase-shifted stream outputs.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB With time-variable phasing-wave frequency, extreme frequency shifts or reversals may produce anomalous output.\n");
        break;
    case(CRYSTAL):
        fprintf(stdout,"INFO: CREATE SOUND-SET RELATED, IN PITCH, TIME & PROXIMITY, TO VERTICES OF A 3D CRYSTAL, THEN ROTATE CRYSTAL AND RECREATE SOUNDS, ETC..\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mono input sound (or N input sounds for N vertices) used as sample-read table to generate outputs. Ideal duration 1 sec, but any dur possible.\n");
        fprintf(stdout,"INFO: Crystal vertices projected onto x, y plane, where x represents pitch, and y represents time. z (depth) determines signal brightness.\n");
        fprintf(stdout,"INFO: After playing one set of vertices, crystal rotates, around 2 different axes, and process of sound generation is then repeated ...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Mono output.\n");
        fprintf(stdout,"INFO: (2)  Stereo output (the y-coordinate is further interpreted as a position in the stereo space).\n");
        fprintf(stdout,"INFO: (3)  Stereo output across 2 channels of an 8-channel multichannel file, but separated by 1 channel.\n");
        fprintf(stdout,"INFO: (4)  Ditto, stepping clockwise around the channels for each vertex-group generated.\n");
        fprintf(stdout,"INFO: (5)  Ditto, stepping anticlockwise.\n");
        fprintf(stdout,"INFO: (6)  Ditto, stepping randomly.\n");
        fprintf(stdout,"INFO: (7)  Stereo output across 2 adjacent channels of an 8-channel multichannel file, stepping clockwise.\n");
        fprintf(stdout,"INFO: (8)  Ditto, stepping anticlockwise.\n");
        fprintf(stdout,"INFO: (9)  Ditto, stepping randomly.\n");
        fprintf(stdout,"INFO: (10) Stereo output, each vertex-set is output as a separate file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ROTATION SPEED AROUND Z AXIS (CYCS PER SEC) ................ Rotation speed (cycles per second) around z-axis.\n");
        fprintf(stdout,"INFO: ROTATION SPEED AROUND Y AXIS (CYCS PER SEC) ................ Rotation speed (cycles per second) around y-axis.\n");
        fprintf(stdout,"INFO: MAXIMUM TIMEWIDTH OF ONE ALL-VERTICES-PLAY .................. Maximum time between first vertex to play, and last, for any playing of one set of vertices.\n");
        fprintf(stdout,"INFO:                 Actual time between first and last vertices played will depend on crystal orientation.\n");
        fprintf(stdout,"INFO:                 Maximum timewidth is the maximum value this timewidth can take for all possible orientations of the crystal.\n");
        fprintf(stdout,"INFO:                 There will be a central time around which the vertices are laid out, sone before and some after this central time.\n");
        fprintf(stdout,"INFO: TIMESTEP BETWEEN ONE ALL-VERTICES-PLAY AND NEXT .......... Time-step between central-time of one playing-of-a-set-of-vertices, and the next playing.\n");
        fprintf(stdout,"INFO: TOTAL DURATION OF OUTPUT ........................................................ Minimum output duration.\n");
        fprintf(stdout,"INFO:                 When \"total duration\" is reached, any vertex-set being played will continue to its end before the output terminates.\n");
        fprintf(stdout,"INFO: MIN MIDI PITCH OF ANY VERTEX (WHEREVER ROTATED)\n");
        fprintf(stdout,"INFO: MAX MIDI PITCH OF ANY VERTEX (WHEREVER ROTATED) .......... As vertices are rotated, their pitch will usually change.\n");
        fprintf(stdout,"INFO:                 These are the minimum and maximum pitch thay any vertex might attain, and will not necessarily be reached by any rotated vertex.\n");
        fprintf(stdout,"INFO: FRQ OF PASSBAND OF FILTER FOR DISTANCE CUES\n");
        fprintf(stdout,"INFO: FRQ OF STOPBAND OF FILTER FOR DISTANCE CUES\n");
        fprintf(stdout,"INFO: MAX ATTENUATION(DB) OF FILTER\n");
        fprintf(stdout,"INFO: GAIN APPLIED TO SRC BEFORE FILTERING ..................................As vertices recede beyond x-y plane, sound is filtered to indicate distance.\n");
        fprintf(stdout,"INFO:                 Filtering done by CDP lowpass-filter, for which a passband, a (higher) stopband, an attenuation and a pregain need to be specified.\n");
        fprintf(stdout,"INFO: CURVE SLOPE FOR MIXING FILT TO UNFILT SND(DEPTH CUE) .. The filtered sound is mixed into the unfiltered, increasingly for greater distance.\n");
        fprintf(stdout,"INFO:                 The curve slope determines how this mixing differs from a simple linear crossfade.\n");
        fprintf(stdout,"INFO:                 Values less than one create a more rapid increase in filtering in the initial stages, values greater than one, the opposite.\n");
        fprintf(stdout,"INFO: CURVE SLOPE FOR MIXING IN OCTAVE-UP-SND(PROXIMITY CUE) As vertices approach in front of the x-y plane, sound is octave-stacked to indicate proximity.\n");
        fprintf(stdout,"INFO:                 The curve slope determines, similarly, how this mixing differs from a simple linear crossfade.\n");
        break;
    case(WAVEFORM):
        fprintf(stdout,"INFO: CREATE A WAVETABLE SUITABLE FOR USE IN THE \"CRYSTAL\" PROCESS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mono input sound used to generate a symmetric output table, suitable to use as a waveform for sound-generation.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Specify a time in the source, and a number of half-wavesets to read.\n");
        fprintf(stdout,"INFO: (2)  Specify a time in the source, and a duration in milliseconds to read.\n");
        fprintf(stdout,"INFO: (3)  Ditto, then combine the selected sound with a single-cycle sinusoid.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIME OF SAMPLING ...................... Time in the source where sound is to be sampled.\n");
        fprintf(stdout,"INFO: COUNT OF HALF WAVESETS .......... Number of half-wavesets to read from the source.\n");
        fprintf(stdout,"INFO: DURATION TO SAMPLE (mS) ........ Duration, in mS, to sample from the source.\n");
        fprintf(stdout,"INFO: BALANCE WITH SINUSOID ............ Relative level of source and sinusoid in final output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Modes 1 and 2 cut a source segment (at zero-crossings), then abutt the inverted segment to the original, to make a waveform.\n");
        fprintf(stdout,"INFO: In Mode 3, this abutted waveform is superimposed over a single-cycle sinusoid of the same duration.\n");
        break;
    case(DVDWIND):
        fprintf(stdout,"INFO: SHORTEN SOUND BY READ-THEN-SKIP, READ-THEN-SKIP, ETC.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIME CONTRACTION ............. Time-contraction of the source. Greater than 1. Can vary through time.\n");
        fprintf(stdout,"INFO: SIZE OF CLIPS(mS) ............ Duration of the retained clips, in mS. Can vary through time.\n");
        break;
    case(CASCADE):
        fprintf(stdout,"INFO: SUCCESSIVE SEGMENTS OF SRC ARE REPEAT-ECHOED, AND ECHO-SETS SUPERIMPOSED ON SRC.\n");
        fprintf(stdout,"INFO: \n");
        if(mode < 5) {
            switch(mode) {
            case(0):    
                fprintf(stdout,"INFO: N-chan output :: N-chan input. Every echo is in all N channels.\n");
                break;
            case(1):
                fprintf(stdout,"INFO: Stereo output :: Mono input (going to left of output)   :: Echo-streams pan to right.\n");
                break;
            case(2):
                fprintf(stdout,"INFO: Stereo output :: Mono input (going to centre of output) :: Echo-streams pan alternately to L and R.\n");
                break;
            case(3):
                fprintf(stdout,"INFO: 8-chan output :: Mono input (going initially to Ch 1)   :: Each echo in each stream steps to next channel, clockwise.\n");
                break;
            case(4):
                fprintf(stdout,"INFO: 8-chan output :: Mono input (going initially to Ch 1)   :: Each echo in odd-numbered streams steps to R, even-numbered to L.\n");
                break;
            }
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SEGMENT LENGTH .......................... Duration (in secs) of (successive) segments in source; each of which is echoed. Possibly time-varying.\n");
            fprintf(stdout,"INFO: MAX SEGMENT LENGTH .................... Maximum duration of the segments. If set, \"SEGMENT LENGTH\" treated as a minimum.\n");
            fprintf(stdout,"INFO:                                                              Actual length is a random value between min and max.\n");
        } else {
            switch(mode) {
            case(5):    
                fprintf(stdout,"INFO: N-chan output :: N-chan input. Every echo is in all N channels.\n");
                break;
            case(6):
                fprintf(stdout,"INFO: Stereo output :: Mono input (going to left of output)   :: Echo-streams pan to right.\n");
                break;
            case(7):
                fprintf(stdout,"INFO: Stereo output :: Mono input (going to centre of output) :: Echo-streams pan alternately to L and R.\n");
                break;
            case(8):
                fprintf(stdout,"INFO: 8-chan output :: Mono input (going initially to Ch 1)   :: Each echo in each stream steps to next channel, clockwise.\n");
                break;
            case(9):
                fprintf(stdout,"INFO: 8-chan output :: Mono input (going initially to Ch 1)   :: Each echo in odd-numbered streams steps to R, even-numbered to L.\n");
                break;
            }
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: CUT_TIMES_IN_SOURCE .................... (Succesive) times at which to cut source, to produce the segments to echo.\n");
            fprintf(stdout,"INFO: \n");
        }
        fprintf(stdout,"INFO: ECHO COUNT ................................... Number of echos of each segment. Possibly time-varying.\n");
        fprintf(stdout,"INFO: MAX ECHO COUNT ........................... Maximum number of echos. If set, \"ECHO COUNT\" treated as a minimum.\n");
        fprintf(stdout,"INFO:                                                              Actual count is a random value between min and max.\n");
        fprintf(stdout,"INFO:                                                              If set to ZERO it is ignored.\n");
        fprintf(stdout,"INFO: TIME RANDOMISATION OF ECHOS .. Randomisation of echo timings (default zero).\n");
        fprintf(stdout,"INFO: RANDOM SEED ............................... With same non-zero Seed value, a repeat process-run with same parameters gives identical output.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ECHOS MAY BE SHREDDED (echoed-segment cut into smaller chunks which are then randomly rearraged)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CHUNKS IN ANY SEGMENT SHRED .. Number of chunks into which segment-echo is cut.\n");
        fprintf(stdout,"INFO: REPEAT SHREDDINGS ....................... Number of repeated shreddings on each segment-echo.\n");
        fprintf(stdout,"INFO: ALSO SHRED SOURCE ....................... Source is shredded, as well as echos.\n");
        fprintf(stdout,"INFO: LINEAR DECAY ECHO LEVELS ........ Successice echos, in each echo-set, fall away in level less rapdily.\n");
        fprintf(stdout,"INFO: NORMALISE LOW LEVEL OUTPUT .... Raise Low level output to near maximum level. (High level output is automatically normalised).\n");
        break;
    case(SYNSPLINE):
        fprintf(stdout,"INFO: SYNTHESIS FROM WAVEFORMS MADE BY SMOOTHLY JOINING RANDOMLY GENERATED POINTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SAMPLE RATE ........................... Sample rate of synthesized sound.\n");
        fprintf(stdout,"INFO: DURATION .............................. Duration of the output sound.\n");
        fprintf(stdout,"INFO: FREQUENCY ............................ Fundamental frq of the output (Range 0.001 to 10000 Hz).\n");
        fprintf(stdout,"INFO: SPLINE COUNT ......................... Number of random points generated within a half-wavecycle. InterpolatION between these create the (next) waveform. (0 -64)\n");
        fprintf(stdout,"INFO: INTERPOLATION STEPS .............. Number of interpolation steps in which one waveform morph into the next (0 - 4096).\n");
        fprintf(stdout,"INFO: MAXIMUM SPLINE COUNT ............ Maximum Spline Count. If a non-zero value is entered, at each new vavecycle,\n");
        fprintf(stdout,"INFO:                                                                     a random number of spline points is generated with value between \"Spline Count\" and this maximum value.\n");
        fprintf(stdout,"INFO: MAXIMUM INTERPOLATION STEPS .. Maximum number of interpolation steps. If a non-zero value is entered, at each new vavecycle,\n");
        fprintf(stdout,"INFO:                                                                     a random number of steps is generated with value between \"Interpolation Steps\" and this maximum value.\n");
        fprintf(stdout,"INFO: MAXIMUM PITCH_DRIFT (SEMITONES)............... Maximum random drift of pitch away away from specified frequency, in semitones. (0 - 12)\n");
        fprintf(stdout,"INFO: AVERAGE TIME(mS) BETWEEN NEW DRIFT VALS .. New pitch drift value set after approximately this timestep (mS).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NORMALISE ALL WAVECYCLES ...... Normalise every wavecycle (default: cycles retain whatever (maximal)-amplitude is generated\n");
        fprintf(stdout,"INFO:                                                                     in the waveform generation process).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FREQUENCY, SPLINE COUNT, INTERPOLATION STEPS (and the related maximal parameters) can all vary through time. \n");
        break;
    case(FRACTAL):
        fprintf(stdout,"INFO: CREATE FRACTAL REARRANGEMENT OF SOURCE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF FRACTAL LAYERS .. How many times the source is rearranged : Range 2 to 100.\n");
        fprintf(stdout,"INFO: SPLICE LENGTH IN mS ............ Length of splices : Range 2 to 50\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB The process magnifies the size of the source, substantially.\n");
        break;
    case(FRACSPEC):
        fprintf(stdout,"INFO: IMPOSE FRACTAL TRANSPOSITION PATTERN ON SPECTRUM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SEMITONE TRANSPOSITION PATTERN ......................... set of time:semitone-transposition pairs for largest time-scale of fractal pattern,\n");
        fprintf(stdout,"INFO:                                                                                                      Last time defines duration of pattern, last value ignored.\n");
        fprintf(stdout,"INFO:                                                                                                      Pattern reproduced at contracted time-scale, on each element of pattern, recursively.\n");
        fprintf(stdout,"INFO: MAX FRACTALISATION ............................................ Maximum degree of fractalisation (repetition of patterning at smaller and smaller timescales.\n");
        fprintf(stdout,"INFO: TIME STRETCH OF FRACTAL PATTERN ......................... Timestretch applied to fractal pattern. Must be >= 1. If set to zero, ignored.\n");
        fprintf(stdout,"INFO: INTERVAL STRETCH OF FRACTAL PATTERN ................... Interval stretch applied to fractal pattern. If set to zero, ignored.\n");
        fprintf(stdout,"INFO: The previous three parameters can all vary through time. \n");
        fprintf(stdout,"INFO: SHRINK FRACTAL INTERVALS AS_TIMESCALE SHRINKS ..... e.g. if pattern (at next timescale) shrinks by 1/4, transposition intervals also shrink by 1/4.\n");
        fprintf(stdout,"INFO: READ BRKPNT DATA IN OUTFILE TIMEFRAME ................. (default : brkpoint data is read in the inputfile timeframe).\n");
        fprintf(stdout,"INFO: FORMANTS NOT RETAINED ............................................. Simple transposition of spectral components. (Default: attempts to retain formant envelope).\n");
        break;
    case(SPLINTER):
        switch(mode) {
        case(0):    
        case(2):    
            fprintf(stdout,"INFO: CREATE SPLINTERS MERGING INTO SOURCE SOUND.\n");
            break;
        case(1):    
        case(3):    
            fprintf(stdout,"INFO: CREATE SPLINTERS EMERGING OUT OF SOURCE SOUND.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Creates splinters by repeating, with shrinking, a specific waveset-group in the source.\n");
        fprintf(stdout,"INFO: The time of and size of this group is specified by you.\n");
        switch(mode) {
        case(0): case(2):   
            fprintf(stdout,"INFO: The derived, shrunk splinters repeat, then expand, eventually merging into the original sound at their origin point.\n");
            break;
        case(1): case(3):   
            fprintf(stdout,"INFO: The original sound plays up to the selected time, then splinters,\n");
            break;
        }
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: As they expand, the splinters step downwards in pitch.\n");
            break;
        case(1):    
            fprintf(stdout,"INFO: As they shrink, the splinters step upward in pitch.\n");
            break;
        case(2): case(3):   
            fprintf(stdout,"INFO: As they shrink, the splinters retain the original pitch (roughly).\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIME (BEFORE) WAVESET GROUP ............. Time immediately before start of selected wavesets.\n");
        fprintf(stdout,"INFO: WAVESET COUNT ............................... Number of wavesets to use to make splinter.\n");
        fprintf(stdout,"INFO: SHRINKING SPLINTERS COUNT ................ Number of splinter repeats before max shrinking attained.\n"); 
        fprintf(stdout,"INFO: SHRUNK SPLINTERS COUNT ................... Number of additional max-shrunk splinters before any accel or rit ends.\n");
        fprintf(stdout,"INFO: SPLINTER PULSE RATE AT ORIG WAVESET .. Pulse rate (in Hz) of the repeating splinters close to their origin in the source.\n");
        fprintf(stdout,"INFO: GOAL PULSE RATE ............................. Pulse rate (in Hz) of the splinters at max distance from their origin.\n");
        fprintf(stdout,"INFO: EXTRA SPLINTERS COUNT .................... Number of any additional splinters, at regular pulse, beond the \"maximum\" distance.\n");
        switch(mode) {
        case(0): case(2):
            fprintf(stdout,"INFO: SHRINK CONTOUR ............................. Contour of shrink. 1.0 = linear; >1 expands more rapidly at end; <1  less rapidly at end.\n");
            break;
        case(1): case(3):
            fprintf(stdout,"INFO: SHRINK CONTOUR ............................. Contour of shrink. 1.0 = linear; >1 shrink more rapidly at end; <1  less rapidly at end.\n");
            break;
        }
        switch(mode) {
        case(0): case(2):
            fprintf(stdout,"INFO: TIMING CONTOUR ............................. Contour of pulse-rate change. >1 accels or rits more rapidly at end; <1 less rapidly at end.\n");
            break;
        case(1): case(3):
            fprintf(stdout,"INFO: TIMING CONTOUR ............................. Contour of pulse-rate change. >1 accels or rits more rapidly at start; <1 less rapidly at start.\n");
            break;
        }
        switch(mode) {
        case(0): case(1):   
            fprintf(stdout,"INFO: FRQ OF SHRUNK WAVESETS ................. Determines final wavelength of wavesets when they are maximally shrunk. Default 6000Hz\n");
            break;
        case(2): case(3):   
            fprintf(stdout,"INFO: DURATION(mS) OF SHRUNK WAVESETS ... The final size (in mS) of the waveset-group when it is maximally shrunk.\n");
            break;
        }
        fprintf(stdout,"INFO: SPLINTER TIMING RANDOMISATION ......... Randomisation of the pulse-rate of the splinters.\n");
        fprintf(stdout,"INFO: SPLINTER SHRINKING RANDOMISATION .... Randomisation of the shrinkage of the splinters.\n");
        switch(mode) {
        case(0): case(2):   
            fprintf(stdout,"INFO: RETAIN ALL SOURCE SND ..................... Default, source is not heard until the splinters merge into it.\n");
            break;
        case(1): case(3):   
            fprintf(stdout,"INFO: RETAIN ALL SOURCE SND ..................... Default, source is not heard after splinters emerge from it.\n");
            break;
        }
        fprintf(stdout,"INFO: RETAIN NO SOURCE SND ..................... The source sound is entirely suppressed.\n");
        break;
    case(REPEATER):
        fprintf(stdout,"INFO: PLAY THROUGH SOURCE, WITH SPECIFIED ELEMENTS REPEATING THEMSELVES.\n");
        fprintf(stdout,"INFO:        The Sound-stream pauses for each segment-of-repeats then continues (to the next) ...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 3 : produces decrescendoing, accelerating output, like bouncing object.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: REPEATED SEGMENTS DATA ......................... a textfile of values specifying the segments to be repeated, and the details of the repetition .\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:                         Each line contains 4 values .....\n");
        fprintf(stdout,"INFO: \n");
        if(mode == 0 || mode == 2) {
            fprintf(stdout,"INFO:                         \"Start-time\"   \"End-time\"   \"Number-of-Repeats\"   \"Delay-time\"\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                         \"Start-time\" and \"End-time\" are the start and end of the segment to be repeated.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                         \"Delay-time\", for any repeating segment,\n");
            fprintf(stdout,"INFO:                         is the time between the START of one repeated element and the START of the next.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                         Delay zero will produce a delay equal to the segment length.\n");
            fprintf(stdout,"INFO:                         Otherwise, delays less than 0.05 seconds may produce output like an oscillator.\n");
        } else {
            fprintf(stdout,"INFO:                         \"Start-time\"   \"End-time\"   \"Number-of-Repeats\"   \"Offset-time\"\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO:                         \"Offset-time\", for any repeating segment,\n");
            fprintf(stdout,"INFO:                         is the time between the END of one repeated element and the START of the next.\n");
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:                         Selected segments  must be at least 0.01 seconds in duration\n");
        fprintf(stdout,"INFO:                         and can overlap one-another, or backtrack in the source sound.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANGE OF ANY RANDOM EXPANSION OF DELAY TIMES ......... For any segment, the delay times may each be randomly stretched.\n");
        fprintf(stdout,"INFO:                            This parameter specifies the upper limit of such streching, and this limit may vary through time.\n");
        fprintf(stdout,"INFO:                            An expansion of \"1.0\" results in no stretching.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANGE OF ANY RANDOM PITCH VARIATION(SEMITONES) ..... For any segment, the pitch of each repeat may randomly vary.\n");
        fprintf(stdout,"INFO:                            This parameter specifies the upper limit of such pitch-variation, in semitones.\n");
        fprintf(stdout,"INFO:                            An expansion limit of e.g. \"1.5\" results in random pitch shifts in the range 1.5 semitones down to 1.5 semitones up.\n");
        fprintf(stdout,"INFO:                            A value of zero results in no transposition.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RANDOM SEED .............................................................. An integer. Repeated process-runs with same source and same seed value gives identical output.\n");
        if(mode == 2) {
            fprintf(stdout,"INFO: ACCELERATION OF REPEATS ...................................... e.g. \"3\" means Gradually shorten delays until they reach 1/3 duration .\n");
            fprintf(stdout,"INFO: WARP OF ACCELERATION ................................................ Warp value >1 shortens by less initially and by more later. Warp 1 has no effect.\n");
            fprintf(stdout,"INFO: FADE CONTOUR .............................................................. 1  Gives linear fade:   >1  Faster followed by slower decay:   <1  Slower followed by faster.\n");
            fprintf(stdout,"INFO: \n");
        }
        break;
    case(VERGES):
        fprintf(stdout,"INFO: PLAY SOURCE, WITH SPECIFIED BRIEF MOMENTS GLISSING UP OR DOWN ABRUPTLY, AND POSSIBLY ACCENTED.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Best applied to attack points in the source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: VERGE TIMES ............................................... Textifle, being a list of times at which to create the verges.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: VERGE TRANSPOSITION(SEMITONES) ......... Initial semitone transposition at the verge-time.\n");
        fprintf(stdout,"INFO:                            This parameter specifies the upper limit of such streching, and this limit may vary through time.\n");
        fprintf(stdout,"INFO:                            An expansion of \"1.0\" results in no stretching.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: VERGE SLOPE ............................................... Slope of glissando. Default 1 (linear). Other values are steeper.\n");
        fprintf(stdout,"INFO: VERGE DURATION ........................................ Duration of the verges.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \"TRANSPOSITION\", \"SLOPE\" and \"DURATION\" can vary through time.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DON'T SEARCH FOR LOCAL PEAKS ....... Use the exact verge-times supplied. Do not search for local peaks.\n");
        fprintf(stdout,"INFO: BOOST VERGE LEVEL ..................................... Boost the level of the verges.\n");
        fprintf(stdout,"INFO: SUPPRESS NON-VERGES .............................. Suppress any input signal which is not a verge.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \"BOOST\" and \"SUPPRESS\" Cannot be used together.\n");
        break;
    case(MOTOR):
        fprintf(stdout,"INFO: CREATING A FAST STREAM OF PULSES, ENVELOPED BY A SLOWER-PULSING STREAM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Create fast (inner) pulse-stream, within slower (outer) pulsing-enveloping.\n");
        fprintf(stdout,"INFO: Under every outer envelope-pulse, the inner events are cut, successively, from the input source(s).\n");
        fprintf(stdout,"INFO: Each outer-pulse (possibly shortened by randomisation) must hold at least 2 inner-pulses (possibly lengthened by randomisation).\n");
        fprintf(stdout,"INFO: Shortish sources with a changing spectrum (or shortish segments cut from a larger source) are recommended.\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: MODE: Uses a single source. Reads src-segment, then advances during pulse crescendo, regressing during decrescendo.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: MODE: Uses several elements cut from a single source, with cuts specified in \"SLICE TIMES\".\n");
            fprintf(stdout,"INFO:             Reads a segment from an element then advances during pulse crescendo, regressing during decrescendo.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: MODE: Uses several srcs. Reads element from a src then advances during pulse crescendo, regressing during decrescendo.\n");
            break;
        case(3):
            fprintf(stdout,"INFO: MODE: Uses a single source. Reads src-segment then advances.\n");
            break;
        case(4):
            fprintf(stdout,"INFO: MODE: Uses several elements cut from a single source, with cuts specified in \"SLICE TIMES\".\n");
            fprintf(stdout,"INFO:             Reads an element-segment then advances.\n");
            break;
        case(5):
            fprintf(stdout,"INFO: MODE: Uses several srcs. Reads a src-segment then advances.\n");
            break;
        case(6):
            fprintf(stdout,"INFO: MODE: Uses a single source. Reads src-segment, advancing for rest of read, or regressing for rest of read. Decision to advance or regress is random.\n");
            break;
        case(7):
            fprintf(stdout,"INFO: MODE: Uses several elements cut from a single source, with cuts specified in \"SLICE TIMES\".\n");
            fprintf(stdout,"INFO:             Reads element-segment advancing for rest of read, or regressing for of the read. Decision to advance or regress is random.\n");
            break;
        case(8):
            fprintf(stdout,"INFO: MODE: Uses several srcs. Reads src-segment advancing for rest of read, or regressing for rest the read. Decision to advance or regress is random.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        switch(mode) {
        case(1):
        case(4):
        case(7):
            fprintf(stdout,"INFO: SLICE TIMES (Mode 2 only) ........................... Slice times to cut source input sound into several source segments.\n");
            break;
        }
        fprintf(stdout,"INFO: TOTAL OUTPUT DURATION ........................... Duration of output sound to produce.\n");
        fprintf(stdout,"INFO: INNER PULSE FRQ(Hz) ................................. Frq rate of inner (faster) pulses.\n");
        fprintf(stdout,"INFO: OUTER PULSE RATE(Hz) ............................... Frq rate of outer (enveloping) pulses.\n");
        fprintf(stdout,"INFO: INNER PULSES PROPORTION ON-TO-OFF TIME ... Proportion of the inner pulse which sounds (the rest is silence, or a low-level tail: see below).\n");
        fprintf(stdout,"INFO: OUTER PULSES PROPORTION ON-TO-OFF TIME .. Proportion of the outer pulse which sounds (the rest is silence).\n");
        fprintf(stdout,"INFO: SYMMETRY OF OUTER PULSES ....................... Position of peak within envelope: 0 is start, 1 is end: 1/2 is halfway through envelope.\n");
        fprintf(stdout,"INFO: INNER PULSE FRQ RANDOMISATION ................ Range of randomisation of the inner-pulse frequency (0 to 1) (max range (val 1) from dur/3 to 3*dur/2).\n");
        fprintf(stdout,"INFO: OUTER PULSE FRQ RANDOMISATION ............... Range of randomisation of the outer-envelope frequency. (similarly)\n");
        fprintf(stdout,"INFO: PITCH RANDOMISATION RANGE(SEMITONES) ..... Range of pitch variation of inner pulse, moving from one envelope to next. (0-3 semitones)\n");
        fprintf(stdout,"INFO: ATTENUATION RANDOMISATION RANGE ........... Range of any random attenuation of inner-pulses (0: no attenuation :: 1: rand attenuation  from  none to zero level output).\n");
        fprintf(stdout,"INFO: SYMMETRY RANDOMISATION ......................... Range of randomisation of envelope symmetry (0 to 1).\n");
        fprintf(stdout,"INFO: INNER PULSES DECAY TAIL ........................... Length of decay tails on inner-pulses, a multiple of their duration.\n");
        fprintf(stdout,"INFO: OUTER PULSE SHARPNESS ............................ Slope of outer-envelope. 1 = linear: >1 slow-to-fast rise:  <1 fast_to_slow rise.\n");
        fprintf(stdout,"INFO: READ ADVANCE RANDOMISATION ................... Randomisation of the step advance in reading the input. (Range 0 to 1).\n");
        fprintf(stdout,"INFO: RANDOM SEED .............................................. Same seed value, with same values for randomising params, produces identical output.\n");
        fprintf(stdout,"INFO: ADVANCE BY FIXED STEP IN SRC READS ........... Default is to step regularly through src so we reach its end, whatever the length of the pulse.\n");
        switch(mode) {
        case(1):
        case(4):
        case(7):
            fprintf(stdout,"INFO: USE SEGMENTS CYCLICALLY .......................... Default is to randomly permute the order of the segments.\n");
            break;
        case(2):
        case(5):
        case(8):
            fprintf(stdout,"INFO: USE SRCS CYCLICALLY ............................... Default is to randomly permute the order of the srcs.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: All parameters EXCEPT \"SEED\" and \"DURATION\" can vary through time.\n");
        break;
    case(STUTTER):
        fprintf(stdout,"INFO: SLICE SOURCE INTO ELEMENTS, AND RANDOMLY PLAY SEGMENTS SLICED FROM START OF SEGMENTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Best applied to attack points in the source (e.g. start of word or syllable of text).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: SLICE TIMES  ...................................................... Slice times to cut source input sound into several elements.\n");
        fprintf(stdout,"INFO: OUTPUT DURATION ...............................................Duration of output sound to produce.\n");
        fprintf(stdout,"INFO: MAX SEGMENT JOINS ............................................ Segments can be used independently, or joined together consecutively.\n");
        fprintf(stdout,"INFO:                                                                                                This parameter determines the maximum number of segments to be joined.\n");
        fprintf(stdout,"INFO: PROPORTION OF SILENCE ...................................... Cut elements can be separated by silence\n");
        fprintf(stdout,"INFO:                                                                                                This parameter determines the proportion of segments that are followed by silence.\n");
        fprintf(stdout,"INFO: MIN SILENCE DURATION ........................................ Minimum duration of any intervening silences.\n");
        fprintf(stdout,"INFO: MAX SILENCE DURATION ........................................ Maximum duration of any intervening silences.\n");
        fprintf(stdout,"INFO: RANDOM SEED .................................................... Same seed value, with same values for randomising params, produces identical output.\n");
        fprintf(stdout,"INFO: MAX RANGE OF RANDOM TRANSPOSITION(SEMITONES) .. Maximum range over which cut segments can be randomly transposed.\n");
        fprintf(stdout,"INFO: MAX RANGE_OF RANDOM ATTENUATION .................... Maximum range over which cut segments can be attenuated.\n");
        fprintf(stdout,"INFO: SEGMENT LENGTH BIAS .......................................... Bias < 0 favours shorter cuts from segments. Bias > 0, longer cuts.\n");
        fprintf(stdout,"INFO: MIN SEGMENT DURATION(mS) .................................. Minimum duration of any cut segment.\n");
        fprintf(stdout,"INFO: PERMUTE SEGMENT ORDER ..................................... Play a cut from each elements in random order, than permute order and repeat.\n");
        fprintf(stdout,"INFO:                                                                                                (Default: elements selected entirely at random.)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \"TRANSPOSITION\", \"ATTENUATION\" and \"BIAS\" can vary through time.\n");
        break;
    case(SCRUNCH):
        switch(mode) {
        case(0):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S AND PERMUTE THEIR ORDER TO FORM OUTPUT STREAM.\n");                   break;
        case(1):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S, THE SELECT AT RANDOM INTO OUTPUT STREAM.\n");                        break;
        case(2):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF INCREASING LENGTH (PITCH FALLING).\n");  break;
        case(3):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF DECREASING LENGTH (PITCH RISING).\n");   break;
        case(4):    fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF INCREASING LENGTH (PITCH FALLING).\n");  break;
        case(5):    fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF DECREASING LENGTH (PITCH RISING).\n");   break;
        case(6):    fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE ALTERNATELY IN ORDER OF INCREASING THEN DECREASING LENGTH (PITCH FALL-RISE).\n"); break;
        case(7):    fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE ALTERNATELY IN ORDER OF DECREASING THEN INCREASING LENGTH (PITCH RISE-FALL).\n"); break;
        case(8):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF INCREASING LOUDNESS.\n");    break;
        case(9):    fprintf(stdout,"INFO: CUT SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF DECREASING LOUDNESS.\n");    break;
        case(10):   fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF INCREASING LOUDNESS.\n");    break;
        case(11):   fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE THEM IN ORDER OF DECREASING LOUDNESS.\n");    break;
        case(12):   fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE ALTERNATELY IN ORDER OF INCREASING THEN DECREASING LOUDNESS.\n"); break;
        case(13):   fprintf(stdout,"INFO: CUT SEGMENTS OF SOURCE INTO WAVESET(GROUP)S AND ARRANGE ALTERNATELY IN ORDER OF DECREASING THEN INCREASING LOUDNESS.\n"); break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        if(mode <= 1)
            fprintf(stdout,"INFO: OUTPUT DURATION ...............................................Duration of output sound to produce.\n");
        else if((mode > 3 && mode < 8) || mode > 9)
            fprintf(stdout,"INFO: SLICE TIMES ...................................................... Textfile of (increasing) times at which to divide src into segments for processing.\n");
        fprintf(stdout,"INFO: RANDOM SEED .................................................... Same seed value, with same values for randomising params, produces identical output.\n");
        fprintf(stdout,"INFO: COUNT_OF_WAVESETS_IN_A_GROUP ....................... Count (and then cut) wavesets in groups of this size.\n");
        fprintf(stdout,"INFO: MAX RANGE OF RANDOM TRANSPOSITION(SEMITONES) .. Maximum range over which cut segments can be randomly transposed.\n");
        fprintf(stdout,"INFO: MAX RANGE_OF RANDOM ATTENUATION .................... Maximum range over which cut segments can be attenuated.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \"TRANSPOSITION\", and \"ATTENUATION\" can vary through time.\n");
        break;
    case(IMPULSE):
        fprintf(stdout,"INFO: GENERATE IMPULSES OR IMPULSE STREAMS, PITCHED OR CHIRPING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT DURATION .............................. Duration of output sound to produce.\n");
        fprintf(stdout,"INFO: PITCH OF IMPULSE STREAM(MIDI) ............ Not the pitch of the impulses, but the rate at which they occur.\n");
        fprintf(stdout,"INFO: GLISSING OF IMPULSE .......................... Zero value gives a fixed-pitch impulse, >zero, impulses gliss (up then down). CARE: high valus may clip.\n");
        fprintf(stdout,"INFO: SLOPE OF IMPULSE .............................. Value 1, impulses rise and fall in level linearly. Higher values give steeper slopes.\n");
        fprintf(stdout,"INFO: NUMBER OF PEAKS PER IMPULSE .............. Dividing this number by the frq of the stream (derived from pitch) gives the (Start) pitch of the impulses themselves.\n");
        fprintf(stdout,"INFO: IMPULSE LEVEL ................................... Loudness of the impulses.\n");
        fprintf(stdout,"INFO: PROPORTIONAL GAP BETWEEN IMPULSES .. Zero gives no gap. +ve vals leave silent space between impulses e.g. 0.5 gives a gap of 1/2 the duration of the impulse.\n");
        fprintf(stdout,"INFO:                                                                                                          -ve values cause the impulses to overlap. With -0.5 they overlap by 1/2 their length.\n");
        fprintf(stdout,"INFO: SAMPLE RATE .................................... Sample rate of the output sound.\n");
        fprintf(stdout,"INFO: OUTPUT CHANNEL CNT ......................... Number of channels in the output sound.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \"PITCH\", \"GLISSING\", \"SLOPE\", \"NUMBER OF PEAKS\", \"LEVEL\" and \"GAP\" can vary through time.\n");
        break;
    case(TWEET):
        switch(mode) {
        case(0):
        case(1):
            fprintf(stdout,"INFO: SUBSITUTE CHIRPS FOR VOCAL FORMANTS.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: SUBSITUTE NOISE FOR VOCAL FORMANTS.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIMEBLOKS IN SRC NOT TO SEARCH FOR FOFS ... Textfile of pairs of times in src where there are no FOFs expected,\n");
        fprintf(stdout,"INFO: FREQUENCY OF SRC(HZ) .............................. A textfile of time : frequency pairs, being the extracted pitch contour of the input sound\n");
        fprintf(stdout,"INFO: LOWEST LEVEL AT WHICH FOFS DETECTED(dB) ... If any FOF is more than this number of dBs below the level of the loudest FOF detected, it is ignored.\n");
        fprintf(stdout,"INFO:                                                                                    (A ZERO value will search for FOFs at any level).\n");
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: NUMBER OF PEAKS IN CHIRP ... ...................... Number of peaks in the chirp which replaces the FOF. (Frq will vary depending on size of FOF)\n");
            fprintf(stdout,"INFO: GLISSING OF CHIRP ..................................... Amount of glissing of the chirps.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: \"NUMBER OF PEAKS\", and \"GLISSING\" can vary through time.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: FREQUENCY OF CHIRP ................................. (Fixed) Frequency of the chirps.\n");
            fprintf(stdout,"INFO: GLISSING OF CHIRP ..................................... Amount of glissing of the chirps.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: \"FREQUENCY\" and \"GLISSING\" can vary through time.\n");
            break;
        }
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: COSIN SMOOTH FOFS .................................. Cosinusoidal onset and decay applied to FOFs, before replacement sound inserted.\n");
        break;
    case(RRRR_EXTEND): // verasion 8+ 
        switch(mode) {
            case(0):
            case(1):
                fprintf(stdout,"INFO: TIME-EXTEND NATURAL ITERATIVE EVENTS IN A SRC (LIKE ROLLED 'rrr' IN SPEECH) IN A PLAUSIBLE WAY\n");
                break;
            case(2):
                fprintf(stdout,"INFO: FIND AND CUT OUT EACH GRAIN OF AN ITERATIVE EVENT IN A SRC SOUND (LIKE ROLLED 'rrr' IN SPEECH)\n");
                fprintf(stdout,"INFO: AND SAVE EACH GRAIN (AND THE PRE-ITERATE AND POST-ITERATE CHUNKS OF THE SRC) TO ITS OWN SOUNDFILE BY FIRST\n");
                break;
        }
        switch(mode) {
            case(0):
            case(2):
            fprintf(stdout,"INFO: SPECIFYING WHERE THE ITERATIVE EVENT IS IN THE SOURCE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: START OF SECTION TO BE EXTENDED ......................... Time of start of the iterated material in the source.\n");
            fprintf(stdout,"INFO: END OF SECTION TO BE EXTENDED ............................ Time of end of the iterated material in the source.\n");
            fprintf(stdout,"INFO: ANTICIPATED NO OF SEGMENTS TO FIND IN SRC............ Estimate how many iterations you hear in marked area.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: LETTING THE PROCESS SEARCH FOR THE (FIRST) ITERATIVE EVENT IN THE SOURCE.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINUMUM NO OF SEGMENTS TO FIND IN SRC ................ Estimate how many iterations you hear in marked area.\n");
            fprintf(stdout,"INFO: APPROX SIZE OF GRANULE (MS) ................................ Anticipated size of grain (try 15mS).\n");
            fprintf(stdout,"INFO: GATE LEVEL BELOW WHICH SIGNAL ENVELOPE IGNORED .. Don't search for grains where signal drops below gate-level.\n");
            fprintf(stdout,"INFO: NUMBER OF GRAINS AT ITERATIVE START TO OMIT ........ Allows you to play through first N grains you find\n");
            fprintf(stdout,"INFO:                                                                  before using the ensuing grains for the time-extension process.\n");
            break;
        }
        fprintf(stdout,"INFO: APPROX RANGE OF ITERATIVE SOUND (OCTAVES) ......... The acceptable variation in grainsize of grains to find (Try 1).\n");
        fprintf(stdout,"INFO:                                                                  This is the 'pitch'-range of the (low_frq) iteration, and NOT the resonant frequency.\n");
        fprintf(stdout,"INFO:                                                                  e.g. for a rolled 'rrr' it is the frq of the 'rrr' itself (even if unvoiced)\n");
        fprintf(stdout,"INFO:                                                                  and not the pitch of any sung note (if the 'rrr' is voiced).\n");
        switch(mode) {
            case(0):
            case(1):
            fprintf(stdout,"INFO: TIME EXTENSION OF THE MATERIAL ITSELF (TEM).......... How much to time-extend the marked material (by randomised repetition).\n");
            fprintf(stdout,"INFO: MAX ADJACENT OCCURENCES OF ANY SEG IN OUTPUT ... Iterated material extended by reusing the individual grains in a randomised pattern.\n");
            fprintf(stdout,"INFO:                                                              In this pattern, grain-A may occur next to an identical copy of grain-A, or not.\n");
            fprintf(stdout,"INFO:                                                              This parameter specifies how many adjacent copies of any segment you are prepared to allow.\n");
            fprintf(stdout,"INFO: AMPLITUDE SCATTER .............................................. The iterated segments may vary in amplitude.\n");
            fprintf(stdout,"INFO:                                                            0 retains original amplitude: N produces random amplitudes between orig and (1-N) * orig.\n");
            fprintf(stdout,"INFO: PITCH SCATTER ................................................... The iterated segments may vary in pitch.\n");;
            fprintf(stdout,"INFO:                      0 retains original pitch: N produces random pitchshift between N and -N semitones.\n");
            fprintf(stdout,"INFO: GRAIN SEPARATION TIMESTRETCH (GST) .................... Material can also be time-stretched by inserting silence between the grains.\n");
            fprintf(stdout,"INFO:                                                              This parameter, varying upwards from 1 (= no timestretch), is independent of the TEM parameter\n");;
            fprintf(stdout,"INFO:                                                              and will overiride it if GST makes the output longer, or shorter than the length implied by TEM.\n");
            fprintf(stdout,"INFO:                                                              In any breakpoint file for this parameter, times are measured FROM THE START OF THE ITERATED SEGMENT\n");
            fprintf(stdout,"INFO:                                                              (rather than the start of the source file) and the final value of \"1.0\" in the brkfile defines the time-end of the GST.\n");
            fprintf(stdout,"INFO:                                                              Note that if your brkpoint values don't begin and end at \"1.0\" there will be a discontinuity\n");
            fprintf(stdout,"INFO:                                                              if you attach the sound before (or after) the iterated segment to the iterated segment itself.\n");
            fprintf(stdout,"INFO: GRAIN SEPARATION REGULARISTION ........................... When set to 1, attempts to make grains appear at a fixed regular rate\n");
            fprintf(stdout,"INFO:                                                              independent of the invidual grain durations.\n");;
            fprintf(stdout,"INFO:                                                              It will only kick in once the grains have been stretched by GST (and total regularity is not possible\n");
            fprintf(stdout,"INFO:                                                               until the average step from one grain start to the next is greater than size of largest grain).\n");
            fprintf(stdout,"INFO:                                                              In any breakpoint file for this parameter, times are measured FROM THE START OF THE ITERATED SEGMENT\n");
            fprintf(stdout,"INFO:                                                              (rather than the start of the source file).\n");
            fprintf(stdout,"INFO: DON'T KEEP SOUND BEFORE ITERATE ..................... If flag is set, start of sound (before iterated material) is discarded.\n");
            fprintf(stdout,"INFO: DON'T KEEP SOUND AFTER ITERATE ....................... If flag is set, end of sound (after iterated material) is discarded.\n");
        }
        break;
    case(SORTER):
        fprintf(stdout,"INFO: CHOPS MONO SOURCE INTO ELEMENTS, THEN REORGANISES BY LOUDNESS, OR DURATION.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Mode 1: Sort to Crescendo.\n");
        fprintf(stdout,"INFO: Mode 2: Sort to Decrescendo.\n");
        fprintf(stdout,"INFO: Mode 3: Sort to Accelerando. (With very small elements, may rise in pitch).\n");
        fprintf(stdout,"INFO: Mode 4: Sort to Ritardando.  (With very small elements, may fall in pitch).\n");
        fprintf(stdout,"INFO: Mode 5: Order at Random.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ELEMENT SIZE ... Approximate size of elements to sort, in seconds.\n");
        fprintf(stdout,"INFO:                                   If set to zero, individual wavesets are chosen as elements.\n");
        fprintf(stdout,"INFO: SMOOTHING .........  Fade in (and out) each segment, with a \"SMOOTH\" mS splice.\n");
        fprintf(stdout,"INFO:                                   If elementsize is zero, this is ignored.\n");
        fprintf(stdout,"INFO: SEED ................... Mode 5 (\"Order at Random\"): a rerun with same non-zero seed value\n");
        fprintf(stdout,"INFO:                                   outputs the SAME random ordering of elements.\n");
        fprintf(stdout,"INFO:                                   (Zero seed-value gives different random ordering on each run).\n");
        fprintf(stdout,"INFO: OUTPITCH ........... Output elements time-spacing equivalent to the MIDI pitch,\"OPCH\".\n");
        fprintf(stdout,"INFO:                                   If \"AS FREQUENCY\" flag is used, value can be set to 128 to specify\n");
        fprintf(stdout,"INFO:                                   the median pitch of the source.\n");
        fprintf(stdout,"INFO:                                   If value is set to zero, parameter is ignored.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AS FRQEQUENCY .. Element size is read as a frq value (= 1.0/duration)\n");
        fprintf(stdout,"INFO:                                   and could be e.g. a frequency-trace of the pitch of the source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The following parameters can only be used if \"AS FRQEQUENCY\" flag is set.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ELEMENT PITCH .. Transpose input elements to the MIDI pitch specified.\n");
        fprintf(stdout,"INFO:                                   If value set to 128, the median pitch of the source is used.\n");
        fprintf(stdout,"INFO:                                   If value is set to zero, parameter is ignored.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The following parameter is only useful if \"ELEMENT PITCH\" is set.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: META GROUPING ... Size of meta-grouping, in seconds.\n");
        fprintf(stdout,"INFO:                                   Allows larger units to be (approximately) pitch-correlated.\n");
        fprintf(stdout,"INFO:                                   Source is first cut to pitch-wavelen-scale elements & transpositions calculated.\n");
        fprintf(stdout,"INFO:                                   These elements are then further grouped to (approx) \"META GROUPING\" size.\n");
        fprintf(stdout,"INFO:                                   This must be larger than the largest element (1/frq) from frq trace.\n");
        fprintf(stdout,"INFO:                                   If \"META GROUPING\" is set to zero, it is ignored.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If \"ELEMENT PITCH\" is NOT set, larger groupings are obtained by using larger value of \"ELEMENT SIZE\".\n");
        break;
    case(SPECFNU):
        switch(mode) {
        case(0):
            fprintf(stdout,"INFO: NARROW FORMANTS: Steepens skirts of formant peaks by power factor.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: NARROWING ........................................ Narrowing of individual formant peaks. Range 1 to 1000. Timevariable.\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: SUPPRESS SET ...................................... Suppress the listed formants. \"OFF\" can be any combination of\n");
            fprintf(stdout,"INFO:                                                                                \"1\",\"2\",\"3\" & \"4\" but not all of them, and with no repetitions.\n");
            fprintf(stdout,"INFO: ZERO TOP OF SPECTRUM .......................... Zero top of spectrum (above fourth formant).\n");
            fprintf(stdout,"INFO: FORCE FUNDAMENTAL ............................. Force lowest formant to use fundamental frq as peak.\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS .................. Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED... Re.place unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(1):
            fprintf(stdout,"INFO: SQUEEZE SPECTRUM AROUND FORMANT: Squeeze around specified formant.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SQUEEZE ............................................ Squeeze factor. Range 1 to 10. Timevariable.\n");
            fprintf(stdout,"INFO: CENTRE FORMANT ................................. Formant peak at centre of squeeze. (range 1 to 4)\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: SQUEEZE AROUND TROUGH ABOVE ............. Squeeze around trough above specified peak.\n");
            fprintf(stdout,"INFO: FORCE FUNDAMENTAL ............................. Force lowest formant to use fundamental frq as peak.\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ............ Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS .................. Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(2):
            fprintf(stdout,"INFO: INVERT FORMANTS: Formant peaks become troughs, and troughs peaks.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: VIBRATE RATE ........................................ If not zero, cycle between original & inversion at this frq. Timevariable.\n");
            fprintf(stdout,"INFO: GAIN .................................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ................................ Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS .............. Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS .................... Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .... Replace unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(3):
            fprintf(stdout,"INFO: ROTATE FORMANTS: Formant peaks & frqs move up (or down) spectrum.\n");
            fprintf(stdout,"INFO:         reappearing at foot (top) of formant-area, when they reach its edge.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ROTATION SPEED ................................... Spectrum rotation speed, e.g. 2 = twice every second.\n");
            fprintf(stdout,"INFO:                                                                                 Range -300 to 300 rotations per second. Timevariable.\n");
            fprintf(stdout,"INFO: GAIN ................................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................... Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ............ Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS ................... Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED ... Replace unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(4):
            fprintf(stdout,"INFO: SPECTRAL NEGATIVE: Spectral values inverted for each channel.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GAIN ...... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: FLAT ...... Do not re-envelope the output spectrum.\n");
            break;
        case(5):
            fprintf(stdout,"INFO: SUPPRESS FORMANTS: Suppresses the selected formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: SUPPRESS SET ............................... which of (4) formants to suppress. e.g. \"1\" means suppress 1st,\n");
            fprintf(stdout,"INFO:                                                                    while \"134\" means suppress 1st, 3rd and 4th.\n");
            fprintf(stdout,"INFO: GAIN ........................................... Output gain or attenuation. (Range 0.1 to 10).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ...................... Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS .... Exclude non-harmonic partials.\n");
            break;
        case(6):
            fprintf(stdout,"INFO: GENERATE FILTER(S) FROM FORMANT(S): Outputs varibank filter data textfile.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: DATAFILE .......................... Textfile containing.\n");
            fprintf(stdout,"INFO:     (1)  LIST OF TIMES at which src to be divided into blocks for analysis.\n");
            fprintf(stdout,"INFO:                      Resulting filter step-changes between vals created from each block.\n");
            fprintf(stdout,"INFO:                      Value ZERO means use the entire source to make 1 fixed filter.\n");
            fprintf(stdout,"INFO:     (2)  PITCH GRID on which pitches you are searching for must lie.\n");
            fprintf(stdout,"INFO:                      There must first be a marker indicating the grid type. These are..\n");
            fprintf(stdout,"INFO:                              #HS:    Followed by listed MIDI pitches to search for.\n");
            fprintf(stdout,"INFO:                              #HF:    Followed by listed MIDI pitches to search for IN ALL OCTAVES.\n");
            fprintf(stdout,"INFO:                              #SCALE: Followed by just TWO values.\n");
            fprintf(stdout,"INFO:                                    (a) the number of equal pitch divisions in an octave.\n");
            fprintf(stdout,"INFO:                                    (b) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO:                              #ELACS: Followed by just THREE values.\n");
            fprintf(stdout,"INFO:                                    (a) Size of \"octave\" in (possibly fractional) semitones.\n");
            fprintf(stdout,"INFO:                                    (b) the number of equal pitch divisions in \"octave\".\n");
            fprintf(stdout,"INFO:                                    (c) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO: PEAKS PER FORMANT ........ (Max) number of peaks from each formant to use. (Default value 1). \n");
            fprintf(stdout,"INFO: FORCE A PITCH BELOW ..... Try to ensure there is 1 (or more) pitch(es) below this MIDI value.\n");
            fprintf(stdout,"INFO: KEEP PEAK LOUDNESS ....... Keep relative (summed) loudnesses of peaks as part of filter design.\n");
            fprintf(stdout,"INFO: INVERT PEAK LOUDNESS .... Keep inverse of loudnesses as part of filter design.\n");
            fprintf(stdout,"INFO:                                                   Default. All filter amplitudes set to 1.0\n");
            fprintf(stdout,"INFO: FORCE FUNDAMENTAL ...... Force lowest formant to use fundamental frq as peak.\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ........ Use short-window for extracting spectral envelope.\n");
            break;
        case(7):
            fprintf(stdout,"INFO: MOVE FORMANTS BY: Displace individual formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MOVE1 .................................................. Frq displacement, up or down, of formant 1. Timevariable.\n");
            fprintf(stdout,"INFO: MOVE2,MOVE3,MOVE4 ............................... Similarly for other formants.\n");
            fprintf(stdout,"INFO:                                          (Formants moving below zero or above nyquist/2 will disappear).\n");
            fprintf(stdout,"INFO: GAIN .................................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ZERO TOP OF SPECTRUM ............................ Zero top of spectrum (above fourth formant).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ................................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS .............. Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS .................... Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .... Replace unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(8):
            fprintf(stdout,"INFO: MOVE FORMANTS TO: Displace individual formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FRQ1 ................................................... New frq of formant 1. Timevariable.\n");
            fprintf(stdout,"INFO: FRQ2,FRQ3,FRQ4 ................................... Similarly for other formants.\n");
            fprintf(stdout,"INFO: GAIN ................................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ZERO TOP OF SPECTRUM ........................... Zero top of spectrum (above fourth formant).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................... Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: NARROW FORMANT BANDS ........................ Use narrow formant bands.\n");
            fprintf(stdout,"INFO:                                                                    Using narrow bands can give counterintuitive results.\n");
            fprintf(stdout,"INFO:                                                                    Doesn't capture so many harmonic peaks, so sounds duller.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ............. Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: EXCLUDE HARMONIC PARTIALS ................... Exclude harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED ... Replace unpitched (or extremely quiet) windows by silence.\n");
            break;
        case(9):
            fprintf(stdout,"INFO: ARPEGGIATE SPECTRUM: Arpeggiate spectrum of source, under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE ..................... Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: GAIN ......................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ..................... Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS .. Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ............................. Arpeggiate downwards (default upwards).\n");
            fprintf(stdout,"INFO: UP AND DOWN ............................ Arpeggiate up and down.\n");
            break;
        case(10):
            fprintf(stdout,"INFO: OCTAVE-SHIFT UNDER FORMANTS: Octave-shift src spectrum, under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: OCTAVE SHIFT ...................................... Octave shift (Range -4 to + 4). (Timevariable).\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE .............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ............................................ Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: FILL TOP OF SPECTRUM ........................... If transposing downwards, fill spectrum top with extra harmonics.\n");
            break;
        case(11):
            fprintf(stdout,"INFO: TRANSPOSE UNDER FORMANTS: tranpose spectrum of src, under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: TRANSPOSITION (SEMITONES).................... Semitone transposition (Range -48 to + 48). (Timevariable).\n");
            fprintf(stdout,"INFO: GAIN ................................................... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE ............................... Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................. Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ............................................. Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ............ Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: FILL TOP OF SPECTRUM ........................... If transposing downwards, fill spectrum top with extra harmonics.\n");
            break;
        case(12):
            fprintf(stdout,"INFO: FRQSHIFT UNDER FORMANTS: Frqshift src spectrum of under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FREQUENCY SHIFT ................................. Frequency shift(Hz) (Range -1000 to +1000). (Timevariable).\n");
            fprintf(stdout,"INFO: GAIN ........................................ ......... Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE .............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ............................................ Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ............ Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: FILL TOP OF SPECTRUM ........................... If transposing downwards, fill spectrum top with extra harmonics.\n");
            break;
        case(13):
            fprintf(stdout,"INFO: RESPACE PARTIALS UNDER FORMANTS: Respace partials in src spectrum,retaining formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: FREQUENCY SPACING ............................ New frq spacing of partials (Hz) (Range 1 to 1000).(Timevariable).\n");
            fprintf(stdout,"INFO: GAIN ................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE ............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ........................................... Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: FILL TOP OF SPECTRUM ........................... If transposing downwards, fill spectrum top with extra harmonics.\n");
            break;
        case(14):
            fprintf(stdout,"INFO: PITCH-INVERT UNDER FORMANTS: Invert pitch of src, under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: INTERVAL MAP ................................... Set map to ZERO if no mapping is required..OTHERWISE\n");
            fprintf(stdout,"INFO:                                                                                         map is a textfile of paired values showing how intervals\n");
            fprintf(stdout,"INFO:                                                                                         (in, possibly fractional, SEMITONES)\n");
            fprintf(stdout,"INFO:                                                                                         are to be mapped onto their inversions.\n");
            fprintf(stdout,"INFO:                                                                                         Range +-%0lf semitones (+- %.0lf octaves).\n",MAXINTRANGE,MAXINTRANGE/SEMITONES_PER_OCTAVE);
            fprintf(stdout,"INFO: PIVOT PITCH ....................................... Pitch about which to invert pitch of src (Range %d to %d).\n",SPEC_MIDIMIN,MIDIMAX);
            fprintf(stdout,"INFO:                                                                                         Pitch as MIDI, with possibly fractional val.  (Timevariable).\n");
            fprintf(stdout,"INFO:                                                                                         If value zero entered, uses the mean pitch of the input.\n");
            fprintf(stdout,"INFO: GAIN ................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE ............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ........................................... Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: LOW PITCH LIMIT .................................. Minimum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: HIGH PITCH LIMIT ................................. Maximum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ...................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ..................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            break;
        case(15):
            fprintf(stdout,"INFO: PITCH-EXAGGERATE/SMOOTH UNDER FORMANTS: Exaggerate/Smooth pitch-line, retaining the formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PIVOT PITCH ....................................... Pitch about which to exaggerate/smooth the pitchline of src (Range %d to %d).\n",SPEC_MIDIMIN,MIDIMAX);
            fprintf(stdout,"INFO:                                                                                Pitch as MIDI, with possibly fractional val.  (Timevariable).\n");
            fprintf(stdout,"INFO:                                                                                If value zero entered, uses the MEAN pitch of the input.\n");
            fprintf(stdout,"INFO: RANGE MULTIPLIER ................................  Expand or Contract Range of pitchline. (Range 0 - 1).\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE .............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ........................................... Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: LOW PITCH LIMIT ................................... Minimum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: HIGH PITCH LIMIT .................................. Maximum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ...................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ..................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: TIE TO TOP ......................................... Tie to TOP of pitch range.\n");
            fprintf(stdout,"INFO: TIE TO FOOT ....................................... Tie to FOOT of pitch range.\n");
            fprintf(stdout,"INFO: TIE TO MIDDLE ..................................... Also Tie to range middle (only with other \"TIE\" flags) .\n");
            fprintf(stdout,"INFO: ABOVE MEAN ONLY ................................ Do range change ABOVE mean only.\n");
            fprintf(stdout,"INFO: BELOW MEAN ONLY ................................ Do range change BELOW mean only.\n");
            break;
        case(16):
            fprintf(stdout,"INFO: QUANTISE PITCH: Force source onto a specified pitch field.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH GRID .......................................... Textfile defining PITCH GRID on which quantised pitches must lie.\n");
            fprintf(stdout,"INFO:                  There must first be a marker indicating the grid type. These are..\n");
            fprintf(stdout,"INFO:                  #HS:    Followed by listed MIDI pitches to search for.\n");
            fprintf(stdout,"INFO:                  #HF:    Followed by listed MIDI pitches to search for IN ALL OCTAVES.\n");
            fprintf(stdout,"INFO:                  #THF:   Followed by lines each with time + list of MIDI pitches.\n");
            fprintf(stdout,"INFO:                                    1st time must be zero & times must increase.\n");
            fprintf(stdout,"INFO:                                    Each MIDI list must be the same length.\n");
            fprintf(stdout,"INFO:                                    To change number of pitches from line to line, duplicate values.\n");
            fprintf(stdout,"INFO:                  #SCALE: Followed by just TWO values.\n");
            fprintf(stdout,"INFO:                                    (a) the number of equal pitch divisions in an octave.\n");
            fprintf(stdout,"INFO:                                    (b) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO:                  #ELACS: Followed by just THREE values.\n");
            fprintf(stdout,"INFO:                                    (a) Size of \"octave\" in (possibly fractional) semitones.\n");
            fprintf(stdout,"INFO:                                    (b) the number of equal pitch divisions in \"octave\".\n");
            fprintf(stdout,"INFO:                                    (c) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE .............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................. Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ............................................ Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: LOW PITCH LIMIT ................................... Minimum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: HIGH PITCH LIMIT .................................. Maximum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: ALLOW ORNAMENTS ............................... Allow ORNAMENTS in the quantised pitch-line.\n");
            fprintf(stdout,"INFO: NO SMOOTHING .................................... No smoothing of transitions between pitches.\n");
            break;
        case(17):
            fprintf(stdout,"INFO: PITCH RANDOMISE: Randomise pitch of src.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH GRID (OR ZERO) .......................... Zero OR a textfile defining PITCH GRID on which pitches are pre-quantised.\n");
            fprintf(stdout,"INFO:                  IF SET TO ZERO, no pre-quantisation of pitch takes place \n");
            fprintf(stdout,"INFO:                  If a textfile, in that file there must first be a marker indicating the grid type. These are..\n");
            fprintf(stdout,"INFO:                  #HS:    Followed by listed MIDI pitches to search for.\n");
            fprintf(stdout,"INFO:                  #HF:    Followed by listed MIDI pitches to search for IN ALL OCTAVES.\n");
            fprintf(stdout,"INFO:                  #THF: Followed by lines each with time + list of MIDI pitches.\n");
            fprintf(stdout,"INFO:                                    1st time must be zero & times must increase.\n");
            fprintf(stdout,"INFO:                                    Each MIDI list must be the same length.\n");
            fprintf(stdout,"INFO:                                    To change number of pitches from line to line, duplicate values.\n");
            fprintf(stdout,"INFO:                  #SCALE: Followed by just TWO values.\n");
            fprintf(stdout,"INFO:                                    (a) the number of equal pitch divisions in an octave.\n");
            fprintf(stdout,"INFO:                                    (b) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO:                  #ELACS: Followed by just THREE values.\n");
            fprintf(stdout,"INFO:                                    (a) Size of \"octave\" in (possibly fractional) semitones.\n");
            fprintf(stdout,"INFO:                                    (b) the number of equal pitch divisions in \"octave\".\n");
            fprintf(stdout,"INFO:                                    (c) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO: RANDOMISATION RANGE ........................ Semitone range within which random offsets generated. (Range 0 to %d)\n",RANDPITCHMAX);
            fprintf(stdout,"INFO: RANDOMISATION SLEW .......................... Relationship between (possible) upward & downward random variation.\n");
            fprintf(stdout,"INFO:                           e.g. 2: uprange = 2 * downrange     0.5: uprange = 0.5 * downrange.\n");
            fprintf(stdout,"INFO:                           Ranges 0.1 to 10. (Value 1 has no effect).\n");
            fprintf(stdout,"INFO: GAIN ................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE ............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................ Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ........................................... Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: LOW PITCH LIMIT ..................................  Minimum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: HIGH PITCH LIMIT .................................. Maximum acceptable pitch (MIDI, possibly fractional).\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ...................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            fprintf(stdout,"INFO: FAST PITCH-CHANGE .............................. Allow fast pitch-motion in the quantised pitch-line.\n");
            fprintf(stdout,"INFO: NO SMOOTHING .................................... No smoothing of transitions between pitches.\n");
            fprintf(stdout,"INFO: NO FORMANT RESHAPING ........................ Do not reshape formants after pitch randomisation.\n");
            break;
        case(18):
            fprintf(stdout,"INFO: RANDOMISE SPECTRUM UNDER FORMANTS: Randomise spectrum, under formants.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: RANDOMISATION .................................. Randomisation of partial frequencies (Range 0 to 1).(Timevariable).\n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: ARPEGGIATION RATE .............................. Rate of arpeggiation of spectrum (Range -50 to +50 Hz).\n");
            fprintf(stdout,"INFO: LOW CUT ............................................. Cut off frequencies below this. (range 20 to 10000)\n");
            fprintf(stdout,"INFO: HIGH CUT ............................................ Cut off frequencies above this. (range 50 to 10000)\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW .............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: EXCLUDE NON-HARMONIC PARTIALS ........... Exclude non-harmonic partials.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: DOWNWARDS ....................................... Arpeggiate downwards (default upwards) (Only when ARPEGGIATION RATE > 0).\n");
            fprintf(stdout,"INFO: UP AND DOWN ...................................... Arpeggiate up and down. (Only when ARPEGGIATION RATE > 0)\n");
            break;
        case(19):
            fprintf(stdout,"INFO: SEE SPECTRAL ENVELOPES: \n");
            fprintf(stdout,"INFO: Outputs viewable (not playable) sndfile showing spectral envelope at each window as a block of +ve samples.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ... Use short-window for extracting spectral envelope.\n");
            break;
        case(20):
            fprintf(stdout,"INFO: SEE SPECTRAL PEAKS & TROUGHS: Frequencies of troughs/peaks in each window printed to textfile.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Format of the printout is:\n");
            fprintf(stdout,"INFO:    \"Trough  PEAK-1  Trough  PEAK-2  Trough  PEAK-3  Trough  PEAK-4  Trough\"\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ... Use short-window for extracting spectral envelope.\n");
            break;
        case(21):
            fprintf(stdout,"INFO: LIST TIMES OF TROUGHS BETWEEN SYLLABLES: Times printed to textfile.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: Will usually need post-correction \"by hand\".\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: MINIMUM SYLLABE DURATION .... Minimum acceptable duration for a syllable (default %.04lf)\n",MIN_SYLLAB_DUR);
            fprintf(stdout,"INFO: MINIMUM PEAK HEIGTH ............ Minimum height of peak above bracketing trofs (default %.04lf).\n",MIN_PEAKTROF_GAP);
            fprintf(stdout,"INFO:                                                                    (Maximum possible height is 1.0).\n");
            fprintf(stdout,"INFO: GET PEAKS ........................... Get syllable amplitude-peaks, rather than interening troughs.\n");
            fprintf(stdout,"INFO: GET TROUGHS AND PEAKS ........ Get both troughs and peaks,\n");
            break;
        case(22):
            fprintf(stdout,"INFO: SINE SPEECH: Convert formant frequencies to sinus tones.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: PITCH GRID (OR ZERO) ........................ ZERO or a textfile.\n");
            fprintf(stdout,"INFO:                                If this is set to ZERO, no pitch quantisation takes place.\n");
            fprintf(stdout,"INFO:                                Otherwise, this is textfile of data about pitches to quantise to.\n");
            fprintf(stdout,"INFO:                                There must first be a marker indicating the grid type. These are..\n");
            fprintf(stdout,"INFO:                                #HS:    Followed by listed MIDI pitches to quantise to.\n");
            fprintf(stdout,"INFO:                                #HF:    Followed by listed MIDI pitches to quantise to IN ALL OCTAVES.\n");
            fprintf(stdout,"INFO:                                #THF:   Followed by lines each with time + list of MIDI pitches.\n");
            fprintf(stdout,"INFO:                                        1st time must be zero & times must increase.\n");
            fprintf(stdout,"INFO:                                        Each MIDI list must be the same length.\n");
            fprintf(stdout,"INFO:                                        To change no of pitches from line to line, duplicate values.\n");
            fprintf(stdout,"INFO:                                #SCALE: Followed by just TWO values.\n");
            fprintf(stdout,"INFO:                                      (a) the number of equal pitch divisions in an octave.\n");
            fprintf(stdout,"INFO:                                      (b) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO:                                #ELACS: Followed by just THREE values.\n");
            fprintf(stdout,"INFO:                                      (a) Size of \"pseudo-octave\" in (possibly fractional) semitones.\n");
            fprintf(stdout,"INFO:                                      (b) the number of equal pitch divisions in peudo-octave.\n");
            fprintf(stdout,"INFO:                                      (c) MIDI pitch of any pitch to tune the scales to.\n");
            fprintf(stdout,"INFO: \n");
            fprintf(stdout,"INFO: GAIN .................................................. Output gain or attenuation. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: DEPTH ................................................ Degree of sinusoidisation. Range 0 to 1.\n");
            fprintf(stdout,"INFO: LEVEL1 ............................................... Relative gain or attenuation of formant1. (Range 0.01 to 10)\n");
            fprintf(stdout,"INFO: LEVEL2,LEVEL3,LEVEL4 ............................ similar for the other formants.\n");
            fprintf(stdout,"INFO: HFIELD DEPTH1 .................................... If Harmonic Field applied, how strongly to force formant1 pitches to Field (Range 0-1).\n");
            fprintf(stdout,"INFO: HFIELD DEPTH2, DEPTH3, DEPTH4 .............. Similarly for other formant bands.\n");
            fprintf(stdout,"INFO: USE SHORT WINDOW ............................. Use short-window for extracting spectral envelope.\n");
            fprintf(stdout,"INFO: FORCE FUNDAMENTAL ............................ Force lowest formant to use fundamental frq as peak.\n");
            fprintf(stdout,"INFO: NONPITCH_&_LOLEVEL_WINDOWS_ZEROED .. Replace unpitched (or extremely quiet) windows by silence.\n");
            fprintf(stdout,"INFO: SMOOTHING ........................................ Smoothing between pitches in formant traces.\n");
            break;
        }
        break;
    case(FLATTEN):
        fprintf(stdout,"INFO: EQUALISE LEVELS OF SEGMENTS (e.g. SYLLABLES) WITHIN A SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ELEMENTSIZE ...... Approx size of elements (e.g. syllables) in the source sound.\n");
        fprintf(stdout,"INFO: SHOULDER ......... Risetime to attain new (segment) level, in mS. (Range 20 to ELEMENTSIZE/2).\n"
        "                                                                           Will never be longer than the time from segment edge to segment peak.\n");
        fprintf(stdout,"INFO: TAIL ................. Portion of end of sound to be treated as a whole segment. (Range 0 to < duration (secs)).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIP :   Use the \"TAIL\" parameter to handle any anomalies (sudden loudness) at file end.\n");
        break;
    case(BOUNCE):
        fprintf(stdout,"INFO: REPEAT SOURCE, \"BOUNCING\" (ACCELERATING REPETITION WITH FADING LEVEL).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1:  Waveset-interpolate between markers.\n");
        fprintf(stdout,"INFO: MODE 2:  Waveset-interpolate within alternate marked blocks.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF BOUNCES ............................ Number of bouncing repeats (after initial sound) (Range 1 to 100).\n");
        fprintf(stdout,"INFO: FIRST BOUNCE EXTENT ........................ Timestep to first bounce entry (Range 0.04 to 10).\n");
        fprintf(stdout,"INFO: BOUNCE ACCEL ...................................... Step to next bounce is \"Bounce-accel\" times step to previous bounce (Range 0.1 to 1).\n");
        fprintf(stdout,"INFO: FINAL LEVEL ........................................ Level of final bounce, relative to source level (Range 0 to 1).\n");
        fprintf(stdout,"INFO: LEVEL DECAY SLOPE ............................ Slope of level reduction: > 1 Greater reduction at start : < 1 Greater reduction at end (Range .1 to 10).\n");
        fprintf(stdout,"INFO: SHRINK GRADUALLY(MIN_DURATION) ..  Successive events are shrunk (by cutting them short) in same proportion as change in bounce-steps.\n");
        fprintf(stdout,"INFO:                                                                           Zero value indicates NO CUTTING. Minimum non-zero value = 0.02.\n");
        fprintf(stdout,"INFO: TRIM TO SIZE ...................................... If bounced elements overlap in time, cut them short to avoid this overlap.\n");
        fprintf(stdout,"INFO: CUTS FROM START ................................ (Automatic in Mode 2) If elements are cut short, trim from the start, retaining the end of the source.\n");
        fprintf(stdout,"INFO:                                                                           (Default, trim from the end, retaining the start of the source).\n");
        break;
    case(DISTMARK):
        fprintf(stdout,"INFO: INTERPOLATE BETWEEN WAVESETS AT MARKED TIMES IN (MONO) SOURCE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIME MARKS IN SOURCE ..................... Times in source at which wavesets are to be selected.\n");
        fprintf(stdout,"INFO: WAVESETGROUP LENGTH(mS) ............... Approximate length, in mS, of waveset group to find (time-variable).\n");
        fprintf(stdout,"INFO: TIMESTRETCH ....................................... Timestretch (in output file) of steps between marks in source (time-variable).\n");
        fprintf(stdout,"INFO: GROUPLENGTH RANDOMISATION ........... Randomisation of lengths of interpolated wavesets (time-variable).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: RETROGRADE AND PHASE INVERT ALTERNATE WAVESETS (Tends to lower the pitch).\n");
        fprintf(stdout,"INFO: RETAIN ORIGINAL TAIL ..................... Once the final marker is reached, the remainder of the source is copied to the output.\n");
        fprintf(stdout,"INFO: ATTENUATION OF DISTORTED REGIONS ... reduction of level of the distorted segments relative to the undistorted.\n");
        fprintf(stdout,"INFO: RETAIN ORIGINAL TAIL ..................... Once the final marker is reached, the remainder of the source is copied to the output.\n");
        fprintf(stdout,"INFO:                                                                                 (Any source-sound before the first marker is also copied into the output).\n");
        fprintf(stdout,"INFO: SWITCH RETAINED AND DISTORTED ELEMENTS ...Switch which set of elements is distorted, and which is undistorted.\n");
        break;
    case(DISTREP):
        fprintf(stdout,"INFO: REPEAT (GROUPS OF) WAVESETS, USING SPLICES TO SMOOTH TRANSITIONS..\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Each (group of) waveset(s), in turn, is repeated.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (2)  After the first repetition-set, the process jumps to a time in the input corresponding to the time at end of current output\n");
        fprintf(stdout,"INFO:            and selects its next waveset from there, so the output is not time-dilated relative to the input.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: REPETITION COUNT ................................ Number of times to repeat each waveset(group). Can vary over time.\n");
        fprintf(stdout,"INFO: COUNT OF WAVESETS IN GROUP TO REPEAT .. How many wavesets, as a group, to repeat. Can vary over time.\n");
        fprintf(stdout,"INFO: WAVESETS TO SKIP AT START .................... Number of wavesets to ignore at file start.\n");
        fprintf(stdout,"INFO: SPLICELENGTH (mS) ................................. Length of splices, in milliseconds (0 to 50, default 15).\n");
        break;
    case(TOSTEREO):
        fprintf(stdout,"INFO: MOVE STEREO SOURCE FROM A MONO-MERGE TO TRUE STEREO, OR VICE VERSA, AND POSSIBLY INTO A MULTICHANNEL SPACE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: There are 4 possible processes.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  The stereo signal starts out merged into mono, the same signal being presented on BOTH channels of the original stereo image,\n");
        fprintf(stdout,"INFO:          and the true stereo image gradually emerges on the same 2 channels.\n");
        fprintf(stdout,"INFO: (2)  The stereo signal starts out as true stereo on a pair of channels and is gradually merged into mono,\n");
        fprintf(stdout,"INFO:          the same merged signal being presented on both of these channels.\n");
        fprintf(stdout,"INFO: (3)  The stereo signal starts out merged into mono, the merged signal being presented on a SINGLE mono channel,\n");
        fprintf(stdout,"INFO:          and the true stereo image gradually emerges onto the TWO ADJACENT CHANNELS (only) : the signal \"FORKS\".\n");
        fprintf(stdout,"INFO: (4)  The stereo signal starts out as true stereo on 2 channels SEPARATED BY an empty INTERVENING CHANNEL,\n");
        fprintf(stdout,"INFO:          and is gradually merged into a mono signal, presenting only on the intermediate channel.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Options (3) and (4) are only available if the count of \"OUTPUT CHANNELS\" is set greater than 2.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: DIVERGE START TIME .......................... Time of start of divergence from mono-merged signal (moving towards true stereo).\n");
        fprintf(stdout,"INFO: DIVERGE END TIME .............................  Time of complete emergence of true stereo.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If the \"DIVERGE\" times are IN REVERSED ORDER, the signal will gradually MERGE FROM stereo INTO mono.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OUTPUT CHANNELS ............................. Number of channels of output file.\n");
        fprintf(stdout,"INFO: LEFT CHANNEL TO : or FORK FROM .......... Channel to which original Left stereo channel is routed in output stereo image\n");
        fprintf(stdout,"INFO:                                                                          OR Channel from which signal Forks.\n");
        fprintf(stdout,"INFO: RIGHT CHANNEL TO ............................. Channel to which original Right stereo channel is routed in output stereo image.\n");
        fprintf(stdout,"INFO:                                                                          If set to ZERO and \"OUTPUT CHANNELS\" is greater than Stereo,\n");
        fprintf(stdout,"INFO:                                                                          output will FORK from \"FORK FROM\" channel to channels on either side.\n");
        fprintf(stdout,"INFO: CHANNEL LEVELS IN MIX TO MONO ........... Level of each of the separated channel signals when mix-merged to mono.\n"); 
        fprintf(stdout,"INFO:                                                                          A ZERO value sets a DEFAULT LEVEL. Otherwise, levels below 0.5 are invalid.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SUPPRESS):
        fprintf(stdout,"INFO: SUPPRESS THE MOST PROMINENT PARTIALS IN THE FRQ BAND, AND AT THE TIMES, INDICATED\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TIMESLOTS .......................... Textfile of time-pairs indicating start & end of timeslots where action is to be taken.\n");
        fprintf(stdout,"INFO: BAND LOW FREQUENCY ....... Frequency of BOTTOM of band in which partials are to be suppressed.\n");
        fprintf(stdout,"INFO: BAND HIGH FREQUENCY ..... Frequency of TOP of band in which partials are to be suppressed.\n");
        fprintf(stdout,"INFO: PARTIALS TO SUPPRESS ... The number of partials to suppress.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CALTRAIN):
        fprintf(stdout,"INFO: BLUR THE HIGH FREQUNCY COMPONENTS OF THE SPECTRUM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: AVERAGE OVER TIME (SECS) .. Time in seconds over which upper frequncy data is averaged.\n");
        fprintf(stdout,"INFO: BLUR ABOVE FRQ (HZ) ............ Frequency (Hz) above which spectrum is blurred.\n");
        fprintf(stdout,"INFO: CUT BASS BELOW FRQ (HZ) .... Frequencies below this in the spectrum are suppressed.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECENV):
        fprintf(stdout,"INFO: APPLY SPECTRAL ENVELOPE OF FILE2 TO FILE1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: WINDOWSIZE (ANALCHANCNT OR OCTAVES) ...... frequency-width of the windows used to extract the spectral envelope.\n");
        fprintf(stdout,"INFO:                                                                                     Either the number of analysis channels per window, or the window-width in octaves.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: BALANCE WITH SOURCES .............................. Ammount of original sources to mix into the transformed output.\n");
        fprintf(stdout,"INFO:                                                                                     Values > 0 are the ratio of sourcefile 1 in the final mix.\n");
        fprintf(stdout,"INFO:                                                                                     Values < 0 are converted to positive values and are then the ratio of sourcefile 2 in the mix.\n");
        fprintf(stdout,"INFO:                                                                                     Default value is zero (none of either source is mixed into the output).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: READ WINDOWSIZE AS OCTAVES .................... Default: windowsize is the number of analysis channels per window.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: IMPOSE SPECTRAL ENVELOPE ......................... Impose spectral envelope of file 2 OVER that of file 1. Default is to REPLACE that of file 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: LOUDNESS CONTOUR FOLLOWS FILE 2 .............. Default is to follow the loudness contour of File 1.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: If the window-amplitude of file 2 (but not file 1) falls below a (near-to-zero) threshold, the file 1 window is passed through with no processing.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(CLIP):
        fprintf(stdout,"INFO: CLIP PEAKS OF SOUND (DISTORTION).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  Clip at given signal level.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (2)  Clip every waveset at given fraction of its maximum height.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CLIP LEVEL (Mode 1)....... Signal level at which input sound is clipped.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: CLIP LEVEL (Mode 2) .......Fraction of maximum height of each waveset at which (all) wavesets are clipped.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECEX):
        fprintf(stdout,"INFO: TIMESTRETCH SEGMENT OF ANALYSIS FILE WITH RANDOMISATION OF WINDOWS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: STARTTIME OF REGION TO STRETCH ...................... Time in source where region to be stretched begins.\n");
        fprintf(stdout,"INFO: DURATION OF REGION TO STRETCH ......................... Duration of region to be stretched.\n");
        fprintf(stdout,"INFO: TIME STRETCHING RATIO ......................................... Time stretch to apply (at least 2).\n");
        fprintf(stdout,"INFO: NO OF WINDOWS IN GROUPS-FOR-PERMUTATION ... Time-stretching repeats selected region, but with windows randomly permuted.\n");
        fprintf(stdout,"INFO:                                                                                      Windows can be collected into groups, and these groups permuted.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: INCLUDE SOUND BEFORE STRETCHED PORTION ........... Sound before stretched portion is retained.\n");
        fprintf(stdout,"INFO: INCLUDE SOUND AFTER STRETCHED PORTION ............. Sound after stretched portion is retained.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(MATRIX):
        fprintf(stdout,"INFO: SPECTRALLY WARP SOUNDFILE, USING UNITARY MATRIX, OR OTHERWISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  GENERATE (SAVE TO FILE) AND USE A RANDOM UNITARY MATRIX.\n");
        fprintf(stdout,"INFO: (2)  USE AN EXISTING UNITARY MATRIX FILE.\n");
        fprintf(stdout,"INFO: (3)  SWAP AMPLITUDE AND PHASE VALUES OF FFT.\n");
        fprintf(stdout,"INFO: (4)  INVERT (x MINUS 1) PHASE VALUES IN FFT .\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS IF NOT IN MODE 2----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ANALYSIS POINTS..(2-32768 (power of 2)): default 1024\n");
        fprintf(stdout,"INFO: .................More points give better freq resolution\n");
        fprintf(stdout,"INFO: .................but worse time-resolution (e.g. rapidly changing spectrum).\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: OVERLAP..........Filter overlap factor (1-4): default 3\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(TRANSPART):
        fprintf(stdout,"INFO: TRANSPOSE OR SHIFT ONLY PART OF SPECTRUM, ABOVE OR BELOW A GIVEN FREQUNCY.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  TRANSPOSE ABOVE FRQ, RETAINING ORIGINAL FORMANTS.\n");
        fprintf(stdout,"INFO: (2)  TRANSPOSE BELOW FRQ, RETAINING ORIGINAL FORMANTS.\n");
        fprintf(stdout,"INFO: (3)  TRANSPOSE ABOVE FRQ, ALSO MOVING FORMANTS.\n");
        fprintf(stdout,"INFO: (4)  TRANSPOSE BELOW FRQ, ALSO MOVING FORMANTS.\n");
        fprintf(stdout,"INFO: (5)  FREQUENCY SHIFT ABOVE FRQ, RETAINING ORIGINAL FORMANTS.\n");
        fprintf(stdout,"INFO: (6)  FREQUENCY SHIFT BELOW FRQ, RETAINING ORIGINAL FORMANTS.\n");
        fprintf(stdout,"INFO: (7)  FREQUENCY SHIFT ABOVE FRQ, ALSO MOVING FORMANTS.\n");
        fprintf(stdout,"INFO: (8)  FREQUENCY SHIFT BELOW FRQ, ALSO MOVING FORMANTS.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FOR TRANSPOSITION\n");
        fprintf(stdout,"INFO: TRANSPOSITION IN SEMITONES ............ Semitone transposition. Range : 4 octaves, up or down.\n");
        fprintf(stdout,"INFO: FOR FREQUENCY SHIFTING\n");
        fprintf(stdout,"INFO: FREQUNCY SHIFT IN HZ ..................... Frequency shift in Hz. Range : (nyquist/4) up or down.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ABOVE/BELOW THIS FREQUENCY ONLY .. Frq above/below which spectrum shifted (Range: 5 to nyquist/2)\n");
        fprintf(stdout,"INFO: OVERALL GAIN ............................... Range : 0.1 to 1.0\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECINVNU):
        fprintf(stdout,"INFO: INVERT THE SPECTRAL AMPLITUDES OVER A SPECIFIED RANGE OF THE SPECTRUM\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: The spectral inversion is over a range of frequencies (a \"region\") which you specify (params 1 & 2).\n");
        fprintf(stdout,"INFO: You must also search for the spectral peak lying between 0Hz and a cutoff frequency (param 3)\n");
        fprintf(stdout,"INFO: This peak is used to create a spectral-amplitude-envelope, used to rebalance the inverted spectrum.\n");
        fprintf(stdout,"INFO: Parameter (3) must lie between the Start Frq of the region (param 1)\n");
        fprintf(stdout,"INFO: and the halfway-point frequency of that region.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  START FRQ OF REGION TO INVERT ................. Range : 0 to nyquist/2\n");
        fprintf(stdout,"INFO: (2)  END FRQ OF REGION TO INVERT .................... Range : 100 to nyquist.\n");
        fprintf(stdout,"INFO: (3)  TOP FRQ TO END SEARCH FOR SPECTRAL PEAK .. Range : 0 to nyquist\n");
        fprintf(stdout,"INFO: (4)  GAIN ...................................................... Range : 0.1 to 1.0\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECCONV):
        fprintf(stdout,"INFO: EXPERIMENTAL CONVOLUTION PROCESS (NOT RECOMMENDED)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1 : CONVOLVE SOUND WITH ITSELF\n");
        fprintf(stdout,"INFO: MODE 2 : CONVOLVE SOUND WITH ANOTHER, EQUAL LENGTH OR SHORTER, SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  OVERALL GAIN ........................... Range : 0.1 to 10.0\n");
        fprintf(stdout,"INFO: (2)  APPLY PROCESS THIS MANY TIMES .. Range : (Mode 1) 1 to 10  (Mode 2) 1 to 2.\n");
        fprintf(stdout,"INFO: (3)  DON'T TIME-STRETCH FILE 2 ......... (Mode 2 ONLY)\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECSND):
        fprintf(stdout,"INFO: TREAT SPECTRUM AS IF IT WERE A SOUND\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Spectral envelope is treated as a waveform.\n");
        fprintf(stdout,"INFO: Ouput pitch derives from maximum amplitude in the spectrum.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: (1)  MINIMUM UPWARD TRANSPOSITION IN OCTAVES .... Range : 0 to 8\n");
        fprintf(stdout,"INFO: (2)  MAXIMUM UPWARD TRANSPOSITION IN OCTAVES .... Range : 1 to 8.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(SPECFRAC):
        fprintf(stdout,"INFO: CREATE FRACTAL VERSION OF SPECTRUM.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NB Ouput sounds depend on number of analysis channels used in source.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1 : Abutt 2 copies, then shrink to orig size by time-contraction.\n");
        fprintf(stdout,"INFO: MODE 2 : Abutt copy with reverse-copy, then shrink by time-contraction.\n");
        fprintf(stdout,"INFO: MODE 3 : As mode 2, but cut into segments and process each segment in turn.\n");
        fprintf(stdout,"INFO: MODE 4 : As mode 3, but shrink by averaging.\n");
        fprintf(stdout,"INFO: MODE 5 : Swap two halves of segments.\n");
        fprintf(stdout,"INFO: MODE 6 : Reverse 2nd half of segments.\n");
        fprintf(stdout,"INFO: MODE 7 : Interleave two halves of segments.\n");
        fprintf(stdout,"INFO: MODE 8 : Reverse 2nd half of segments, then interleave.\n");
        fprintf(stdout,"INFO: MODE 9 : Interleave, retaining original speed.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: NUMBER OF FRACTAL LAYERS .................. Number of times fractalisation process applied.\n");
        fprintf(stdout,"INFO: OUTPUT ALL INTERMEDIATE FRACTALS .. Outputs sound made at each intermediate stage of fractalisation.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ENVSPEAK):
        fprintf(stdout,"INFO: PROCESS SPEECH \"SYLLABLE\"-WISE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES 1-12  Extract the \"syllables\" by an automatic envelope-tracking process.\n");
        fprintf(stdout,"INFO: MODES 13-24 Expects a File specifying the necessary cut-times to separate the sound into syllables.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: 1 & 13 : Repeat each syllable, N times.\n");
        fprintf(stdout,"INFO: 2 & 14 : Reverse-repeat each syllable.\n");
        fprintf(stdout,"INFO: 3 & 15 : Attenuate N in N+1 syllables.\n");
        fprintf(stdout,"INFO: 4 & 16 : Attenuate all except N in N+1 syllables.\n");
        fprintf(stdout,"INFO: 5 & 17 : Repeat each syllable N times, shrinking from its end, on each repeat, by 1/Nth.\n");
        fprintf(stdout,"INFO: 6 & 18 : Repeat each syllable N times, shrinking from its start, on each repeat, by 1/N.\n");
        fprintf(stdout,"INFO: 7 & 19 : Divide each syllable into N parts, and repeat just one of those parts, N times.\n");
        fprintf(stdout,"INFO: 8 & 20 : For each syllable, repeat it, shrinking from its end by a specified Ratio.\n");
        fprintf(stdout,"INFO: 9 & 21 : For each syllable, repeat it, shrinking from its start by a specified Ratio.\n");
        fprintf(stdout,"INFO: 10 & 22 : Extract all the syllables.\n");
        fprintf(stdout,"INFO: 11 & 23 : Randomly reorder the syllables.\n");
        fprintf(stdout,"INFO: 12 & 24 : Reverse order of first N syllable , then order of 2nd N syllable,  etc.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (mS) (Modes 1-12 ONLY) ........... Size of envelope-search window in mS (default 50).\n");
        fprintf(stdout,"INFO: SYLLABLE CUT TIMES (secs) (Modes 13-24 ONLY).............. Position of cuts (except at zero and end of file) to separate the syllables.\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (mS) ............................................... Splice length in mS (default 15) \n");
        fprintf(stdout,"INFO: INITIAL SYLLABLES TO SKIP ....................................... Number of syllables at sound start to send to output UNCHANGED.\n");
        fprintf(stdout,"INFO: NUMBER OF REPETITIONS ........................................ Number of repetitions of each syllable (Range 2 upwards).\n");
        fprintf(stdout,"INFO: N (ATTEN N in every N+1 SYLLABLES) ........................... Size of Each Group of syllables to attenuate : N = 3 means attenuate 3 in every 4.\n");
        fprintf(stdout,"INFO: N (DON'T ATTEN N in every N+1 SYLLABS) .....................  Size of Each Group of syllables NOT to attenuate : N = 3 means DON'T attenuate 3 in every 4.\n");
        fprintf(stdout,"INFO: GAIN ON ATTENUATED SYLLABLES ............................... Reduce the level of Attenuated syllables by this number of dBs: (Range -96 to < 0)\n");
        fprintf(stdout,"INFO: NO OF PARTS TO DIVIDE SYLLABLES INTO .....................  For each syllable, Keep 1/Nth part, and repeat that part N times.\n");
        fprintf(stdout,"INFO: WHICH DIVIDED ELEMENT TO USE ............................... Which division of the divided-sylllable to repeat (Range 1 to N)\n");
        fprintf(stdout,"INFO: CONTRACTION RATIO ............................................. Reduce length of repeated elements by this Ratio : Range (> 0.0 to 1)\n");
        fprintf(stdout,"INFO: DEGREE OF RANDOMISATION, LENGTHS OF REPET UNITS .. Degree of Randomisation of the lengths of repeated units.\n");
        fprintf(stdout,"INFO: REVERSE ORDER IN GROUPS OF ................................. Reverse the order order of the first N syllables, then the order of the 2nd N, and so on ....\n");
        fprintf(stdout,"INFO: SEED FOR RANDOM PERMUTATION ............................. (Modes 11 only) Initialises the random number generator for Random reorderings of the syllables.\n");
        fprintf(stdout,"INFO:                                                                                                   If the Seed is NOT 0, using the same seed again on a future pass gives IDENTICAL random output.\n");
        fprintf(stdout,"INFO: REPEATED ELEMENTS DO NOT GROW IN SIZE ................. (Mode 7 only) with many divisions, may give a mechanical or buzzing quality to the ouptut.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(EXTSPEAK):
        fprintf(stdout,"INFO: OVERWRITE OR REPLACE SPEECH SYLLABLES WITH ALTERNATIVE \"SYLLABLES\"\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------------------------------------MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: FINDING THE ORIGINAL SYLLABLES IN INPUT FILE 1.\n");
        fprintf(stdout,"INFO:            In Modes 1-6 the \"syllables\" in file-1 are extracted by an automatic process using the ENVELOPE WINDOW SIZE parameter.\n");
        fprintf(stdout,"INFO:                                  Results may be good enough for some applications, but not as good as ...\n");
        fprintf(stdout,"INFO:            In Modes 7-18 the syllable-boundaries in file-1 are marked \"by hand\" on a graphic of the original soundfile.\n");
        fprintf(stdout,"INFO:                                  Markers at time zero, and at the end of the sound are not required.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: USE OF THE NEW SYLLABLES, FROM INPUT FILES 2,3 ....\n");
        fprintf(stdout,"INFO:            In Modes 1-3,7-9     new syllables REPLACE, or are INJECTED BETWEEN, the original syllables.\n");
        fprintf(stdout,"INFO:            In Modes 4-6,10-12 new syllables MIX INTO the original syllables.\n");
        fprintf(stdout,"INFO:            In Modes 13-15        new syllables REPLACE the SPECIFIED original syllables.\n");
        fprintf(stdout,"INFO:            In Modes 16-18        new syllables MIX INTO the SPECIFIED original syllables.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ORDER OF THE NEW SYLLABLES.\n");
        fprintf(stdout,"INFO:            Modes 1,4,7,10,13,16:  Insert syllables in the Order of the input files. Or (\"SELECT INSERTS AT RANDOM\") Entirely at Random.\n");
        fprintf(stdout,"INFO:            Modes 2,5,8,11,14,17:  Insert ALL syllables in the input files in some random order, then permute that order before adding more syllables, and so on.\n");
        fprintf(stdout,"INFO:            Modes 3,6,9,12,15,18:  Insert syllables in a specific pattern, specified in the Pattern File.\n");
        fprintf(stdout,"INFO:                                                   For example : Pattern \"1 5 2\" means insert syllables 1,5 and 2 from the input list, in that order, then repeat (so 1 5 2 1 5 2 1 ....etc.)\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------------------------------------INPUT DATA (Scroll down for MORE)---------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Many of the modes require you to enter data in a TEXT FILE.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:            SYLLABLE BOUNDARY TIMES   Modes 7-18             This LIST OF TIMES indicate where file1 is to be divided, to produce separate syllables.\n");
        fprintf(stdout,"INFO:                                                                                             You do not need to indicate a cut at zero time or at the file end (if you do, these are ignored).\n");
        fprintf(stdout,"INFO:                                                                                             there is one cut for the END of each syllable, and the area after the last cut is a final syllable.\n");
        fprintf(stdout,"INFO:                                                                                             So with C cuts, there will be C+1 syllables.\n");
        fprintf(stdout,"INFO:                                                                                             IN OTHER MODES \"syllables\" are cut automatically,\n");
        fprintf(stdout,"INFO:                                                                                             using the ENVELOPE WINDOW SIZE parameter to scan the loudness envelope of the input file.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:            PATTERN OF INSERTS        Modes 3,6,8,12,15      This LIST OF NUMBERS indicates the order of the syllables to be added.\n");
        fprintf(stdout,"INFO:                                                                                             The pattern \"2  5  1\" means add syllable 2, then syllable 5, then syllable 1: And then repeat this pattern as long as necessary.\n");
        fprintf(stdout,"INFO:                            OTHERWISE:     Modes 1,4,7,10,13,16  Uses the new syllables in the order you enter them on the \"Chosen Files\" listing EXCEPT \n");
        fprintf(stdout,"INFO:                                                                                             with the \"SELECT INSERTS AT RANDOM\" flag, which causes new syllables to be selected entirely randomly.\n");
        fprintf(stdout,"INFO:                                                      Modes 2,5,8,11,14,17   Uses ALL new syllables in some random order, before creating a different random order and using ALL the files again, and so on ...\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:            SYLLABLES TO TARGET     Modes 12 - 18                This LIST OF NUMBERS indicates which of the syllables in the first infile are to reaplaced, or mixed-over by the syllables in the other files.\n");
        fprintf(stdout,"INFO:                            OTHERWISE:                                           This is determined by the parameter \"N\" and the Flag \"N = RETAIN ...\".\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO:            Note that, in some modes 2 or 3 of these data sets are required, in the SAME textfile. In this case THE DATA SETS ARE SEPARATED BY A LINE WITH A SINGLE \"#\" CHARACTER.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------------------------------------PARAMETERS (Scroll down for MORE)---------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (mS) ...................................... Size of envelope-search window in mS (default 50).\n");
        fprintf(stdout,"INFO: SPLICE LENGTH (mS) .................................................. Splice length for cutting and joining syllables, in mS (default 15) \n");
        fprintf(stdout,"INFO: INITIAL SYLLABLES TO SKIP .......................................... Number of syllables at sound start to send to the output UNCHANGED.\n");
        fprintf(stdout,"INFO: N = RETAIN 1 ORIG SYLLAB FOR EVERY N OVERWRITTEN ...... Size of Group replaced/overwritten/inserted : N = 3 means r-o-i 3 in every 4  (BUT see \"-k\" Flag)\n");
        fprintf(stdout,"INFO: OVERALL ATTENUATION OF INSERTED SYLLABLES ............... Reduce the level of the new syllables by this number of dBs: (Range -96 to < 0)\n");
        fprintf(stdout,"INFO: (NOT Modes 3,6,9,12,15,18) SEED FOR RANDOM GENERATOR Initialises the random number generator for Random reorderings of the syllables.\n");
        fprintf(stdout,"INFO:                                                                                                        If the Seed is NOT 0, using the same seed again on a future pass gives IDENTICAL random output.\n");
        fprintf(stdout,"INFO: N = RETAIN N ORIG SYLLABS FOR EVERY 1 OVERWRITTEN .... Changes the meaning of the Parameter N.\n");
        fprintf(stdout,"INFO:                                                                                                       (see the examples below).\n");
        fprintf(stdout,"INFO: TRANSPOSE (RATHER THAN CUT TO SIZE) INSERTS ............. Default option cuts (or pads with zeros) the resized syllables.\n");
        fprintf(stdout,"INFO: FOLLOW ENVELOPE OF OVERWRITTEN SYLLABLES ............... Inserted syllables follow level-contour of original syllables.\n");
        fprintf(stdout,"INFO: INSERT BETWEEN (RATHER THAN OVERWRITE) .................. Don't overwrite/mix-into the original syllables. INSERT the new syllables After the existing syllables.\n");
        fprintf(stdout,"INFO:                                                                                                       (see the examples below).\n");
        fprintf(stdout,"INFO: RETAIN ORIGINAL DURATION OF INSERTS ........................ This option (typically) changes the duration and rhythm of the output relative to that of the (1st) input file.\n");
        fprintf(stdout,"INFO:                                                                                                        Default option RESIZES the inserted syllables to match the durations of the replaced syllables.\n");
        fprintf(stdout,"INFO: (Modes 1,4,7,10,13,16) SELECT INSERTS AT RANDOM .......... Select next syllable to insert, from the input syllable-files, ENTIRELY at random.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ----------------------------------------------------------HOW THE N-patterning WORKS---------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: STARTING WITH A SET OF 9 SYLLABLES USING A VALUE N=2: ..... S S S S S S S S S\n");
        fprintf(stdout,"INFO:                                         NO FLAGS gives .............................. S x x S x x S x x\n");
        fprintf(stdout,"INFO:                                         \"N = RETAIN ...\" FLAG gives ............... S S x S S x S S x\n");
        fprintf(stdout,"INFO:                                         \"INSERT ...\" FLAG gives ....................  S x x S x x S x x S x x S x x S x x S x x S x x S x x\n");
        fprintf(stdout,"INFO:                                         Using BOTH OF THESE FLAGS gives ....... S S x S S x S S x S S x S\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(ENVSCULPT):
        fprintf(stdout,"INFO: SCULPT SHARP ATTACK FROM SYLLABLE\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MODE 1 : SCULPT AN EVENT\n");
        fprintf(stdout,"INFO: MODE 2 : SCULPT A USER-SPECIFIED DOUBLE-EVENT (e.g. Consonant-Vowel) .\n");
        fprintf(stdout,"INFO: MODE 3 : SCULPT A DOUBLE-EVENT AUTOMATICALLY.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (mS) ................. Window Size for extracting envelope (1-64 dflt 20)\n");
        fprintf(stdout,"INFO: RISE TIME (mS) ................................... (Max) Duration of attack onset (mS).\n");
        fprintf(stdout,"INFO: DECAY DURATION ................................ Maximum time to reach zero after the attack peak.\n");
        fprintf(stdout,"INFO: STEEPNESS  ........................................ Steepness of decay : 1 = linear, > 1 steeper.\n");
        fprintf(stdout,"INFO: CONSONANT DECAY START ..................... Time at which sound after 1st attack can start to fall to zero.\n");
        fprintf(stdout,"INFO: CONSONANT DECAY END ........................ End time of decay-to-zero after 1st attack.\n");
        fprintf(stdout,"INFO: LOUDNESS RATIO OF 1st TO 2nd ATTACKS .. Ratio of loudness of First attack to loudness of Second (Dflt 1).\n");
        fprintf(stdout,"INFO: ATTACK 2nd PEAK ONLY (Mode 3) ............. Peak One is isolated, but with no Attack.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(TREMENV):
        fprintf(stdout,"INFO: TREMOLO A SOUND AFTER ITS PEAK, WITH TREMOLO-WIDTH NARROWING.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: TREMOLO FREQUENCY ....................... is frequency of the tremolo vibration itself.\n");
        fprintf(stdout,"INFO: TREMOLO DEPTH ............................... amplitude depth of tremolo.\n");
        fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (mS) ....... Window Size for extracting envelope (1-64 dflt 20)\n");
        fprintf(stdout,"INFO: PEAK NARROWING .................. Tremolo peaks can be made narrower.\n");
        fprintf(stdout,"INFO: \n");
        break;
    case(DCFIX):
        fprintf(stdout,"INFO: REMOVE DC SIGNAL FROM A DISTORTED SOUND.\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: Use with \"Distort Multiply\".\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
        fprintf(stdout,"INFO: \n");
        fprintf(stdout,"INFO: MINIMUM DURATION OF DC (mS) ...... Minimu duration of any block of DC signal to be removed.\n");
        fprintf(stdout,"INFO: \n");
        break;
    default:
        fprintf(stdout,"ERROR: Unknown PROCESS\n");
        fprintf(stdout,"INFO: \n");
        break;
    }
    return 0;
}

void RoomReverbFormat(void)
{
    fprintf(stdout,"INFO: DELAY TIMES AMPS (& POSITIONS). A Text Datafile.\n");
    fprintf(stdout,"INFO:       Each line has either 2 vals (TIME , AMP of one of delays) or 3 (3rd is spatial POSITION in stereo space).\n");
    fprintf(stdout,"INFO:       TIMES (seconds) must be increasing. Duplicate times are ignored.\n");
    fprintf(stdout,"INFO:       A zero time (no delay) overrides the mix parameter, and determines the level and pan of the (effectively mono) input.\n");
    fprintf(stdout,"INFO:       AMP values must be in the range 0.0 to 1.0\n");
    fprintf(stdout,"INFO:       Empty lines and lines starting with a semi-colon (e.g. comments) are permitted.\n");
    fprintf(stdout,"INFO:       If a Position value is used in any line, outfile will be stereo.\n");
    fprintf(stdout,"INFO:       POSITION values are nominally in the range -1 to +1:     0 = centre.  If all position values are 0, the output will be mono.\n");
    fprintf(stdout,"INFO:       Values beyond these limits result in attenuation according to the inverse-square law, to suggest distance beyond the speakers.\n");
}
